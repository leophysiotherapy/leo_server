
/**
 * Client
**/

import * as runtime from '@prisma/client/runtime/library';
import $Types = runtime.Types // general types
import $Public = runtime.Types.Public
import $Utils = runtime.Types.Utils
import $Extensions = runtime.Types.Extensions
import $Result = runtime.Types.Result

export type PrismaPromise<T> = $Public.PrismaPromise<T>


/**
 * Model user
 * 
 */
export type user = $Result.DefaultSelection<Prisma.$userPayload>
/**
 * Model services
 * 
 */
export type services = $Result.DefaultSelection<Prisma.$servicesPayload>
/**
 * Model otp
 * 
 */
export type otp = $Result.DefaultSelection<Prisma.$otpPayload>
/**
 * Model appointment
 * 
 */
export type appointment = $Result.DefaultSelection<Prisma.$appointmentPayload>
/**
 * Model equipment
 * 
 */
export type equipment = $Result.DefaultSelection<Prisma.$equipmentPayload>
/**
 * Model blogs
 * 
 */
export type blogs = $Result.DefaultSelection<Prisma.$blogsPayload>
/**
 * Model faqs
 * 
 */
export type faqs = $Result.DefaultSelection<Prisma.$faqsPayload>
/**
 * Model avatar
 * 
 */
export type avatar = $Result.DefaultSelection<Prisma.$avatarPayload>
/**
 * Model profile
 * 
 */
export type profile = $Result.DefaultSelection<Prisma.$profilePayload>
/**
 * Model diagnosis
 * 
 */
export type diagnosis = $Result.DefaultSelection<Prisma.$diagnosisPayload>
/**
 * Model presciption
 * 
 */
export type presciption = $Result.DefaultSelection<Prisma.$presciptionPayload>
/**
 * Model feedback
 * 
 */
export type feedback = $Result.DefaultSelection<Prisma.$feedbackPayload>
/**
 * Model prediag
 * 
 */
export type prediag = $Result.DefaultSelection<Prisma.$prediagPayload>

/**
 * Enums
 */
export namespace $Enums {
  export const roles: {
  patient: 'patient',
  admin: 'admin',
  staff: 'staff'
};

export type roles = (typeof roles)[keyof typeof roles]


export const platform: {
  online: 'online',
  f2f: 'f2f'
};

export type platform = (typeof platform)[keyof typeof platform]


export const status: {
  upcoming: 'upcoming',
  done: 'done',
  finished: 'finished',
  canceled: 'canceled'
};

export type status = (typeof status)[keyof typeof status]


export const inventory: {
  equipment: 'equipment',
  supplies: 'supplies'
};

export type inventory = (typeof inventory)[keyof typeof inventory]

}

export type roles = $Enums.roles

export const roles: typeof $Enums.roles

export type platform = $Enums.platform

export const platform: typeof $Enums.platform

export type status = $Enums.status

export const status: typeof $Enums.status

export type inventory = $Enums.inventory

export const inventory: typeof $Enums.inventory

/**
 * ##  Prisma Client ʲˢ
 * 
 * Type-safe database client for TypeScript & Node.js
 * @example
 * ```
 * const prisma = new PrismaClient()
 * // Fetch zero or more Users
 * const users = await prisma.user.findMany()
 * ```
 *
 * 
 * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client).
 */
export class PrismaClient<
  T extends Prisma.PrismaClientOptions = Prisma.PrismaClientOptions,
  U = 'log' extends keyof T ? T['log'] extends Array<Prisma.LogLevel | Prisma.LogDefinition> ? Prisma.GetEvents<T['log']> : never : never,
  ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
> {
  [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['other'] }

    /**
   * ##  Prisma Client ʲˢ
   * 
   * Type-safe database client for TypeScript & Node.js
   * @example
   * ```
   * const prisma = new PrismaClient()
   * // Fetch zero or more Users
   * const users = await prisma.user.findMany()
   * ```
   *
   * 
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client).
   */

  constructor(optionsArg ?: Prisma.Subset<T, Prisma.PrismaClientOptions>);
  $on<V extends U>(eventType: V, callback: (event: V extends 'query' ? Prisma.QueryEvent : Prisma.LogEvent) => void): void;

  /**
   * Connect with the database
   */
  $connect(): $Utils.JsPromise<void>;

  /**
   * Disconnect from the database
   */
  $disconnect(): $Utils.JsPromise<void>;

  /**
   * Add a middleware
   * @deprecated since 4.16.0. For new code, prefer client extensions instead.
   * @see https://pris.ly/d/extensions
   */
  $use(cb: Prisma.Middleware): void

/**
   * Executes a prepared raw query and returns the number of affected rows.
   * @example
   * ```
   * const result = await prisma.$executeRaw`UPDATE User SET cool = ${true} WHERE email = ${'user@email.com'};`
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $executeRaw<T = unknown>(query: TemplateStringsArray | Prisma.Sql, ...values: any[]): Prisma.PrismaPromise<number>;

  /**
   * Executes a raw query and returns the number of affected rows.
   * Susceptible to SQL injections, see documentation.
   * @example
   * ```
   * const result = await prisma.$executeRawUnsafe('UPDATE User SET cool = $1 WHERE email = $2 ;', true, 'user@email.com')
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $executeRawUnsafe<T = unknown>(query: string, ...values: any[]): Prisma.PrismaPromise<number>;

  /**
   * Performs a prepared raw query and returns the `SELECT` data.
   * @example
   * ```
   * const result = await prisma.$queryRaw`SELECT * FROM User WHERE id = ${1} OR email = ${'user@email.com'};`
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $queryRaw<T = unknown>(query: TemplateStringsArray | Prisma.Sql, ...values: any[]): Prisma.PrismaPromise<T>;

  /**
   * Performs a raw query and returns the `SELECT` data.
   * Susceptible to SQL injections, see documentation.
   * @example
   * ```
   * const result = await prisma.$queryRawUnsafe('SELECT * FROM User WHERE id = $1 OR email = $2;', 1, 'user@email.com')
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $queryRawUnsafe<T = unknown>(query: string, ...values: any[]): Prisma.PrismaPromise<T>;

  /**
   * Allows the running of a sequence of read/write operations that are guaranteed to either succeed or fail as a whole.
   * @example
   * ```
   * const [george, bob, alice] = await prisma.$transaction([
   *   prisma.user.create({ data: { name: 'George' } }),
   *   prisma.user.create({ data: { name: 'Bob' } }),
   *   prisma.user.create({ data: { name: 'Alice' } }),
   * ])
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/concepts/components/prisma-client/transactions).
   */
  $transaction<P extends Prisma.PrismaPromise<any>[]>(arg: [...P], options?: { isolationLevel?: Prisma.TransactionIsolationLevel }): $Utils.JsPromise<runtime.Types.Utils.UnwrapTuple<P>>

  $transaction<R>(fn: (prisma: Omit<PrismaClient, runtime.ITXClientDenyList>) => $Utils.JsPromise<R>, options?: { maxWait?: number, timeout?: number, isolationLevel?: Prisma.TransactionIsolationLevel }): $Utils.JsPromise<R>


  $extends: $Extensions.ExtendsHook<'extends', Prisma.TypeMapCb, ExtArgs>

      /**
   * `prisma.user`: Exposes CRUD operations for the **user** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Users
    * const users = await prisma.user.findMany()
    * ```
    */
  get user(): Prisma.userDelegate<ExtArgs>;

  /**
   * `prisma.services`: Exposes CRUD operations for the **services** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Services
    * const services = await prisma.services.findMany()
    * ```
    */
  get services(): Prisma.servicesDelegate<ExtArgs>;

  /**
   * `prisma.otp`: Exposes CRUD operations for the **otp** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Otps
    * const otps = await prisma.otp.findMany()
    * ```
    */
  get otp(): Prisma.otpDelegate<ExtArgs>;

  /**
   * `prisma.appointment`: Exposes CRUD operations for the **appointment** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Appointments
    * const appointments = await prisma.appointment.findMany()
    * ```
    */
  get appointment(): Prisma.appointmentDelegate<ExtArgs>;

  /**
   * `prisma.equipment`: Exposes CRUD operations for the **equipment** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Equipment
    * const equipment = await prisma.equipment.findMany()
    * ```
    */
  get equipment(): Prisma.equipmentDelegate<ExtArgs>;

  /**
   * `prisma.blogs`: Exposes CRUD operations for the **blogs** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Blogs
    * const blogs = await prisma.blogs.findMany()
    * ```
    */
  get blogs(): Prisma.blogsDelegate<ExtArgs>;

  /**
   * `prisma.faqs`: Exposes CRUD operations for the **faqs** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Faqs
    * const faqs = await prisma.faqs.findMany()
    * ```
    */
  get faqs(): Prisma.faqsDelegate<ExtArgs>;

  /**
   * `prisma.avatar`: Exposes CRUD operations for the **avatar** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Avatars
    * const avatars = await prisma.avatar.findMany()
    * ```
    */
  get avatar(): Prisma.avatarDelegate<ExtArgs>;

  /**
   * `prisma.profile`: Exposes CRUD operations for the **profile** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Profiles
    * const profiles = await prisma.profile.findMany()
    * ```
    */
  get profile(): Prisma.profileDelegate<ExtArgs>;

  /**
   * `prisma.diagnosis`: Exposes CRUD operations for the **diagnosis** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Diagnoses
    * const diagnoses = await prisma.diagnosis.findMany()
    * ```
    */
  get diagnosis(): Prisma.diagnosisDelegate<ExtArgs>;

  /**
   * `prisma.presciption`: Exposes CRUD operations for the **presciption** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Presciptions
    * const presciptions = await prisma.presciption.findMany()
    * ```
    */
  get presciption(): Prisma.presciptionDelegate<ExtArgs>;

  /**
   * `prisma.feedback`: Exposes CRUD operations for the **feedback** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Feedbacks
    * const feedbacks = await prisma.feedback.findMany()
    * ```
    */
  get feedback(): Prisma.feedbackDelegate<ExtArgs>;

  /**
   * `prisma.prediag`: Exposes CRUD operations for the **prediag** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Prediags
    * const prediags = await prisma.prediag.findMany()
    * ```
    */
  get prediag(): Prisma.prediagDelegate<ExtArgs>;
}

export namespace Prisma {
  export import DMMF = runtime.DMMF

  export type PrismaPromise<T> = $Public.PrismaPromise<T>

  /**
   * Validator
   */
  export import validator = runtime.Public.validator

  /**
   * Prisma Errors
   */
  export import PrismaClientKnownRequestError = runtime.PrismaClientKnownRequestError
  export import PrismaClientUnknownRequestError = runtime.PrismaClientUnknownRequestError
  export import PrismaClientRustPanicError = runtime.PrismaClientRustPanicError
  export import PrismaClientInitializationError = runtime.PrismaClientInitializationError
  export import PrismaClientValidationError = runtime.PrismaClientValidationError
  export import NotFoundError = runtime.NotFoundError

  /**
   * Re-export of sql-template-tag
   */
  export import sql = runtime.sqltag
  export import empty = runtime.empty
  export import join = runtime.join
  export import raw = runtime.raw
  export import Sql = runtime.Sql

  /**
   * Decimal.js
   */
  export import Decimal = runtime.Decimal

  export type DecimalJsLike = runtime.DecimalJsLike

  /**
   * Metrics 
   */
  export type Metrics = runtime.Metrics
  export type Metric<T> = runtime.Metric<T>
  export type MetricHistogram = runtime.MetricHistogram
  export type MetricHistogramBucket = runtime.MetricHistogramBucket

  /**
  * Extensions
  */
  export import Extension = $Extensions.UserArgs
  export import getExtensionContext = runtime.Extensions.getExtensionContext
  export import Args = $Public.Args
  export import Payload = $Public.Payload
  export import Result = $Public.Result
  export import Exact = $Public.Exact

  /**
   * Prisma Client JS version: 5.5.2
   * Query Engine version: aebc046ce8b88ebbcb45efe31cbe7d06fd6abc0a
   */
  export type PrismaVersion = {
    client: string
  }

  export const prismaVersion: PrismaVersion 

  /**
   * Utility Types
   */

  /**
   * From https://github.com/sindresorhus/type-fest/
   * Matches a JSON object.
   * This type can be useful to enforce some input to be JSON-compatible or as a super-type to be extended from. 
   */
  export type JsonObject = {[Key in string]?: JsonValue}

  /**
   * From https://github.com/sindresorhus/type-fest/
   * Matches a JSON array.
   */
  export interface JsonArray extends Array<JsonValue> {}

  /**
   * From https://github.com/sindresorhus/type-fest/
   * Matches any valid JSON value.
   */
  export type JsonValue = string | number | boolean | JsonObject | JsonArray | null

  /**
   * Matches a JSON object.
   * Unlike `JsonObject`, this type allows undefined and read-only properties.
   */
  export type InputJsonObject = {readonly [Key in string]?: InputJsonValue | null}

  /**
   * Matches a JSON array.
   * Unlike `JsonArray`, readonly arrays are assignable to this type.
   */
  export interface InputJsonArray extends ReadonlyArray<InputJsonValue | null> {}

  /**
   * Matches any valid value that can be used as an input for operations like
   * create and update as the value of a JSON field. Unlike `JsonValue`, this
   * type allows read-only arrays and read-only object properties and disallows
   * `null` at the top level.
   *
   * `null` cannot be used as the value of a JSON field because its meaning
   * would be ambiguous. Use `Prisma.JsonNull` to store the JSON null value or
   * `Prisma.DbNull` to clear the JSON value and set the field to the database
   * NULL value instead.
   *
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-by-null-values
   */
  export type InputJsonValue = string | number | boolean | InputJsonObject | InputJsonArray | { toJSON(): unknown }

  /**
   * Types of the values used to represent different kinds of `null` values when working with JSON fields.
   * 
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  namespace NullTypes {
    /**
    * Type of `Prisma.DbNull`.
    * 
    * You cannot use other instances of this class. Please use the `Prisma.DbNull` value.
    * 
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class DbNull {
      private DbNull: never
      private constructor()
    }

    /**
    * Type of `Prisma.JsonNull`.
    * 
    * You cannot use other instances of this class. Please use the `Prisma.JsonNull` value.
    * 
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class JsonNull {
      private JsonNull: never
      private constructor()
    }

    /**
    * Type of `Prisma.AnyNull`.
    * 
    * You cannot use other instances of this class. Please use the `Prisma.AnyNull` value.
    * 
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class AnyNull {
      private AnyNull: never
      private constructor()
    }
  }

  /**
   * Helper for filtering JSON entries that have `null` on the database (empty on the db)
   * 
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const DbNull: NullTypes.DbNull

  /**
   * Helper for filtering JSON entries that have JSON `null` values (not empty on the db)
   * 
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const JsonNull: NullTypes.JsonNull

  /**
   * Helper for filtering JSON entries that are `Prisma.DbNull` or `Prisma.JsonNull`
   * 
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const AnyNull: NullTypes.AnyNull

  type SelectAndInclude = {
    select: any
    include: any
  }

  /**
   * Get the type of the value, that the Promise holds.
   */
  export type PromiseType<T extends PromiseLike<any>> = T extends PromiseLike<infer U> ? U : T;

  /**
   * Get the return type of a function which returns a Promise.
   */
  export type PromiseReturnType<T extends (...args: any) => $Utils.JsPromise<any>> = PromiseType<ReturnType<T>>

  /**
   * From T, pick a set of properties whose keys are in the union K
   */
  type Prisma__Pick<T, K extends keyof T> = {
      [P in K]: T[P];
  };


  export type Enumerable<T> = T | Array<T>;

  export type RequiredKeys<T> = {
    [K in keyof T]-?: {} extends Prisma__Pick<T, K> ? never : K
  }[keyof T]

  export type TruthyKeys<T> = keyof {
    [K in keyof T as T[K] extends false | undefined | null ? never : K]: K
  }

  export type TrueKeys<T> = TruthyKeys<Prisma__Pick<T, RequiredKeys<T>>>

  /**
   * Subset
   * @desc From `T` pick properties that exist in `U`. Simple version of Intersection
   */
  export type Subset<T, U> = {
    [key in keyof T]: key extends keyof U ? T[key] : never;
  };

  /**
   * SelectSubset
   * @desc From `T` pick properties that exist in `U`. Simple version of Intersection.
   * Additionally, it validates, if both select and include are present. If the case, it errors.
   */
  export type SelectSubset<T, U> = {
    [key in keyof T]: key extends keyof U ? T[key] : never
  } &
    (T extends SelectAndInclude
      ? 'Please either choose `select` or `include`.'
      : {})

  /**
   * Subset + Intersection
   * @desc From `T` pick properties that exist in `U` and intersect `K`
   */
  export type SubsetIntersection<T, U, K> = {
    [key in keyof T]: key extends keyof U ? T[key] : never
  } &
    K

  type Without<T, U> = { [P in Exclude<keyof T, keyof U>]?: never };

  /**
   * XOR is needed to have a real mutually exclusive union type
   * https://stackoverflow.com/questions/42123407/does-typescript-support-mutually-exclusive-types
   */
  type XOR<T, U> =
    T extends object ?
    U extends object ?
      (Without<T, U> & U) | (Without<U, T> & T)
    : U : T


  /**
   * Is T a Record?
   */
  type IsObject<T extends any> = T extends Array<any>
  ? False
  : T extends Date
  ? False
  : T extends Uint8Array
  ? False
  : T extends BigInt
  ? False
  : T extends object
  ? True
  : False


  /**
   * If it's T[], return T
   */
  export type UnEnumerate<T extends unknown> = T extends Array<infer U> ? U : T

  /**
   * From ts-toolbelt
   */

  type __Either<O extends object, K extends Key> = Omit<O, K> &
    {
      // Merge all but K
      [P in K]: Prisma__Pick<O, P & keyof O> // With K possibilities
    }[K]

  type EitherStrict<O extends object, K extends Key> = Strict<__Either<O, K>>

  type EitherLoose<O extends object, K extends Key> = ComputeRaw<__Either<O, K>>

  type _Either<
    O extends object,
    K extends Key,
    strict extends Boolean
  > = {
    1: EitherStrict<O, K>
    0: EitherLoose<O, K>
  }[strict]

  type Either<
    O extends object,
    K extends Key,
    strict extends Boolean = 1
  > = O extends unknown ? _Either<O, K, strict> : never

  export type Union = any

  type PatchUndefined<O extends object, O1 extends object> = {
    [K in keyof O]: O[K] extends undefined ? At<O1, K> : O[K]
  } & {}

  /** Helper Types for "Merge" **/
  export type IntersectOf<U extends Union> = (
    U extends unknown ? (k: U) => void : never
  ) extends (k: infer I) => void
    ? I
    : never

  export type Overwrite<O extends object, O1 extends object> = {
      [K in keyof O]: K extends keyof O1 ? O1[K] : O[K];
  } & {};

  type _Merge<U extends object> = IntersectOf<Overwrite<U, {
      [K in keyof U]-?: At<U, K>;
  }>>;

  type Key = string | number | symbol;
  type AtBasic<O extends object, K extends Key> = K extends keyof O ? O[K] : never;
  type AtStrict<O extends object, K extends Key> = O[K & keyof O];
  type AtLoose<O extends object, K extends Key> = O extends unknown ? AtStrict<O, K> : never;
  export type At<O extends object, K extends Key, strict extends Boolean = 1> = {
      1: AtStrict<O, K>;
      0: AtLoose<O, K>;
  }[strict];

  export type ComputeRaw<A extends any> = A extends Function ? A : {
    [K in keyof A]: A[K];
  } & {};

  export type OptionalFlat<O> = {
    [K in keyof O]?: O[K];
  } & {};

  type _Record<K extends keyof any, T> = {
    [P in K]: T;
  };

  // cause typescript not to expand types and preserve names
  type NoExpand<T> = T extends unknown ? T : never;

  // this type assumes the passed object is entirely optional
  type AtLeast<O extends object, K extends string> = NoExpand<
    O extends unknown
    ? | (K extends keyof O ? { [P in K]: O[P] } & O : O)
      | {[P in keyof O as P extends K ? K : never]-?: O[P]} & O
    : never>;

  type _Strict<U, _U = U> = U extends unknown ? U & OptionalFlat<_Record<Exclude<Keys<_U>, keyof U>, never>> : never;

  export type Strict<U extends object> = ComputeRaw<_Strict<U>>;
  /** End Helper Types for "Merge" **/

  export type Merge<U extends object> = ComputeRaw<_Merge<Strict<U>>>;

  /**
  A [[Boolean]]
  */
  export type Boolean = True | False

  // /**
  // 1
  // */
  export type True = 1

  /**
  0
  */
  export type False = 0

  export type Not<B extends Boolean> = {
    0: 1
    1: 0
  }[B]

  export type Extends<A1 extends any, A2 extends any> = [A1] extends [never]
    ? 0 // anything `never` is false
    : A1 extends A2
    ? 1
    : 0

  export type Has<U extends Union, U1 extends Union> = Not<
    Extends<Exclude<U1, U>, U1>
  >

  export type Or<B1 extends Boolean, B2 extends Boolean> = {
    0: {
      0: 0
      1: 1
    }
    1: {
      0: 1
      1: 1
    }
  }[B1][B2]

  export type Keys<U extends Union> = U extends unknown ? keyof U : never

  type Cast<A, B> = A extends B ? A : B;

  export const type: unique symbol;



  /**
   * Used by group by
   */

  export type GetScalarType<T, O> = O extends object ? {
    [P in keyof T]: P extends keyof O
      ? O[P]
      : never
  } : never

  type FieldPaths<
    T,
    U = Omit<T, '_avg' | '_sum' | '_count' | '_min' | '_max'>
  > = IsObject<T> extends True ? U : T

  type GetHavingFields<T> = {
    [K in keyof T]: Or<
      Or<Extends<'OR', K>, Extends<'AND', K>>,
      Extends<'NOT', K>
    > extends True
      ? // infer is only needed to not hit TS limit
        // based on the brilliant idea of Pierre-Antoine Mills
        // https://github.com/microsoft/TypeScript/issues/30188#issuecomment-478938437
        T[K] extends infer TK
        ? GetHavingFields<UnEnumerate<TK> extends object ? Merge<UnEnumerate<TK>> : never>
        : never
      : {} extends FieldPaths<T[K]>
      ? never
      : K
  }[keyof T]

  /**
   * Convert tuple to union
   */
  type _TupleToUnion<T> = T extends (infer E)[] ? E : never
  type TupleToUnion<K extends readonly any[]> = _TupleToUnion<K>
  type MaybeTupleToUnion<T> = T extends any[] ? TupleToUnion<T> : T

  /**
   * Like `Pick`, but additionally can also accept an array of keys
   */
  type PickEnumerable<T, K extends Enumerable<keyof T> | keyof T> = Prisma__Pick<T, MaybeTupleToUnion<K>>

  /**
   * Exclude all keys with underscores
   */
  type ExcludeUnderscoreKeys<T extends string> = T extends `_${string}` ? never : T


  export type FieldRef<Model, FieldType> = runtime.FieldRef<Model, FieldType>

  type FieldRefInputType<Model, FieldType> = Model extends never ? never : FieldRef<Model, FieldType>


  export const ModelName: {
    user: 'user',
    services: 'services',
    otp: 'otp',
    appointment: 'appointment',
    equipment: 'equipment',
    blogs: 'blogs',
    faqs: 'faqs',
    avatar: 'avatar',
    profile: 'profile',
    diagnosis: 'diagnosis',
    presciption: 'presciption',
    feedback: 'feedback',
    prediag: 'prediag'
  };

  export type ModelName = (typeof ModelName)[keyof typeof ModelName]


  export type Datasources = {
    db?: Datasource
  }


  interface TypeMapCb extends $Utils.Fn<{extArgs: $Extensions.InternalArgs}, $Utils.Record<string, any>> {
    returns: Prisma.TypeMap<this['params']['extArgs']>
  }

  export type TypeMap<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    meta: {
      modelProps: 'user' | 'services' | 'otp' | 'appointment' | 'equipment' | 'blogs' | 'faqs' | 'avatar' | 'profile' | 'diagnosis' | 'presciption' | 'feedback' | 'prediag'
      txIsolationLevel: Prisma.TransactionIsolationLevel
    },
    model: {
      user: {
        payload: Prisma.$userPayload<ExtArgs>
        fields: Prisma.userFieldRefs
        operations: {
          findUnique: {
            args: Prisma.userFindUniqueArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$userPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.userFindUniqueOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$userPayload>
          }
          findFirst: {
            args: Prisma.userFindFirstArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$userPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.userFindFirstOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$userPayload>
          }
          findMany: {
            args: Prisma.userFindManyArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$userPayload>[]
          }
          create: {
            args: Prisma.userCreateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$userPayload>
          }
          createMany: {
            args: Prisma.userCreateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          delete: {
            args: Prisma.userDeleteArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$userPayload>
          }
          update: {
            args: Prisma.userUpdateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$userPayload>
          }
          deleteMany: {
            args: Prisma.userDeleteManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          updateMany: {
            args: Prisma.userUpdateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          upsert: {
            args: Prisma.userUpsertArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$userPayload>
          }
          aggregate: {
            args: Prisma.UserAggregateArgs<ExtArgs>,
            result: $Utils.Optional<AggregateUser>
          }
          groupBy: {
            args: Prisma.userGroupByArgs<ExtArgs>,
            result: $Utils.Optional<UserGroupByOutputType>[]
          }
          count: {
            args: Prisma.userCountArgs<ExtArgs>,
            result: $Utils.Optional<UserCountAggregateOutputType> | number
          }
        }
      }
      services: {
        payload: Prisma.$servicesPayload<ExtArgs>
        fields: Prisma.servicesFieldRefs
        operations: {
          findUnique: {
            args: Prisma.servicesFindUniqueArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$servicesPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.servicesFindUniqueOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$servicesPayload>
          }
          findFirst: {
            args: Prisma.servicesFindFirstArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$servicesPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.servicesFindFirstOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$servicesPayload>
          }
          findMany: {
            args: Prisma.servicesFindManyArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$servicesPayload>[]
          }
          create: {
            args: Prisma.servicesCreateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$servicesPayload>
          }
          createMany: {
            args: Prisma.servicesCreateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          delete: {
            args: Prisma.servicesDeleteArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$servicesPayload>
          }
          update: {
            args: Prisma.servicesUpdateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$servicesPayload>
          }
          deleteMany: {
            args: Prisma.servicesDeleteManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          updateMany: {
            args: Prisma.servicesUpdateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          upsert: {
            args: Prisma.servicesUpsertArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$servicesPayload>
          }
          aggregate: {
            args: Prisma.ServicesAggregateArgs<ExtArgs>,
            result: $Utils.Optional<AggregateServices>
          }
          groupBy: {
            args: Prisma.servicesGroupByArgs<ExtArgs>,
            result: $Utils.Optional<ServicesGroupByOutputType>[]
          }
          count: {
            args: Prisma.servicesCountArgs<ExtArgs>,
            result: $Utils.Optional<ServicesCountAggregateOutputType> | number
          }
        }
      }
      otp: {
        payload: Prisma.$otpPayload<ExtArgs>
        fields: Prisma.otpFieldRefs
        operations: {
          findUnique: {
            args: Prisma.otpFindUniqueArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$otpPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.otpFindUniqueOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$otpPayload>
          }
          findFirst: {
            args: Prisma.otpFindFirstArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$otpPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.otpFindFirstOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$otpPayload>
          }
          findMany: {
            args: Prisma.otpFindManyArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$otpPayload>[]
          }
          create: {
            args: Prisma.otpCreateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$otpPayload>
          }
          createMany: {
            args: Prisma.otpCreateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          delete: {
            args: Prisma.otpDeleteArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$otpPayload>
          }
          update: {
            args: Prisma.otpUpdateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$otpPayload>
          }
          deleteMany: {
            args: Prisma.otpDeleteManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          updateMany: {
            args: Prisma.otpUpdateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          upsert: {
            args: Prisma.otpUpsertArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$otpPayload>
          }
          aggregate: {
            args: Prisma.OtpAggregateArgs<ExtArgs>,
            result: $Utils.Optional<AggregateOtp>
          }
          groupBy: {
            args: Prisma.otpGroupByArgs<ExtArgs>,
            result: $Utils.Optional<OtpGroupByOutputType>[]
          }
          count: {
            args: Prisma.otpCountArgs<ExtArgs>,
            result: $Utils.Optional<OtpCountAggregateOutputType> | number
          }
        }
      }
      appointment: {
        payload: Prisma.$appointmentPayload<ExtArgs>
        fields: Prisma.appointmentFieldRefs
        operations: {
          findUnique: {
            args: Prisma.appointmentFindUniqueArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$appointmentPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.appointmentFindUniqueOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$appointmentPayload>
          }
          findFirst: {
            args: Prisma.appointmentFindFirstArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$appointmentPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.appointmentFindFirstOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$appointmentPayload>
          }
          findMany: {
            args: Prisma.appointmentFindManyArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$appointmentPayload>[]
          }
          create: {
            args: Prisma.appointmentCreateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$appointmentPayload>
          }
          createMany: {
            args: Prisma.appointmentCreateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          delete: {
            args: Prisma.appointmentDeleteArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$appointmentPayload>
          }
          update: {
            args: Prisma.appointmentUpdateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$appointmentPayload>
          }
          deleteMany: {
            args: Prisma.appointmentDeleteManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          updateMany: {
            args: Prisma.appointmentUpdateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          upsert: {
            args: Prisma.appointmentUpsertArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$appointmentPayload>
          }
          aggregate: {
            args: Prisma.AppointmentAggregateArgs<ExtArgs>,
            result: $Utils.Optional<AggregateAppointment>
          }
          groupBy: {
            args: Prisma.appointmentGroupByArgs<ExtArgs>,
            result: $Utils.Optional<AppointmentGroupByOutputType>[]
          }
          count: {
            args: Prisma.appointmentCountArgs<ExtArgs>,
            result: $Utils.Optional<AppointmentCountAggregateOutputType> | number
          }
        }
      }
      equipment: {
        payload: Prisma.$equipmentPayload<ExtArgs>
        fields: Prisma.equipmentFieldRefs
        operations: {
          findUnique: {
            args: Prisma.equipmentFindUniqueArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$equipmentPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.equipmentFindUniqueOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$equipmentPayload>
          }
          findFirst: {
            args: Prisma.equipmentFindFirstArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$equipmentPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.equipmentFindFirstOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$equipmentPayload>
          }
          findMany: {
            args: Prisma.equipmentFindManyArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$equipmentPayload>[]
          }
          create: {
            args: Prisma.equipmentCreateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$equipmentPayload>
          }
          createMany: {
            args: Prisma.equipmentCreateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          delete: {
            args: Prisma.equipmentDeleteArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$equipmentPayload>
          }
          update: {
            args: Prisma.equipmentUpdateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$equipmentPayload>
          }
          deleteMany: {
            args: Prisma.equipmentDeleteManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          updateMany: {
            args: Prisma.equipmentUpdateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          upsert: {
            args: Prisma.equipmentUpsertArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$equipmentPayload>
          }
          aggregate: {
            args: Prisma.EquipmentAggregateArgs<ExtArgs>,
            result: $Utils.Optional<AggregateEquipment>
          }
          groupBy: {
            args: Prisma.equipmentGroupByArgs<ExtArgs>,
            result: $Utils.Optional<EquipmentGroupByOutputType>[]
          }
          count: {
            args: Prisma.equipmentCountArgs<ExtArgs>,
            result: $Utils.Optional<EquipmentCountAggregateOutputType> | number
          }
        }
      }
      blogs: {
        payload: Prisma.$blogsPayload<ExtArgs>
        fields: Prisma.blogsFieldRefs
        operations: {
          findUnique: {
            args: Prisma.blogsFindUniqueArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$blogsPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.blogsFindUniqueOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$blogsPayload>
          }
          findFirst: {
            args: Prisma.blogsFindFirstArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$blogsPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.blogsFindFirstOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$blogsPayload>
          }
          findMany: {
            args: Prisma.blogsFindManyArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$blogsPayload>[]
          }
          create: {
            args: Prisma.blogsCreateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$blogsPayload>
          }
          createMany: {
            args: Prisma.blogsCreateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          delete: {
            args: Prisma.blogsDeleteArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$blogsPayload>
          }
          update: {
            args: Prisma.blogsUpdateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$blogsPayload>
          }
          deleteMany: {
            args: Prisma.blogsDeleteManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          updateMany: {
            args: Prisma.blogsUpdateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          upsert: {
            args: Prisma.blogsUpsertArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$blogsPayload>
          }
          aggregate: {
            args: Prisma.BlogsAggregateArgs<ExtArgs>,
            result: $Utils.Optional<AggregateBlogs>
          }
          groupBy: {
            args: Prisma.blogsGroupByArgs<ExtArgs>,
            result: $Utils.Optional<BlogsGroupByOutputType>[]
          }
          count: {
            args: Prisma.blogsCountArgs<ExtArgs>,
            result: $Utils.Optional<BlogsCountAggregateOutputType> | number
          }
        }
      }
      faqs: {
        payload: Prisma.$faqsPayload<ExtArgs>
        fields: Prisma.faqsFieldRefs
        operations: {
          findUnique: {
            args: Prisma.faqsFindUniqueArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$faqsPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.faqsFindUniqueOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$faqsPayload>
          }
          findFirst: {
            args: Prisma.faqsFindFirstArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$faqsPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.faqsFindFirstOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$faqsPayload>
          }
          findMany: {
            args: Prisma.faqsFindManyArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$faqsPayload>[]
          }
          create: {
            args: Prisma.faqsCreateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$faqsPayload>
          }
          createMany: {
            args: Prisma.faqsCreateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          delete: {
            args: Prisma.faqsDeleteArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$faqsPayload>
          }
          update: {
            args: Prisma.faqsUpdateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$faqsPayload>
          }
          deleteMany: {
            args: Prisma.faqsDeleteManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          updateMany: {
            args: Prisma.faqsUpdateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          upsert: {
            args: Prisma.faqsUpsertArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$faqsPayload>
          }
          aggregate: {
            args: Prisma.FaqsAggregateArgs<ExtArgs>,
            result: $Utils.Optional<AggregateFaqs>
          }
          groupBy: {
            args: Prisma.faqsGroupByArgs<ExtArgs>,
            result: $Utils.Optional<FaqsGroupByOutputType>[]
          }
          count: {
            args: Prisma.faqsCountArgs<ExtArgs>,
            result: $Utils.Optional<FaqsCountAggregateOutputType> | number
          }
        }
      }
      avatar: {
        payload: Prisma.$avatarPayload<ExtArgs>
        fields: Prisma.avatarFieldRefs
        operations: {
          findUnique: {
            args: Prisma.avatarFindUniqueArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$avatarPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.avatarFindUniqueOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$avatarPayload>
          }
          findFirst: {
            args: Prisma.avatarFindFirstArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$avatarPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.avatarFindFirstOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$avatarPayload>
          }
          findMany: {
            args: Prisma.avatarFindManyArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$avatarPayload>[]
          }
          create: {
            args: Prisma.avatarCreateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$avatarPayload>
          }
          createMany: {
            args: Prisma.avatarCreateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          delete: {
            args: Prisma.avatarDeleteArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$avatarPayload>
          }
          update: {
            args: Prisma.avatarUpdateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$avatarPayload>
          }
          deleteMany: {
            args: Prisma.avatarDeleteManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          updateMany: {
            args: Prisma.avatarUpdateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          upsert: {
            args: Prisma.avatarUpsertArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$avatarPayload>
          }
          aggregate: {
            args: Prisma.AvatarAggregateArgs<ExtArgs>,
            result: $Utils.Optional<AggregateAvatar>
          }
          groupBy: {
            args: Prisma.avatarGroupByArgs<ExtArgs>,
            result: $Utils.Optional<AvatarGroupByOutputType>[]
          }
          count: {
            args: Prisma.avatarCountArgs<ExtArgs>,
            result: $Utils.Optional<AvatarCountAggregateOutputType> | number
          }
        }
      }
      profile: {
        payload: Prisma.$profilePayload<ExtArgs>
        fields: Prisma.profileFieldRefs
        operations: {
          findUnique: {
            args: Prisma.profileFindUniqueArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$profilePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.profileFindUniqueOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$profilePayload>
          }
          findFirst: {
            args: Prisma.profileFindFirstArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$profilePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.profileFindFirstOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$profilePayload>
          }
          findMany: {
            args: Prisma.profileFindManyArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$profilePayload>[]
          }
          create: {
            args: Prisma.profileCreateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$profilePayload>
          }
          createMany: {
            args: Prisma.profileCreateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          delete: {
            args: Prisma.profileDeleteArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$profilePayload>
          }
          update: {
            args: Prisma.profileUpdateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$profilePayload>
          }
          deleteMany: {
            args: Prisma.profileDeleteManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          updateMany: {
            args: Prisma.profileUpdateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          upsert: {
            args: Prisma.profileUpsertArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$profilePayload>
          }
          aggregate: {
            args: Prisma.ProfileAggregateArgs<ExtArgs>,
            result: $Utils.Optional<AggregateProfile>
          }
          groupBy: {
            args: Prisma.profileGroupByArgs<ExtArgs>,
            result: $Utils.Optional<ProfileGroupByOutputType>[]
          }
          count: {
            args: Prisma.profileCountArgs<ExtArgs>,
            result: $Utils.Optional<ProfileCountAggregateOutputType> | number
          }
        }
      }
      diagnosis: {
        payload: Prisma.$diagnosisPayload<ExtArgs>
        fields: Prisma.diagnosisFieldRefs
        operations: {
          findUnique: {
            args: Prisma.diagnosisFindUniqueArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$diagnosisPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.diagnosisFindUniqueOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$diagnosisPayload>
          }
          findFirst: {
            args: Prisma.diagnosisFindFirstArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$diagnosisPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.diagnosisFindFirstOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$diagnosisPayload>
          }
          findMany: {
            args: Prisma.diagnosisFindManyArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$diagnosisPayload>[]
          }
          create: {
            args: Prisma.diagnosisCreateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$diagnosisPayload>
          }
          createMany: {
            args: Prisma.diagnosisCreateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          delete: {
            args: Prisma.diagnosisDeleteArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$diagnosisPayload>
          }
          update: {
            args: Prisma.diagnosisUpdateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$diagnosisPayload>
          }
          deleteMany: {
            args: Prisma.diagnosisDeleteManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          updateMany: {
            args: Prisma.diagnosisUpdateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          upsert: {
            args: Prisma.diagnosisUpsertArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$diagnosisPayload>
          }
          aggregate: {
            args: Prisma.DiagnosisAggregateArgs<ExtArgs>,
            result: $Utils.Optional<AggregateDiagnosis>
          }
          groupBy: {
            args: Prisma.diagnosisGroupByArgs<ExtArgs>,
            result: $Utils.Optional<DiagnosisGroupByOutputType>[]
          }
          count: {
            args: Prisma.diagnosisCountArgs<ExtArgs>,
            result: $Utils.Optional<DiagnosisCountAggregateOutputType> | number
          }
        }
      }
      presciption: {
        payload: Prisma.$presciptionPayload<ExtArgs>
        fields: Prisma.presciptionFieldRefs
        operations: {
          findUnique: {
            args: Prisma.presciptionFindUniqueArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$presciptionPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.presciptionFindUniqueOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$presciptionPayload>
          }
          findFirst: {
            args: Prisma.presciptionFindFirstArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$presciptionPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.presciptionFindFirstOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$presciptionPayload>
          }
          findMany: {
            args: Prisma.presciptionFindManyArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$presciptionPayload>[]
          }
          create: {
            args: Prisma.presciptionCreateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$presciptionPayload>
          }
          createMany: {
            args: Prisma.presciptionCreateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          delete: {
            args: Prisma.presciptionDeleteArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$presciptionPayload>
          }
          update: {
            args: Prisma.presciptionUpdateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$presciptionPayload>
          }
          deleteMany: {
            args: Prisma.presciptionDeleteManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          updateMany: {
            args: Prisma.presciptionUpdateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          upsert: {
            args: Prisma.presciptionUpsertArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$presciptionPayload>
          }
          aggregate: {
            args: Prisma.PresciptionAggregateArgs<ExtArgs>,
            result: $Utils.Optional<AggregatePresciption>
          }
          groupBy: {
            args: Prisma.presciptionGroupByArgs<ExtArgs>,
            result: $Utils.Optional<PresciptionGroupByOutputType>[]
          }
          count: {
            args: Prisma.presciptionCountArgs<ExtArgs>,
            result: $Utils.Optional<PresciptionCountAggregateOutputType> | number
          }
        }
      }
      feedback: {
        payload: Prisma.$feedbackPayload<ExtArgs>
        fields: Prisma.feedbackFieldRefs
        operations: {
          findUnique: {
            args: Prisma.feedbackFindUniqueArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$feedbackPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.feedbackFindUniqueOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$feedbackPayload>
          }
          findFirst: {
            args: Prisma.feedbackFindFirstArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$feedbackPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.feedbackFindFirstOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$feedbackPayload>
          }
          findMany: {
            args: Prisma.feedbackFindManyArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$feedbackPayload>[]
          }
          create: {
            args: Prisma.feedbackCreateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$feedbackPayload>
          }
          createMany: {
            args: Prisma.feedbackCreateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          delete: {
            args: Prisma.feedbackDeleteArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$feedbackPayload>
          }
          update: {
            args: Prisma.feedbackUpdateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$feedbackPayload>
          }
          deleteMany: {
            args: Prisma.feedbackDeleteManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          updateMany: {
            args: Prisma.feedbackUpdateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          upsert: {
            args: Prisma.feedbackUpsertArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$feedbackPayload>
          }
          aggregate: {
            args: Prisma.FeedbackAggregateArgs<ExtArgs>,
            result: $Utils.Optional<AggregateFeedback>
          }
          groupBy: {
            args: Prisma.feedbackGroupByArgs<ExtArgs>,
            result: $Utils.Optional<FeedbackGroupByOutputType>[]
          }
          count: {
            args: Prisma.feedbackCountArgs<ExtArgs>,
            result: $Utils.Optional<FeedbackCountAggregateOutputType> | number
          }
        }
      }
      prediag: {
        payload: Prisma.$prediagPayload<ExtArgs>
        fields: Prisma.prediagFieldRefs
        operations: {
          findUnique: {
            args: Prisma.prediagFindUniqueArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$prediagPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.prediagFindUniqueOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$prediagPayload>
          }
          findFirst: {
            args: Prisma.prediagFindFirstArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$prediagPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.prediagFindFirstOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$prediagPayload>
          }
          findMany: {
            args: Prisma.prediagFindManyArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$prediagPayload>[]
          }
          create: {
            args: Prisma.prediagCreateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$prediagPayload>
          }
          createMany: {
            args: Prisma.prediagCreateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          delete: {
            args: Prisma.prediagDeleteArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$prediagPayload>
          }
          update: {
            args: Prisma.prediagUpdateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$prediagPayload>
          }
          deleteMany: {
            args: Prisma.prediagDeleteManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          updateMany: {
            args: Prisma.prediagUpdateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          upsert: {
            args: Prisma.prediagUpsertArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$prediagPayload>
          }
          aggregate: {
            args: Prisma.PrediagAggregateArgs<ExtArgs>,
            result: $Utils.Optional<AggregatePrediag>
          }
          groupBy: {
            args: Prisma.prediagGroupByArgs<ExtArgs>,
            result: $Utils.Optional<PrediagGroupByOutputType>[]
          }
          count: {
            args: Prisma.prediagCountArgs<ExtArgs>,
            result: $Utils.Optional<PrediagCountAggregateOutputType> | number
          }
        }
      }
    }
  } & {
    other: {
      payload: any
      operations: {
        $executeRawUnsafe: {
          args: [query: string, ...values: any[]],
          result: any
        }
        $executeRaw: {
          args: [query: TemplateStringsArray | Prisma.Sql, ...values: any[]],
          result: any
        }
        $queryRawUnsafe: {
          args: [query: string, ...values: any[]],
          result: any
        }
        $queryRaw: {
          args: [query: TemplateStringsArray | Prisma.Sql, ...values: any[]],
          result: any
        }
      }
    }
  }
  export const defineExtension: $Extensions.ExtendsHook<'define', Prisma.TypeMapCb, $Extensions.DefaultArgs>
  export type DefaultPrismaClient = PrismaClient
  export type ErrorFormat = 'pretty' | 'colorless' | 'minimal'
  export interface PrismaClientOptions {
    /**
     * Overwrites the datasource url from your schema.prisma file
     */
    datasources?: Datasources
    /**
     * Overwrites the datasource url from your schema.prisma file
     */
    datasourceUrl?: string
    /**
     * @default "colorless"
     */
    errorFormat?: ErrorFormat
    /**
     * @example
     * ```
     * // Defaults to stdout
     * log: ['query', 'info', 'warn', 'error']
     * 
     * // Emit as events
     * log: [
     *   { emit: 'stdout', level: 'query' },
     *   { emit: 'stdout', level: 'info' },
     *   { emit: 'stdout', level: 'warn' }
     *   { emit: 'stdout', level: 'error' }
     * ]
     * ```
     * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/logging#the-log-option).
     */
    log?: (LogLevel | LogDefinition)[]
  }

  /* Types for Logging */
  export type LogLevel = 'info' | 'query' | 'warn' | 'error'
  export type LogDefinition = {
    level: LogLevel
    emit: 'stdout' | 'event'
  }

  export type GetLogType<T extends LogLevel | LogDefinition> = T extends LogDefinition ? T['emit'] extends 'event' ? T['level'] : never : never
  export type GetEvents<T extends any> = T extends Array<LogLevel | LogDefinition> ?
    GetLogType<T[0]> | GetLogType<T[1]> | GetLogType<T[2]> | GetLogType<T[3]>
    : never

  export type QueryEvent = {
    timestamp: Date
    query: string
    params: string
    duration: number
    target: string
  }

  export type LogEvent = {
    timestamp: Date
    message: string
    target: string
  }
  /* End Types for Logging */


  export type PrismaAction =
    | 'findUnique'
    | 'findUniqueOrThrow'
    | 'findMany'
    | 'findFirst'
    | 'findFirstOrThrow'
    | 'create'
    | 'createMany'
    | 'update'
    | 'updateMany'
    | 'upsert'
    | 'delete'
    | 'deleteMany'
    | 'executeRaw'
    | 'queryRaw'
    | 'aggregate'
    | 'count'
    | 'runCommandRaw'
    | 'findRaw'
    | 'groupBy'

  /**
   * These options are being passed into the middleware as "params"
   */
  export type MiddlewareParams = {
    model?: ModelName
    action: PrismaAction
    args: any
    dataPath: string[]
    runInTransaction: boolean
  }

  /**
   * The `T` type makes sure, that the `return proceed` is not forgotten in the middleware implementation
   */
  export type Middleware<T = any> = (
    params: MiddlewareParams,
    next: (params: MiddlewareParams) => $Utils.JsPromise<T>,
  ) => $Utils.JsPromise<T>

  // tested in getLogLevel.test.ts
  export function getLogLevel(log: Array<LogLevel | LogDefinition>): LogLevel | undefined;

  /**
   * `PrismaClient` proxy available in interactive transactions.
   */
  export type TransactionClient = Omit<Prisma.DefaultPrismaClient, runtime.ITXClientDenyList>

  export type Datasource = {
    url?: string
  }

  /**
   * Count Types
   */


  /**
   * Count Type UserCountOutputType
   */

  export type UserCountOutputType = {
    blog: number
    faqs: number
    equipment: number
    prescription: number
    feedback: number
    appointment: number
    diagnosis: number
    otp: number
    services: number
    preDiagnostic: number
  }

  export type UserCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    blog?: boolean | UserCountOutputTypeCountBlogArgs
    faqs?: boolean | UserCountOutputTypeCountFaqsArgs
    equipment?: boolean | UserCountOutputTypeCountEquipmentArgs
    prescription?: boolean | UserCountOutputTypeCountPrescriptionArgs
    feedback?: boolean | UserCountOutputTypeCountFeedbackArgs
    appointment?: boolean | UserCountOutputTypeCountAppointmentArgs
    diagnosis?: boolean | UserCountOutputTypeCountDiagnosisArgs
    otp?: boolean | UserCountOutputTypeCountOtpArgs
    services?: boolean | UserCountOutputTypeCountServicesArgs
    preDiagnostic?: boolean | UserCountOutputTypeCountPreDiagnosticArgs
  }

  // Custom InputTypes

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserCountOutputType
     */
    select?: UserCountOutputTypeSelect<ExtArgs> | null
  }


  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountBlogArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: blogsWhereInput
  }


  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountFaqsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: faqsWhereInput
  }


  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountEquipmentArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: equipmentWhereInput
  }


  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountPrescriptionArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: presciptionWhereInput
  }


  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountFeedbackArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: feedbackWhereInput
  }


  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountAppointmentArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: appointmentWhereInput
  }


  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountDiagnosisArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: diagnosisWhereInput
  }


  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountOtpArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: otpWhereInput
  }


  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountServicesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: servicesWhereInput
  }


  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountPreDiagnosticArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: prediagWhereInput
  }



  /**
   * Count Type ServicesCountOutputType
   */

  export type ServicesCountOutputType = {
    appointment: number
  }

  export type ServicesCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    appointment?: boolean | ServicesCountOutputTypeCountAppointmentArgs
  }

  // Custom InputTypes

  /**
   * ServicesCountOutputType without action
   */
  export type ServicesCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ServicesCountOutputType
     */
    select?: ServicesCountOutputTypeSelect<ExtArgs> | null
  }


  /**
   * ServicesCountOutputType without action
   */
  export type ServicesCountOutputTypeCountAppointmentArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: appointmentWhereInput
  }



  /**
   * Count Type OtpCountOutputType
   */

  export type OtpCountOutputType = {
    user: number
  }

  export type OtpCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | OtpCountOutputTypeCountUserArgs
  }

  // Custom InputTypes

  /**
   * OtpCountOutputType without action
   */
  export type OtpCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OtpCountOutputType
     */
    select?: OtpCountOutputTypeSelect<ExtArgs> | null
  }


  /**
   * OtpCountOutputType without action
   */
  export type OtpCountOutputTypeCountUserArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: userWhereInput
  }



  /**
   * Count Type AppointmentCountOutputType
   */

  export type AppointmentCountOutputType = {
    user: number
    service: number
  }

  export type AppointmentCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | AppointmentCountOutputTypeCountUserArgs
    service?: boolean | AppointmentCountOutputTypeCountServiceArgs
  }

  // Custom InputTypes

  /**
   * AppointmentCountOutputType without action
   */
  export type AppointmentCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AppointmentCountOutputType
     */
    select?: AppointmentCountOutputTypeSelect<ExtArgs> | null
  }


  /**
   * AppointmentCountOutputType without action
   */
  export type AppointmentCountOutputTypeCountUserArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: userWhereInput
  }


  /**
   * AppointmentCountOutputType without action
   */
  export type AppointmentCountOutputTypeCountServiceArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: servicesWhereInput
  }



  /**
   * Count Type EquipmentCountOutputType
   */

  export type EquipmentCountOutputType = {
    user: number
  }

  export type EquipmentCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | EquipmentCountOutputTypeCountUserArgs
  }

  // Custom InputTypes

  /**
   * EquipmentCountOutputType without action
   */
  export type EquipmentCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EquipmentCountOutputType
     */
    select?: EquipmentCountOutputTypeSelect<ExtArgs> | null
  }


  /**
   * EquipmentCountOutputType without action
   */
  export type EquipmentCountOutputTypeCountUserArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: userWhereInput
  }



  /**
   * Count Type BlogsCountOutputType
   */

  export type BlogsCountOutputType = {
    user: number
  }

  export type BlogsCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | BlogsCountOutputTypeCountUserArgs
  }

  // Custom InputTypes

  /**
   * BlogsCountOutputType without action
   */
  export type BlogsCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BlogsCountOutputType
     */
    select?: BlogsCountOutputTypeSelect<ExtArgs> | null
  }


  /**
   * BlogsCountOutputType without action
   */
  export type BlogsCountOutputTypeCountUserArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: userWhereInput
  }



  /**
   * Count Type FaqsCountOutputType
   */

  export type FaqsCountOutputType = {
    user: number
  }

  export type FaqsCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | FaqsCountOutputTypeCountUserArgs
  }

  // Custom InputTypes

  /**
   * FaqsCountOutputType without action
   */
  export type FaqsCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FaqsCountOutputType
     */
    select?: FaqsCountOutputTypeSelect<ExtArgs> | null
  }


  /**
   * FaqsCountOutputType without action
   */
  export type FaqsCountOutputTypeCountUserArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: userWhereInput
  }



  /**
   * Count Type FeedbackCountOutputType
   */

  export type FeedbackCountOutputType = {
    appointment: number
    user: number
  }

  export type FeedbackCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    appointment?: boolean | FeedbackCountOutputTypeCountAppointmentArgs
    user?: boolean | FeedbackCountOutputTypeCountUserArgs
  }

  // Custom InputTypes

  /**
   * FeedbackCountOutputType without action
   */
  export type FeedbackCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FeedbackCountOutputType
     */
    select?: FeedbackCountOutputTypeSelect<ExtArgs> | null
  }


  /**
   * FeedbackCountOutputType without action
   */
  export type FeedbackCountOutputTypeCountAppointmentArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: appointmentWhereInput
  }


  /**
   * FeedbackCountOutputType without action
   */
  export type FeedbackCountOutputTypeCountUserArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: userWhereInput
  }



  /**
   * Models
   */

  /**
   * Model user
   */

  export type AggregateUser = {
    _count: UserCountAggregateOutputType | null
    _min: UserMinAggregateOutputType | null
    _max: UserMaxAggregateOutputType | null
  }

  export type UserMinAggregateOutputType = {
    userID: string | null
    email: string | null
    password: string | null
    role: $Enums.roles | null
    verified: boolean | null
    creatdAt: Date | null
    updateAt: Date | null
  }

  export type UserMaxAggregateOutputType = {
    userID: string | null
    email: string | null
    password: string | null
    role: $Enums.roles | null
    verified: boolean | null
    creatdAt: Date | null
    updateAt: Date | null
  }

  export type UserCountAggregateOutputType = {
    userID: number
    email: number
    password: number
    role: number
    verified: number
    creatdAt: number
    updateAt: number
    _all: number
  }


  export type UserMinAggregateInputType = {
    userID?: true
    email?: true
    password?: true
    role?: true
    verified?: true
    creatdAt?: true
    updateAt?: true
  }

  export type UserMaxAggregateInputType = {
    userID?: true
    email?: true
    password?: true
    role?: true
    verified?: true
    creatdAt?: true
    updateAt?: true
  }

  export type UserCountAggregateInputType = {
    userID?: true
    email?: true
    password?: true
    role?: true
    verified?: true
    creatdAt?: true
    updateAt?: true
    _all?: true
  }

  export type UserAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which user to aggregate.
     */
    where?: userWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of users to fetch.
     */
    orderBy?: userOrderByWithRelationInput | userOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: userWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` users.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned users
    **/
    _count?: true | UserCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: UserMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: UserMaxAggregateInputType
  }

  export type GetUserAggregateType<T extends UserAggregateArgs> = {
        [P in keyof T & keyof AggregateUser]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateUser[P]>
      : GetScalarType<T[P], AggregateUser[P]>
  }




  export type userGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: userWhereInput
    orderBy?: userOrderByWithAggregationInput | userOrderByWithAggregationInput[]
    by: UserScalarFieldEnum[] | UserScalarFieldEnum
    having?: userScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: UserCountAggregateInputType | true
    _min?: UserMinAggregateInputType
    _max?: UserMaxAggregateInputType
  }

  export type UserGroupByOutputType = {
    userID: string
    email: string
    password: string
    role: $Enums.roles
    verified: boolean
    creatdAt: Date
    updateAt: Date
    _count: UserCountAggregateOutputType | null
    _min: UserMinAggregateOutputType | null
    _max: UserMaxAggregateOutputType | null
  }

  type GetUserGroupByPayload<T extends userGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<UserGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof UserGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], UserGroupByOutputType[P]>
            : GetScalarType<T[P], UserGroupByOutputType[P]>
        }
      >
    >


  export type userSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    userID?: boolean
    email?: boolean
    password?: boolean
    role?: boolean
    verified?: boolean
    creatdAt?: boolean
    updateAt?: boolean
    profile?: boolean | user$profileArgs<ExtArgs>
    blog?: boolean | user$blogArgs<ExtArgs>
    faqs?: boolean | user$faqsArgs<ExtArgs>
    equipment?: boolean | user$equipmentArgs<ExtArgs>
    prescription?: boolean | user$prescriptionArgs<ExtArgs>
    feedback?: boolean | user$feedbackArgs<ExtArgs>
    appointment?: boolean | user$appointmentArgs<ExtArgs>
    diagnosis?: boolean | user$diagnosisArgs<ExtArgs>
    otp?: boolean | user$otpArgs<ExtArgs>
    services?: boolean | user$servicesArgs<ExtArgs>
    preDiagnostic?: boolean | user$preDiagnosticArgs<ExtArgs>
    _count?: boolean | UserCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["user"]>

  export type userSelectScalar = {
    userID?: boolean
    email?: boolean
    password?: boolean
    role?: boolean
    verified?: boolean
    creatdAt?: boolean
    updateAt?: boolean
  }

  export type userInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    profile?: boolean | user$profileArgs<ExtArgs>
    blog?: boolean | user$blogArgs<ExtArgs>
    faqs?: boolean | user$faqsArgs<ExtArgs>
    equipment?: boolean | user$equipmentArgs<ExtArgs>
    prescription?: boolean | user$prescriptionArgs<ExtArgs>
    feedback?: boolean | user$feedbackArgs<ExtArgs>
    appointment?: boolean | user$appointmentArgs<ExtArgs>
    diagnosis?: boolean | user$diagnosisArgs<ExtArgs>
    otp?: boolean | user$otpArgs<ExtArgs>
    services?: boolean | user$servicesArgs<ExtArgs>
    preDiagnostic?: boolean | user$preDiagnosticArgs<ExtArgs>
    _count?: boolean | UserCountOutputTypeDefaultArgs<ExtArgs>
  }


  export type $userPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "user"
    objects: {
      profile: Prisma.$profilePayload<ExtArgs> | null
      blog: Prisma.$blogsPayload<ExtArgs>[]
      faqs: Prisma.$faqsPayload<ExtArgs>[]
      equipment: Prisma.$equipmentPayload<ExtArgs>[]
      prescription: Prisma.$presciptionPayload<ExtArgs>[]
      feedback: Prisma.$feedbackPayload<ExtArgs>[]
      appointment: Prisma.$appointmentPayload<ExtArgs>[]
      diagnosis: Prisma.$diagnosisPayload<ExtArgs>[]
      otp: Prisma.$otpPayload<ExtArgs>[]
      services: Prisma.$servicesPayload<ExtArgs>[]
      preDiagnostic: Prisma.$prediagPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      userID: string
      email: string
      password: string
      role: $Enums.roles
      verified: boolean
      creatdAt: Date
      updateAt: Date
    }, ExtArgs["result"]["user"]>
    composites: {}
  }


  type userGetPayload<S extends boolean | null | undefined | userDefaultArgs> = $Result.GetResult<Prisma.$userPayload, S>

  type userCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<userFindManyArgs, 'select' | 'include' | 'distinct' > & {
      select?: UserCountAggregateInputType | true
    }

  export interface userDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['user'], meta: { name: 'user' } }
    /**
     * Find zero or one User that matches the filter.
     * @param {userFindUniqueArgs} args - Arguments to find a User
     * @example
     * // Get one User
     * const user = await prisma.user.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends userFindUniqueArgs<ExtArgs>>(
      args: SelectSubset<T, userFindUniqueArgs<ExtArgs>>
    ): Prisma__userClient<$Result.GetResult<Prisma.$userPayload<ExtArgs>, T, 'findUnique'> | null, null, ExtArgs>

    /**
     * Find one User that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {userFindUniqueOrThrowArgs} args - Arguments to find a User
     * @example
     * // Get one User
     * const user = await prisma.user.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends userFindUniqueOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, userFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__userClient<$Result.GetResult<Prisma.$userPayload<ExtArgs>, T, 'findUniqueOrThrow'>, never, ExtArgs>

    /**
     * Find the first User that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {userFindFirstArgs} args - Arguments to find a User
     * @example
     * // Get one User
     * const user = await prisma.user.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends userFindFirstArgs<ExtArgs>>(
      args?: SelectSubset<T, userFindFirstArgs<ExtArgs>>
    ): Prisma__userClient<$Result.GetResult<Prisma.$userPayload<ExtArgs>, T, 'findFirst'> | null, null, ExtArgs>

    /**
     * Find the first User that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {userFindFirstOrThrowArgs} args - Arguments to find a User
     * @example
     * // Get one User
     * const user = await prisma.user.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends userFindFirstOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, userFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__userClient<$Result.GetResult<Prisma.$userPayload<ExtArgs>, T, 'findFirstOrThrow'>, never, ExtArgs>

    /**
     * Find zero or more Users that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {userFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Users
     * const users = await prisma.user.findMany()
     * 
     * // Get first 10 Users
     * const users = await prisma.user.findMany({ take: 10 })
     * 
     * // Only select the `userID`
     * const userWithUserIDOnly = await prisma.user.findMany({ select: { userID: true } })
     * 
    **/
    findMany<T extends userFindManyArgs<ExtArgs>>(
      args?: SelectSubset<T, userFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<$Result.GetResult<Prisma.$userPayload<ExtArgs>, T, 'findMany'>>

    /**
     * Create a User.
     * @param {userCreateArgs} args - Arguments to create a User.
     * @example
     * // Create one User
     * const User = await prisma.user.create({
     *   data: {
     *     // ... data to create a User
     *   }
     * })
     * 
    **/
    create<T extends userCreateArgs<ExtArgs>>(
      args: SelectSubset<T, userCreateArgs<ExtArgs>>
    ): Prisma__userClient<$Result.GetResult<Prisma.$userPayload<ExtArgs>, T, 'create'>, never, ExtArgs>

    /**
     * Create many Users.
     *     @param {userCreateManyArgs} args - Arguments to create many Users.
     *     @example
     *     // Create many Users
     *     const user = await prisma.user.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends userCreateManyArgs<ExtArgs>>(
      args?: SelectSubset<T, userCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a User.
     * @param {userDeleteArgs} args - Arguments to delete one User.
     * @example
     * // Delete one User
     * const User = await prisma.user.delete({
     *   where: {
     *     // ... filter to delete one User
     *   }
     * })
     * 
    **/
    delete<T extends userDeleteArgs<ExtArgs>>(
      args: SelectSubset<T, userDeleteArgs<ExtArgs>>
    ): Prisma__userClient<$Result.GetResult<Prisma.$userPayload<ExtArgs>, T, 'delete'>, never, ExtArgs>

    /**
     * Update one User.
     * @param {userUpdateArgs} args - Arguments to update one User.
     * @example
     * // Update one User
     * const user = await prisma.user.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends userUpdateArgs<ExtArgs>>(
      args: SelectSubset<T, userUpdateArgs<ExtArgs>>
    ): Prisma__userClient<$Result.GetResult<Prisma.$userPayload<ExtArgs>, T, 'update'>, never, ExtArgs>

    /**
     * Delete zero or more Users.
     * @param {userDeleteManyArgs} args - Arguments to filter Users to delete.
     * @example
     * // Delete a few Users
     * const { count } = await prisma.user.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends userDeleteManyArgs<ExtArgs>>(
      args?: SelectSubset<T, userDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Users.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {userUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Users
     * const user = await prisma.user.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends userUpdateManyArgs<ExtArgs>>(
      args: SelectSubset<T, userUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one User.
     * @param {userUpsertArgs} args - Arguments to update or create a User.
     * @example
     * // Update or create a User
     * const user = await prisma.user.upsert({
     *   create: {
     *     // ... data to create a User
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the User we want to update
     *   }
     * })
    **/
    upsert<T extends userUpsertArgs<ExtArgs>>(
      args: SelectSubset<T, userUpsertArgs<ExtArgs>>
    ): Prisma__userClient<$Result.GetResult<Prisma.$userPayload<ExtArgs>, T, 'upsert'>, never, ExtArgs>

    /**
     * Count the number of Users.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {userCountArgs} args - Arguments to filter Users to count.
     * @example
     * // Count the number of Users
     * const count = await prisma.user.count({
     *   where: {
     *     // ... the filter for the Users we want to count
     *   }
     * })
    **/
    count<T extends userCountArgs>(
      args?: Subset<T, userCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], UserCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a User.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends UserAggregateArgs>(args: Subset<T, UserAggregateArgs>): Prisma.PrismaPromise<GetUserAggregateType<T>>

    /**
     * Group by User.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {userGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends userGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: userGroupByArgs['orderBy'] }
        : { orderBy?: userGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, userGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetUserGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the user model
   */
  readonly fields: userFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for user.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__userClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: 'PrismaPromise';

    profile<T extends user$profileArgs<ExtArgs> = {}>(args?: Subset<T, user$profileArgs<ExtArgs>>): Prisma__profileClient<$Result.GetResult<Prisma.$profilePayload<ExtArgs>, T, 'findUniqueOrThrow'> | null, null, ExtArgs>;

    blog<T extends user$blogArgs<ExtArgs> = {}>(args?: Subset<T, user$blogArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$blogsPayload<ExtArgs>, T, 'findMany'> | Null>;

    faqs<T extends user$faqsArgs<ExtArgs> = {}>(args?: Subset<T, user$faqsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$faqsPayload<ExtArgs>, T, 'findMany'> | Null>;

    equipment<T extends user$equipmentArgs<ExtArgs> = {}>(args?: Subset<T, user$equipmentArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$equipmentPayload<ExtArgs>, T, 'findMany'> | Null>;

    prescription<T extends user$prescriptionArgs<ExtArgs> = {}>(args?: Subset<T, user$prescriptionArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$presciptionPayload<ExtArgs>, T, 'findMany'> | Null>;

    feedback<T extends user$feedbackArgs<ExtArgs> = {}>(args?: Subset<T, user$feedbackArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$feedbackPayload<ExtArgs>, T, 'findMany'> | Null>;

    appointment<T extends user$appointmentArgs<ExtArgs> = {}>(args?: Subset<T, user$appointmentArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$appointmentPayload<ExtArgs>, T, 'findMany'> | Null>;

    diagnosis<T extends user$diagnosisArgs<ExtArgs> = {}>(args?: Subset<T, user$diagnosisArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$diagnosisPayload<ExtArgs>, T, 'findMany'> | Null>;

    otp<T extends user$otpArgs<ExtArgs> = {}>(args?: Subset<T, user$otpArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$otpPayload<ExtArgs>, T, 'findMany'> | Null>;

    services<T extends user$servicesArgs<ExtArgs> = {}>(args?: Subset<T, user$servicesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$servicesPayload<ExtArgs>, T, 'findMany'> | Null>;

    preDiagnostic<T extends user$preDiagnosticArgs<ExtArgs> = {}>(args?: Subset<T, user$preDiagnosticArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$prediagPayload<ExtArgs>, T, 'findMany'> | Null>;

    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>;
  }



  /**
   * Fields of the user model
   */ 
  interface userFieldRefs {
    readonly userID: FieldRef<"user", 'String'>
    readonly email: FieldRef<"user", 'String'>
    readonly password: FieldRef<"user", 'String'>
    readonly role: FieldRef<"user", 'roles'>
    readonly verified: FieldRef<"user", 'Boolean'>
    readonly creatdAt: FieldRef<"user", 'DateTime'>
    readonly updateAt: FieldRef<"user", 'DateTime'>
  }
    

  // Custom InputTypes

  /**
   * user findUnique
   */
  export type userFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the user
     */
    select?: userSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: userInclude<ExtArgs> | null
    /**
     * Filter, which user to fetch.
     */
    where: userWhereUniqueInput
  }


  /**
   * user findUniqueOrThrow
   */
  export type userFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the user
     */
    select?: userSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: userInclude<ExtArgs> | null
    /**
     * Filter, which user to fetch.
     */
    where: userWhereUniqueInput
  }


  /**
   * user findFirst
   */
  export type userFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the user
     */
    select?: userSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: userInclude<ExtArgs> | null
    /**
     * Filter, which user to fetch.
     */
    where?: userWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of users to fetch.
     */
    orderBy?: userOrderByWithRelationInput | userOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for users.
     */
    cursor?: userWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` users.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of users.
     */
    distinct?: UserScalarFieldEnum | UserScalarFieldEnum[]
  }


  /**
   * user findFirstOrThrow
   */
  export type userFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the user
     */
    select?: userSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: userInclude<ExtArgs> | null
    /**
     * Filter, which user to fetch.
     */
    where?: userWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of users to fetch.
     */
    orderBy?: userOrderByWithRelationInput | userOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for users.
     */
    cursor?: userWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` users.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of users.
     */
    distinct?: UserScalarFieldEnum | UserScalarFieldEnum[]
  }


  /**
   * user findMany
   */
  export type userFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the user
     */
    select?: userSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: userInclude<ExtArgs> | null
    /**
     * Filter, which users to fetch.
     */
    where?: userWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of users to fetch.
     */
    orderBy?: userOrderByWithRelationInput | userOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing users.
     */
    cursor?: userWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` users.
     */
    skip?: number
    distinct?: UserScalarFieldEnum | UserScalarFieldEnum[]
  }


  /**
   * user create
   */
  export type userCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the user
     */
    select?: userSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: userInclude<ExtArgs> | null
    /**
     * The data needed to create a user.
     */
    data: XOR<userCreateInput, userUncheckedCreateInput>
  }


  /**
   * user createMany
   */
  export type userCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many users.
     */
    data: userCreateManyInput | userCreateManyInput[]
    skipDuplicates?: boolean
  }


  /**
   * user update
   */
  export type userUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the user
     */
    select?: userSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: userInclude<ExtArgs> | null
    /**
     * The data needed to update a user.
     */
    data: XOR<userUpdateInput, userUncheckedUpdateInput>
    /**
     * Choose, which user to update.
     */
    where: userWhereUniqueInput
  }


  /**
   * user updateMany
   */
  export type userUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update users.
     */
    data: XOR<userUpdateManyMutationInput, userUncheckedUpdateManyInput>
    /**
     * Filter which users to update
     */
    where?: userWhereInput
  }


  /**
   * user upsert
   */
  export type userUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the user
     */
    select?: userSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: userInclude<ExtArgs> | null
    /**
     * The filter to search for the user to update in case it exists.
     */
    where: userWhereUniqueInput
    /**
     * In case the user found by the `where` argument doesn't exist, create a new user with this data.
     */
    create: XOR<userCreateInput, userUncheckedCreateInput>
    /**
     * In case the user was found with the provided `where` argument, update it with this data.
     */
    update: XOR<userUpdateInput, userUncheckedUpdateInput>
  }


  /**
   * user delete
   */
  export type userDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the user
     */
    select?: userSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: userInclude<ExtArgs> | null
    /**
     * Filter which user to delete.
     */
    where: userWhereUniqueInput
  }


  /**
   * user deleteMany
   */
  export type userDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which users to delete
     */
    where?: userWhereInput
  }


  /**
   * user.profile
   */
  export type user$profileArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the profile
     */
    select?: profileSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: profileInclude<ExtArgs> | null
    where?: profileWhereInput
  }


  /**
   * user.blog
   */
  export type user$blogArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the blogs
     */
    select?: blogsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: blogsInclude<ExtArgs> | null
    where?: blogsWhereInput
    orderBy?: blogsOrderByWithRelationInput | blogsOrderByWithRelationInput[]
    cursor?: blogsWhereUniqueInput
    take?: number
    skip?: number
    distinct?: BlogsScalarFieldEnum | BlogsScalarFieldEnum[]
  }


  /**
   * user.faqs
   */
  export type user$faqsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the faqs
     */
    select?: faqsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: faqsInclude<ExtArgs> | null
    where?: faqsWhereInput
    orderBy?: faqsOrderByWithRelationInput | faqsOrderByWithRelationInput[]
    cursor?: faqsWhereUniqueInput
    take?: number
    skip?: number
    distinct?: FaqsScalarFieldEnum | FaqsScalarFieldEnum[]
  }


  /**
   * user.equipment
   */
  export type user$equipmentArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the equipment
     */
    select?: equipmentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: equipmentInclude<ExtArgs> | null
    where?: equipmentWhereInput
    orderBy?: equipmentOrderByWithRelationInput | equipmentOrderByWithRelationInput[]
    cursor?: equipmentWhereUniqueInput
    take?: number
    skip?: number
    distinct?: EquipmentScalarFieldEnum | EquipmentScalarFieldEnum[]
  }


  /**
   * user.prescription
   */
  export type user$prescriptionArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the presciption
     */
    select?: presciptionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: presciptionInclude<ExtArgs> | null
    where?: presciptionWhereInput
    orderBy?: presciptionOrderByWithRelationInput | presciptionOrderByWithRelationInput[]
    cursor?: presciptionWhereUniqueInput
    take?: number
    skip?: number
    distinct?: PresciptionScalarFieldEnum | PresciptionScalarFieldEnum[]
  }


  /**
   * user.feedback
   */
  export type user$feedbackArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the feedback
     */
    select?: feedbackSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: feedbackInclude<ExtArgs> | null
    where?: feedbackWhereInput
    orderBy?: feedbackOrderByWithRelationInput | feedbackOrderByWithRelationInput[]
    cursor?: feedbackWhereUniqueInput
    take?: number
    skip?: number
    distinct?: FeedbackScalarFieldEnum | FeedbackScalarFieldEnum[]
  }


  /**
   * user.appointment
   */
  export type user$appointmentArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the appointment
     */
    select?: appointmentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: appointmentInclude<ExtArgs> | null
    where?: appointmentWhereInput
    orderBy?: appointmentOrderByWithRelationInput | appointmentOrderByWithRelationInput[]
    cursor?: appointmentWhereUniqueInput
    take?: number
    skip?: number
    distinct?: AppointmentScalarFieldEnum | AppointmentScalarFieldEnum[]
  }


  /**
   * user.diagnosis
   */
  export type user$diagnosisArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the diagnosis
     */
    select?: diagnosisSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: diagnosisInclude<ExtArgs> | null
    where?: diagnosisWhereInput
    orderBy?: diagnosisOrderByWithRelationInput | diagnosisOrderByWithRelationInput[]
    cursor?: diagnosisWhereUniqueInput
    take?: number
    skip?: number
    distinct?: DiagnosisScalarFieldEnum | DiagnosisScalarFieldEnum[]
  }


  /**
   * user.otp
   */
  export type user$otpArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the otp
     */
    select?: otpSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: otpInclude<ExtArgs> | null
    where?: otpWhereInput
    orderBy?: otpOrderByWithRelationInput | otpOrderByWithRelationInput[]
    cursor?: otpWhereUniqueInput
    take?: number
    skip?: number
    distinct?: OtpScalarFieldEnum | OtpScalarFieldEnum[]
  }


  /**
   * user.services
   */
  export type user$servicesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the services
     */
    select?: servicesSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: servicesInclude<ExtArgs> | null
    where?: servicesWhereInput
    orderBy?: servicesOrderByWithRelationInput | servicesOrderByWithRelationInput[]
    cursor?: servicesWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ServicesScalarFieldEnum | ServicesScalarFieldEnum[]
  }


  /**
   * user.preDiagnostic
   */
  export type user$preDiagnosticArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the prediag
     */
    select?: prediagSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: prediagInclude<ExtArgs> | null
    where?: prediagWhereInput
    orderBy?: prediagOrderByWithRelationInput | prediagOrderByWithRelationInput[]
    cursor?: prediagWhereUniqueInput
    take?: number
    skip?: number
    distinct?: PrediagScalarFieldEnum | PrediagScalarFieldEnum[]
  }


  /**
   * user without action
   */
  export type userDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the user
     */
    select?: userSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: userInclude<ExtArgs> | null
  }



  /**
   * Model services
   */

  export type AggregateServices = {
    _count: ServicesCountAggregateOutputType | null
    _avg: ServicesAvgAggregateOutputType | null
    _sum: ServicesSumAggregateOutputType | null
    _min: ServicesMinAggregateOutputType | null
    _max: ServicesMaxAggregateOutputType | null
  }

  export type ServicesAvgAggregateOutputType = {
    price: number | null
  }

  export type ServicesSumAggregateOutputType = {
    price: number | null
  }

  export type ServicesMinAggregateOutputType = {
    servicesID: string | null
    services: string | null
    descriptions: string | null
    image: string | null
    price: number | null
    userID: string | null
  }

  export type ServicesMaxAggregateOutputType = {
    servicesID: string | null
    services: string | null
    descriptions: string | null
    image: string | null
    price: number | null
    userID: string | null
  }

  export type ServicesCountAggregateOutputType = {
    servicesID: number
    services: number
    descriptions: number
    image: number
    price: number
    userID: number
    _all: number
  }


  export type ServicesAvgAggregateInputType = {
    price?: true
  }

  export type ServicesSumAggregateInputType = {
    price?: true
  }

  export type ServicesMinAggregateInputType = {
    servicesID?: true
    services?: true
    descriptions?: true
    image?: true
    price?: true
    userID?: true
  }

  export type ServicesMaxAggregateInputType = {
    servicesID?: true
    services?: true
    descriptions?: true
    image?: true
    price?: true
    userID?: true
  }

  export type ServicesCountAggregateInputType = {
    servicesID?: true
    services?: true
    descriptions?: true
    image?: true
    price?: true
    userID?: true
    _all?: true
  }

  export type ServicesAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which services to aggregate.
     */
    where?: servicesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of services to fetch.
     */
    orderBy?: servicesOrderByWithRelationInput | servicesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: servicesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` services from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` services.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned services
    **/
    _count?: true | ServicesCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: ServicesAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: ServicesSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ServicesMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ServicesMaxAggregateInputType
  }

  export type GetServicesAggregateType<T extends ServicesAggregateArgs> = {
        [P in keyof T & keyof AggregateServices]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateServices[P]>
      : GetScalarType<T[P], AggregateServices[P]>
  }




  export type servicesGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: servicesWhereInput
    orderBy?: servicesOrderByWithAggregationInput | servicesOrderByWithAggregationInput[]
    by: ServicesScalarFieldEnum[] | ServicesScalarFieldEnum
    having?: servicesScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ServicesCountAggregateInputType | true
    _avg?: ServicesAvgAggregateInputType
    _sum?: ServicesSumAggregateInputType
    _min?: ServicesMinAggregateInputType
    _max?: ServicesMaxAggregateInputType
  }

  export type ServicesGroupByOutputType = {
    servicesID: string
    services: string
    descriptions: string
    image: string
    price: number
    userID: string | null
    _count: ServicesCountAggregateOutputType | null
    _avg: ServicesAvgAggregateOutputType | null
    _sum: ServicesSumAggregateOutputType | null
    _min: ServicesMinAggregateOutputType | null
    _max: ServicesMaxAggregateOutputType | null
  }

  type GetServicesGroupByPayload<T extends servicesGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ServicesGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ServicesGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ServicesGroupByOutputType[P]>
            : GetScalarType<T[P], ServicesGroupByOutputType[P]>
        }
      >
    >


  export type servicesSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    servicesID?: boolean
    services?: boolean
    descriptions?: boolean
    image?: boolean
    price?: boolean
    userID?: boolean
    user?: boolean | services$userArgs<ExtArgs>
    appointment?: boolean | services$appointmentArgs<ExtArgs>
    _count?: boolean | ServicesCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["services"]>

  export type servicesSelectScalar = {
    servicesID?: boolean
    services?: boolean
    descriptions?: boolean
    image?: boolean
    price?: boolean
    userID?: boolean
  }

  export type servicesInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | services$userArgs<ExtArgs>
    appointment?: boolean | services$appointmentArgs<ExtArgs>
    _count?: boolean | ServicesCountOutputTypeDefaultArgs<ExtArgs>
  }


  export type $servicesPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "services"
    objects: {
      user: Prisma.$userPayload<ExtArgs> | null
      appointment: Prisma.$appointmentPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      servicesID: string
      services: string
      descriptions: string
      image: string
      price: number
      userID: string | null
    }, ExtArgs["result"]["services"]>
    composites: {}
  }


  type servicesGetPayload<S extends boolean | null | undefined | servicesDefaultArgs> = $Result.GetResult<Prisma.$servicesPayload, S>

  type servicesCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<servicesFindManyArgs, 'select' | 'include' | 'distinct' > & {
      select?: ServicesCountAggregateInputType | true
    }

  export interface servicesDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['services'], meta: { name: 'services' } }
    /**
     * Find zero or one Services that matches the filter.
     * @param {servicesFindUniqueArgs} args - Arguments to find a Services
     * @example
     * // Get one Services
     * const services = await prisma.services.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends servicesFindUniqueArgs<ExtArgs>>(
      args: SelectSubset<T, servicesFindUniqueArgs<ExtArgs>>
    ): Prisma__servicesClient<$Result.GetResult<Prisma.$servicesPayload<ExtArgs>, T, 'findUnique'> | null, null, ExtArgs>

    /**
     * Find one Services that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {servicesFindUniqueOrThrowArgs} args - Arguments to find a Services
     * @example
     * // Get one Services
     * const services = await prisma.services.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends servicesFindUniqueOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, servicesFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__servicesClient<$Result.GetResult<Prisma.$servicesPayload<ExtArgs>, T, 'findUniqueOrThrow'>, never, ExtArgs>

    /**
     * Find the first Services that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {servicesFindFirstArgs} args - Arguments to find a Services
     * @example
     * // Get one Services
     * const services = await prisma.services.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends servicesFindFirstArgs<ExtArgs>>(
      args?: SelectSubset<T, servicesFindFirstArgs<ExtArgs>>
    ): Prisma__servicesClient<$Result.GetResult<Prisma.$servicesPayload<ExtArgs>, T, 'findFirst'> | null, null, ExtArgs>

    /**
     * Find the first Services that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {servicesFindFirstOrThrowArgs} args - Arguments to find a Services
     * @example
     * // Get one Services
     * const services = await prisma.services.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends servicesFindFirstOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, servicesFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__servicesClient<$Result.GetResult<Prisma.$servicesPayload<ExtArgs>, T, 'findFirstOrThrow'>, never, ExtArgs>

    /**
     * Find zero or more Services that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {servicesFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Services
     * const services = await prisma.services.findMany()
     * 
     * // Get first 10 Services
     * const services = await prisma.services.findMany({ take: 10 })
     * 
     * // Only select the `servicesID`
     * const servicesWithServicesIDOnly = await prisma.services.findMany({ select: { servicesID: true } })
     * 
    **/
    findMany<T extends servicesFindManyArgs<ExtArgs>>(
      args?: SelectSubset<T, servicesFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<$Result.GetResult<Prisma.$servicesPayload<ExtArgs>, T, 'findMany'>>

    /**
     * Create a Services.
     * @param {servicesCreateArgs} args - Arguments to create a Services.
     * @example
     * // Create one Services
     * const Services = await prisma.services.create({
     *   data: {
     *     // ... data to create a Services
     *   }
     * })
     * 
    **/
    create<T extends servicesCreateArgs<ExtArgs>>(
      args: SelectSubset<T, servicesCreateArgs<ExtArgs>>
    ): Prisma__servicesClient<$Result.GetResult<Prisma.$servicesPayload<ExtArgs>, T, 'create'>, never, ExtArgs>

    /**
     * Create many Services.
     *     @param {servicesCreateManyArgs} args - Arguments to create many Services.
     *     @example
     *     // Create many Services
     *     const services = await prisma.services.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends servicesCreateManyArgs<ExtArgs>>(
      args?: SelectSubset<T, servicesCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Services.
     * @param {servicesDeleteArgs} args - Arguments to delete one Services.
     * @example
     * // Delete one Services
     * const Services = await prisma.services.delete({
     *   where: {
     *     // ... filter to delete one Services
     *   }
     * })
     * 
    **/
    delete<T extends servicesDeleteArgs<ExtArgs>>(
      args: SelectSubset<T, servicesDeleteArgs<ExtArgs>>
    ): Prisma__servicesClient<$Result.GetResult<Prisma.$servicesPayload<ExtArgs>, T, 'delete'>, never, ExtArgs>

    /**
     * Update one Services.
     * @param {servicesUpdateArgs} args - Arguments to update one Services.
     * @example
     * // Update one Services
     * const services = await prisma.services.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends servicesUpdateArgs<ExtArgs>>(
      args: SelectSubset<T, servicesUpdateArgs<ExtArgs>>
    ): Prisma__servicesClient<$Result.GetResult<Prisma.$servicesPayload<ExtArgs>, T, 'update'>, never, ExtArgs>

    /**
     * Delete zero or more Services.
     * @param {servicesDeleteManyArgs} args - Arguments to filter Services to delete.
     * @example
     * // Delete a few Services
     * const { count } = await prisma.services.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends servicesDeleteManyArgs<ExtArgs>>(
      args?: SelectSubset<T, servicesDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Services.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {servicesUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Services
     * const services = await prisma.services.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends servicesUpdateManyArgs<ExtArgs>>(
      args: SelectSubset<T, servicesUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Services.
     * @param {servicesUpsertArgs} args - Arguments to update or create a Services.
     * @example
     * // Update or create a Services
     * const services = await prisma.services.upsert({
     *   create: {
     *     // ... data to create a Services
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Services we want to update
     *   }
     * })
    **/
    upsert<T extends servicesUpsertArgs<ExtArgs>>(
      args: SelectSubset<T, servicesUpsertArgs<ExtArgs>>
    ): Prisma__servicesClient<$Result.GetResult<Prisma.$servicesPayload<ExtArgs>, T, 'upsert'>, never, ExtArgs>

    /**
     * Count the number of Services.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {servicesCountArgs} args - Arguments to filter Services to count.
     * @example
     * // Count the number of Services
     * const count = await prisma.services.count({
     *   where: {
     *     // ... the filter for the Services we want to count
     *   }
     * })
    **/
    count<T extends servicesCountArgs>(
      args?: Subset<T, servicesCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ServicesCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Services.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ServicesAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ServicesAggregateArgs>(args: Subset<T, ServicesAggregateArgs>): Prisma.PrismaPromise<GetServicesAggregateType<T>>

    /**
     * Group by Services.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {servicesGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends servicesGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: servicesGroupByArgs['orderBy'] }
        : { orderBy?: servicesGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, servicesGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetServicesGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the services model
   */
  readonly fields: servicesFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for services.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__servicesClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: 'PrismaPromise';

    user<T extends services$userArgs<ExtArgs> = {}>(args?: Subset<T, services$userArgs<ExtArgs>>): Prisma__userClient<$Result.GetResult<Prisma.$userPayload<ExtArgs>, T, 'findUniqueOrThrow'> | null, null, ExtArgs>;

    appointment<T extends services$appointmentArgs<ExtArgs> = {}>(args?: Subset<T, services$appointmentArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$appointmentPayload<ExtArgs>, T, 'findMany'> | Null>;

    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>;
  }



  /**
   * Fields of the services model
   */ 
  interface servicesFieldRefs {
    readonly servicesID: FieldRef<"services", 'String'>
    readonly services: FieldRef<"services", 'String'>
    readonly descriptions: FieldRef<"services", 'String'>
    readonly image: FieldRef<"services", 'String'>
    readonly price: FieldRef<"services", 'Float'>
    readonly userID: FieldRef<"services", 'String'>
  }
    

  // Custom InputTypes

  /**
   * services findUnique
   */
  export type servicesFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the services
     */
    select?: servicesSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: servicesInclude<ExtArgs> | null
    /**
     * Filter, which services to fetch.
     */
    where: servicesWhereUniqueInput
  }


  /**
   * services findUniqueOrThrow
   */
  export type servicesFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the services
     */
    select?: servicesSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: servicesInclude<ExtArgs> | null
    /**
     * Filter, which services to fetch.
     */
    where: servicesWhereUniqueInput
  }


  /**
   * services findFirst
   */
  export type servicesFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the services
     */
    select?: servicesSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: servicesInclude<ExtArgs> | null
    /**
     * Filter, which services to fetch.
     */
    where?: servicesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of services to fetch.
     */
    orderBy?: servicesOrderByWithRelationInput | servicesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for services.
     */
    cursor?: servicesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` services from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` services.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of services.
     */
    distinct?: ServicesScalarFieldEnum | ServicesScalarFieldEnum[]
  }


  /**
   * services findFirstOrThrow
   */
  export type servicesFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the services
     */
    select?: servicesSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: servicesInclude<ExtArgs> | null
    /**
     * Filter, which services to fetch.
     */
    where?: servicesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of services to fetch.
     */
    orderBy?: servicesOrderByWithRelationInput | servicesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for services.
     */
    cursor?: servicesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` services from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` services.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of services.
     */
    distinct?: ServicesScalarFieldEnum | ServicesScalarFieldEnum[]
  }


  /**
   * services findMany
   */
  export type servicesFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the services
     */
    select?: servicesSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: servicesInclude<ExtArgs> | null
    /**
     * Filter, which services to fetch.
     */
    where?: servicesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of services to fetch.
     */
    orderBy?: servicesOrderByWithRelationInput | servicesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing services.
     */
    cursor?: servicesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` services from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` services.
     */
    skip?: number
    distinct?: ServicesScalarFieldEnum | ServicesScalarFieldEnum[]
  }


  /**
   * services create
   */
  export type servicesCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the services
     */
    select?: servicesSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: servicesInclude<ExtArgs> | null
    /**
     * The data needed to create a services.
     */
    data: XOR<servicesCreateInput, servicesUncheckedCreateInput>
  }


  /**
   * services createMany
   */
  export type servicesCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many services.
     */
    data: servicesCreateManyInput | servicesCreateManyInput[]
    skipDuplicates?: boolean
  }


  /**
   * services update
   */
  export type servicesUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the services
     */
    select?: servicesSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: servicesInclude<ExtArgs> | null
    /**
     * The data needed to update a services.
     */
    data: XOR<servicesUpdateInput, servicesUncheckedUpdateInput>
    /**
     * Choose, which services to update.
     */
    where: servicesWhereUniqueInput
  }


  /**
   * services updateMany
   */
  export type servicesUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update services.
     */
    data: XOR<servicesUpdateManyMutationInput, servicesUncheckedUpdateManyInput>
    /**
     * Filter which services to update
     */
    where?: servicesWhereInput
  }


  /**
   * services upsert
   */
  export type servicesUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the services
     */
    select?: servicesSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: servicesInclude<ExtArgs> | null
    /**
     * The filter to search for the services to update in case it exists.
     */
    where: servicesWhereUniqueInput
    /**
     * In case the services found by the `where` argument doesn't exist, create a new services with this data.
     */
    create: XOR<servicesCreateInput, servicesUncheckedCreateInput>
    /**
     * In case the services was found with the provided `where` argument, update it with this data.
     */
    update: XOR<servicesUpdateInput, servicesUncheckedUpdateInput>
  }


  /**
   * services delete
   */
  export type servicesDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the services
     */
    select?: servicesSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: servicesInclude<ExtArgs> | null
    /**
     * Filter which services to delete.
     */
    where: servicesWhereUniqueInput
  }


  /**
   * services deleteMany
   */
  export type servicesDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which services to delete
     */
    where?: servicesWhereInput
  }


  /**
   * services.user
   */
  export type services$userArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the user
     */
    select?: userSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: userInclude<ExtArgs> | null
    where?: userWhereInput
  }


  /**
   * services.appointment
   */
  export type services$appointmentArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the appointment
     */
    select?: appointmentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: appointmentInclude<ExtArgs> | null
    where?: appointmentWhereInput
    orderBy?: appointmentOrderByWithRelationInput | appointmentOrderByWithRelationInput[]
    cursor?: appointmentWhereUniqueInput
    take?: number
    skip?: number
    distinct?: AppointmentScalarFieldEnum | AppointmentScalarFieldEnum[]
  }


  /**
   * services without action
   */
  export type servicesDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the services
     */
    select?: servicesSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: servicesInclude<ExtArgs> | null
  }



  /**
   * Model otp
   */

  export type AggregateOtp = {
    _count: OtpCountAggregateOutputType | null
    _min: OtpMinAggregateOutputType | null
    _max: OtpMaxAggregateOutputType | null
  }

  export type OtpMinAggregateOutputType = {
    otpID: string | null
    otp: string | null
    expiredAt: Date | null
    createdAt: Date | null
  }

  export type OtpMaxAggregateOutputType = {
    otpID: string | null
    otp: string | null
    expiredAt: Date | null
    createdAt: Date | null
  }

  export type OtpCountAggregateOutputType = {
    otpID: number
    otp: number
    expiredAt: number
    createdAt: number
    _all: number
  }


  export type OtpMinAggregateInputType = {
    otpID?: true
    otp?: true
    expiredAt?: true
    createdAt?: true
  }

  export type OtpMaxAggregateInputType = {
    otpID?: true
    otp?: true
    expiredAt?: true
    createdAt?: true
  }

  export type OtpCountAggregateInputType = {
    otpID?: true
    otp?: true
    expiredAt?: true
    createdAt?: true
    _all?: true
  }

  export type OtpAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which otp to aggregate.
     */
    where?: otpWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of otps to fetch.
     */
    orderBy?: otpOrderByWithRelationInput | otpOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: otpWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` otps from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` otps.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned otps
    **/
    _count?: true | OtpCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: OtpMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: OtpMaxAggregateInputType
  }

  export type GetOtpAggregateType<T extends OtpAggregateArgs> = {
        [P in keyof T & keyof AggregateOtp]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateOtp[P]>
      : GetScalarType<T[P], AggregateOtp[P]>
  }




  export type otpGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: otpWhereInput
    orderBy?: otpOrderByWithAggregationInput | otpOrderByWithAggregationInput[]
    by: OtpScalarFieldEnum[] | OtpScalarFieldEnum
    having?: otpScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: OtpCountAggregateInputType | true
    _min?: OtpMinAggregateInputType
    _max?: OtpMaxAggregateInputType
  }

  export type OtpGroupByOutputType = {
    otpID: string
    otp: string
    expiredAt: Date
    createdAt: Date
    _count: OtpCountAggregateOutputType | null
    _min: OtpMinAggregateOutputType | null
    _max: OtpMaxAggregateOutputType | null
  }

  type GetOtpGroupByPayload<T extends otpGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<OtpGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof OtpGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], OtpGroupByOutputType[P]>
            : GetScalarType<T[P], OtpGroupByOutputType[P]>
        }
      >
    >


  export type otpSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    otpID?: boolean
    otp?: boolean
    expiredAt?: boolean
    createdAt?: boolean
    user?: boolean | otp$userArgs<ExtArgs>
    _count?: boolean | OtpCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["otp"]>

  export type otpSelectScalar = {
    otpID?: boolean
    otp?: boolean
    expiredAt?: boolean
    createdAt?: boolean
  }

  export type otpInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | otp$userArgs<ExtArgs>
    _count?: boolean | OtpCountOutputTypeDefaultArgs<ExtArgs>
  }


  export type $otpPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "otp"
    objects: {
      user: Prisma.$userPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      otpID: string
      otp: string
      expiredAt: Date
      createdAt: Date
    }, ExtArgs["result"]["otp"]>
    composites: {}
  }


  type otpGetPayload<S extends boolean | null | undefined | otpDefaultArgs> = $Result.GetResult<Prisma.$otpPayload, S>

  type otpCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<otpFindManyArgs, 'select' | 'include' | 'distinct' > & {
      select?: OtpCountAggregateInputType | true
    }

  export interface otpDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['otp'], meta: { name: 'otp' } }
    /**
     * Find zero or one Otp that matches the filter.
     * @param {otpFindUniqueArgs} args - Arguments to find a Otp
     * @example
     * // Get one Otp
     * const otp = await prisma.otp.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends otpFindUniqueArgs<ExtArgs>>(
      args: SelectSubset<T, otpFindUniqueArgs<ExtArgs>>
    ): Prisma__otpClient<$Result.GetResult<Prisma.$otpPayload<ExtArgs>, T, 'findUnique'> | null, null, ExtArgs>

    /**
     * Find one Otp that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {otpFindUniqueOrThrowArgs} args - Arguments to find a Otp
     * @example
     * // Get one Otp
     * const otp = await prisma.otp.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends otpFindUniqueOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, otpFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__otpClient<$Result.GetResult<Prisma.$otpPayload<ExtArgs>, T, 'findUniqueOrThrow'>, never, ExtArgs>

    /**
     * Find the first Otp that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {otpFindFirstArgs} args - Arguments to find a Otp
     * @example
     * // Get one Otp
     * const otp = await prisma.otp.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends otpFindFirstArgs<ExtArgs>>(
      args?: SelectSubset<T, otpFindFirstArgs<ExtArgs>>
    ): Prisma__otpClient<$Result.GetResult<Prisma.$otpPayload<ExtArgs>, T, 'findFirst'> | null, null, ExtArgs>

    /**
     * Find the first Otp that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {otpFindFirstOrThrowArgs} args - Arguments to find a Otp
     * @example
     * // Get one Otp
     * const otp = await prisma.otp.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends otpFindFirstOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, otpFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__otpClient<$Result.GetResult<Prisma.$otpPayload<ExtArgs>, T, 'findFirstOrThrow'>, never, ExtArgs>

    /**
     * Find zero or more Otps that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {otpFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Otps
     * const otps = await prisma.otp.findMany()
     * 
     * // Get first 10 Otps
     * const otps = await prisma.otp.findMany({ take: 10 })
     * 
     * // Only select the `otpID`
     * const otpWithOtpIDOnly = await prisma.otp.findMany({ select: { otpID: true } })
     * 
    **/
    findMany<T extends otpFindManyArgs<ExtArgs>>(
      args?: SelectSubset<T, otpFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<$Result.GetResult<Prisma.$otpPayload<ExtArgs>, T, 'findMany'>>

    /**
     * Create a Otp.
     * @param {otpCreateArgs} args - Arguments to create a Otp.
     * @example
     * // Create one Otp
     * const Otp = await prisma.otp.create({
     *   data: {
     *     // ... data to create a Otp
     *   }
     * })
     * 
    **/
    create<T extends otpCreateArgs<ExtArgs>>(
      args: SelectSubset<T, otpCreateArgs<ExtArgs>>
    ): Prisma__otpClient<$Result.GetResult<Prisma.$otpPayload<ExtArgs>, T, 'create'>, never, ExtArgs>

    /**
     * Create many Otps.
     *     @param {otpCreateManyArgs} args - Arguments to create many Otps.
     *     @example
     *     // Create many Otps
     *     const otp = await prisma.otp.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends otpCreateManyArgs<ExtArgs>>(
      args?: SelectSubset<T, otpCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Otp.
     * @param {otpDeleteArgs} args - Arguments to delete one Otp.
     * @example
     * // Delete one Otp
     * const Otp = await prisma.otp.delete({
     *   where: {
     *     // ... filter to delete one Otp
     *   }
     * })
     * 
    **/
    delete<T extends otpDeleteArgs<ExtArgs>>(
      args: SelectSubset<T, otpDeleteArgs<ExtArgs>>
    ): Prisma__otpClient<$Result.GetResult<Prisma.$otpPayload<ExtArgs>, T, 'delete'>, never, ExtArgs>

    /**
     * Update one Otp.
     * @param {otpUpdateArgs} args - Arguments to update one Otp.
     * @example
     * // Update one Otp
     * const otp = await prisma.otp.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends otpUpdateArgs<ExtArgs>>(
      args: SelectSubset<T, otpUpdateArgs<ExtArgs>>
    ): Prisma__otpClient<$Result.GetResult<Prisma.$otpPayload<ExtArgs>, T, 'update'>, never, ExtArgs>

    /**
     * Delete zero or more Otps.
     * @param {otpDeleteManyArgs} args - Arguments to filter Otps to delete.
     * @example
     * // Delete a few Otps
     * const { count } = await prisma.otp.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends otpDeleteManyArgs<ExtArgs>>(
      args?: SelectSubset<T, otpDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Otps.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {otpUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Otps
     * const otp = await prisma.otp.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends otpUpdateManyArgs<ExtArgs>>(
      args: SelectSubset<T, otpUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Otp.
     * @param {otpUpsertArgs} args - Arguments to update or create a Otp.
     * @example
     * // Update or create a Otp
     * const otp = await prisma.otp.upsert({
     *   create: {
     *     // ... data to create a Otp
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Otp we want to update
     *   }
     * })
    **/
    upsert<T extends otpUpsertArgs<ExtArgs>>(
      args: SelectSubset<T, otpUpsertArgs<ExtArgs>>
    ): Prisma__otpClient<$Result.GetResult<Prisma.$otpPayload<ExtArgs>, T, 'upsert'>, never, ExtArgs>

    /**
     * Count the number of Otps.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {otpCountArgs} args - Arguments to filter Otps to count.
     * @example
     * // Count the number of Otps
     * const count = await prisma.otp.count({
     *   where: {
     *     // ... the filter for the Otps we want to count
     *   }
     * })
    **/
    count<T extends otpCountArgs>(
      args?: Subset<T, otpCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], OtpCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Otp.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OtpAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends OtpAggregateArgs>(args: Subset<T, OtpAggregateArgs>): Prisma.PrismaPromise<GetOtpAggregateType<T>>

    /**
     * Group by Otp.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {otpGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends otpGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: otpGroupByArgs['orderBy'] }
        : { orderBy?: otpGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, otpGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetOtpGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the otp model
   */
  readonly fields: otpFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for otp.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__otpClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: 'PrismaPromise';

    user<T extends otp$userArgs<ExtArgs> = {}>(args?: Subset<T, otp$userArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$userPayload<ExtArgs>, T, 'findMany'> | Null>;

    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>;
  }



  /**
   * Fields of the otp model
   */ 
  interface otpFieldRefs {
    readonly otpID: FieldRef<"otp", 'String'>
    readonly otp: FieldRef<"otp", 'String'>
    readonly expiredAt: FieldRef<"otp", 'DateTime'>
    readonly createdAt: FieldRef<"otp", 'DateTime'>
  }
    

  // Custom InputTypes

  /**
   * otp findUnique
   */
  export type otpFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the otp
     */
    select?: otpSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: otpInclude<ExtArgs> | null
    /**
     * Filter, which otp to fetch.
     */
    where: otpWhereUniqueInput
  }


  /**
   * otp findUniqueOrThrow
   */
  export type otpFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the otp
     */
    select?: otpSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: otpInclude<ExtArgs> | null
    /**
     * Filter, which otp to fetch.
     */
    where: otpWhereUniqueInput
  }


  /**
   * otp findFirst
   */
  export type otpFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the otp
     */
    select?: otpSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: otpInclude<ExtArgs> | null
    /**
     * Filter, which otp to fetch.
     */
    where?: otpWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of otps to fetch.
     */
    orderBy?: otpOrderByWithRelationInput | otpOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for otps.
     */
    cursor?: otpWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` otps from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` otps.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of otps.
     */
    distinct?: OtpScalarFieldEnum | OtpScalarFieldEnum[]
  }


  /**
   * otp findFirstOrThrow
   */
  export type otpFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the otp
     */
    select?: otpSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: otpInclude<ExtArgs> | null
    /**
     * Filter, which otp to fetch.
     */
    where?: otpWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of otps to fetch.
     */
    orderBy?: otpOrderByWithRelationInput | otpOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for otps.
     */
    cursor?: otpWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` otps from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` otps.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of otps.
     */
    distinct?: OtpScalarFieldEnum | OtpScalarFieldEnum[]
  }


  /**
   * otp findMany
   */
  export type otpFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the otp
     */
    select?: otpSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: otpInclude<ExtArgs> | null
    /**
     * Filter, which otps to fetch.
     */
    where?: otpWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of otps to fetch.
     */
    orderBy?: otpOrderByWithRelationInput | otpOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing otps.
     */
    cursor?: otpWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` otps from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` otps.
     */
    skip?: number
    distinct?: OtpScalarFieldEnum | OtpScalarFieldEnum[]
  }


  /**
   * otp create
   */
  export type otpCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the otp
     */
    select?: otpSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: otpInclude<ExtArgs> | null
    /**
     * The data needed to create a otp.
     */
    data: XOR<otpCreateInput, otpUncheckedCreateInput>
  }


  /**
   * otp createMany
   */
  export type otpCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many otps.
     */
    data: otpCreateManyInput | otpCreateManyInput[]
    skipDuplicates?: boolean
  }


  /**
   * otp update
   */
  export type otpUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the otp
     */
    select?: otpSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: otpInclude<ExtArgs> | null
    /**
     * The data needed to update a otp.
     */
    data: XOR<otpUpdateInput, otpUncheckedUpdateInput>
    /**
     * Choose, which otp to update.
     */
    where: otpWhereUniqueInput
  }


  /**
   * otp updateMany
   */
  export type otpUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update otps.
     */
    data: XOR<otpUpdateManyMutationInput, otpUncheckedUpdateManyInput>
    /**
     * Filter which otps to update
     */
    where?: otpWhereInput
  }


  /**
   * otp upsert
   */
  export type otpUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the otp
     */
    select?: otpSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: otpInclude<ExtArgs> | null
    /**
     * The filter to search for the otp to update in case it exists.
     */
    where: otpWhereUniqueInput
    /**
     * In case the otp found by the `where` argument doesn't exist, create a new otp with this data.
     */
    create: XOR<otpCreateInput, otpUncheckedCreateInput>
    /**
     * In case the otp was found with the provided `where` argument, update it with this data.
     */
    update: XOR<otpUpdateInput, otpUncheckedUpdateInput>
  }


  /**
   * otp delete
   */
  export type otpDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the otp
     */
    select?: otpSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: otpInclude<ExtArgs> | null
    /**
     * Filter which otp to delete.
     */
    where: otpWhereUniqueInput
  }


  /**
   * otp deleteMany
   */
  export type otpDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which otps to delete
     */
    where?: otpWhereInput
  }


  /**
   * otp.user
   */
  export type otp$userArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the user
     */
    select?: userSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: userInclude<ExtArgs> | null
    where?: userWhereInput
    orderBy?: userOrderByWithRelationInput | userOrderByWithRelationInput[]
    cursor?: userWhereUniqueInput
    take?: number
    skip?: number
    distinct?: UserScalarFieldEnum | UserScalarFieldEnum[]
  }


  /**
   * otp without action
   */
  export type otpDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the otp
     */
    select?: otpSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: otpInclude<ExtArgs> | null
  }



  /**
   * Model appointment
   */

  export type AggregateAppointment = {
    _count: AppointmentCountAggregateOutputType | null
    _avg: AppointmentAvgAggregateOutputType | null
    _sum: AppointmentSumAggregateOutputType | null
    _min: AppointmentMinAggregateOutputType | null
    _max: AppointmentMaxAggregateOutputType | null
  }

  export type AppointmentAvgAggregateOutputType = {
    amount: number | null
  }

  export type AppointmentSumAggregateOutputType = {
    amount: number | null
  }

  export type AppointmentMinAggregateOutputType = {
    appointmentID: string | null
    date: Date | null
    time: string | null
    services: string | null
    platform: $Enums.platform | null
    link: string | null
    amount: number | null
    status: $Enums.status | null
    createdAt: Date | null
    updatedAt: Date | null
    feedbackID: string | null
  }

  export type AppointmentMaxAggregateOutputType = {
    appointmentID: string | null
    date: Date | null
    time: string | null
    services: string | null
    platform: $Enums.platform | null
    link: string | null
    amount: number | null
    status: $Enums.status | null
    createdAt: Date | null
    updatedAt: Date | null
    feedbackID: string | null
  }

  export type AppointmentCountAggregateOutputType = {
    appointmentID: number
    date: number
    time: number
    services: number
    platform: number
    link: number
    amount: number
    status: number
    createdAt: number
    updatedAt: number
    feedbackID: number
    _all: number
  }


  export type AppointmentAvgAggregateInputType = {
    amount?: true
  }

  export type AppointmentSumAggregateInputType = {
    amount?: true
  }

  export type AppointmentMinAggregateInputType = {
    appointmentID?: true
    date?: true
    time?: true
    services?: true
    platform?: true
    link?: true
    amount?: true
    status?: true
    createdAt?: true
    updatedAt?: true
    feedbackID?: true
  }

  export type AppointmentMaxAggregateInputType = {
    appointmentID?: true
    date?: true
    time?: true
    services?: true
    platform?: true
    link?: true
    amount?: true
    status?: true
    createdAt?: true
    updatedAt?: true
    feedbackID?: true
  }

  export type AppointmentCountAggregateInputType = {
    appointmentID?: true
    date?: true
    time?: true
    services?: true
    platform?: true
    link?: true
    amount?: true
    status?: true
    createdAt?: true
    updatedAt?: true
    feedbackID?: true
    _all?: true
  }

  export type AppointmentAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which appointment to aggregate.
     */
    where?: appointmentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of appointments to fetch.
     */
    orderBy?: appointmentOrderByWithRelationInput | appointmentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: appointmentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` appointments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` appointments.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned appointments
    **/
    _count?: true | AppointmentCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: AppointmentAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: AppointmentSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: AppointmentMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: AppointmentMaxAggregateInputType
  }

  export type GetAppointmentAggregateType<T extends AppointmentAggregateArgs> = {
        [P in keyof T & keyof AggregateAppointment]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateAppointment[P]>
      : GetScalarType<T[P], AggregateAppointment[P]>
  }




  export type appointmentGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: appointmentWhereInput
    orderBy?: appointmentOrderByWithAggregationInput | appointmentOrderByWithAggregationInput[]
    by: AppointmentScalarFieldEnum[] | AppointmentScalarFieldEnum
    having?: appointmentScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: AppointmentCountAggregateInputType | true
    _avg?: AppointmentAvgAggregateInputType
    _sum?: AppointmentSumAggregateInputType
    _min?: AppointmentMinAggregateInputType
    _max?: AppointmentMaxAggregateInputType
  }

  export type AppointmentGroupByOutputType = {
    appointmentID: string
    date: Date
    time: string
    services: string | null
    platform: $Enums.platform
    link: string | null
    amount: number
    status: $Enums.status
    createdAt: Date
    updatedAt: Date
    feedbackID: string | null
    _count: AppointmentCountAggregateOutputType | null
    _avg: AppointmentAvgAggregateOutputType | null
    _sum: AppointmentSumAggregateOutputType | null
    _min: AppointmentMinAggregateOutputType | null
    _max: AppointmentMaxAggregateOutputType | null
  }

  type GetAppointmentGroupByPayload<T extends appointmentGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<AppointmentGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof AppointmentGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], AppointmentGroupByOutputType[P]>
            : GetScalarType<T[P], AppointmentGroupByOutputType[P]>
        }
      >
    >


  export type appointmentSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    appointmentID?: boolean
    date?: boolean
    time?: boolean
    services?: boolean
    platform?: boolean
    link?: boolean
    amount?: boolean
    status?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    feedbackID?: boolean
    user?: boolean | appointment$userArgs<ExtArgs>
    feedback?: boolean | appointment$feedbackArgs<ExtArgs>
    service?: boolean | appointment$serviceArgs<ExtArgs>
    _count?: boolean | AppointmentCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["appointment"]>

  export type appointmentSelectScalar = {
    appointmentID?: boolean
    date?: boolean
    time?: boolean
    services?: boolean
    platform?: boolean
    link?: boolean
    amount?: boolean
    status?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    feedbackID?: boolean
  }

  export type appointmentInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | appointment$userArgs<ExtArgs>
    feedback?: boolean | appointment$feedbackArgs<ExtArgs>
    service?: boolean | appointment$serviceArgs<ExtArgs>
    _count?: boolean | AppointmentCountOutputTypeDefaultArgs<ExtArgs>
  }


  export type $appointmentPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "appointment"
    objects: {
      user: Prisma.$userPayload<ExtArgs>[]
      feedback: Prisma.$feedbackPayload<ExtArgs> | null
      service: Prisma.$servicesPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      appointmentID: string
      date: Date
      time: string
      services: string | null
      platform: $Enums.platform
      link: string | null
      amount: number
      status: $Enums.status
      createdAt: Date
      updatedAt: Date
      feedbackID: string | null
    }, ExtArgs["result"]["appointment"]>
    composites: {}
  }


  type appointmentGetPayload<S extends boolean | null | undefined | appointmentDefaultArgs> = $Result.GetResult<Prisma.$appointmentPayload, S>

  type appointmentCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<appointmentFindManyArgs, 'select' | 'include' | 'distinct' > & {
      select?: AppointmentCountAggregateInputType | true
    }

  export interface appointmentDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['appointment'], meta: { name: 'appointment' } }
    /**
     * Find zero or one Appointment that matches the filter.
     * @param {appointmentFindUniqueArgs} args - Arguments to find a Appointment
     * @example
     * // Get one Appointment
     * const appointment = await prisma.appointment.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends appointmentFindUniqueArgs<ExtArgs>>(
      args: SelectSubset<T, appointmentFindUniqueArgs<ExtArgs>>
    ): Prisma__appointmentClient<$Result.GetResult<Prisma.$appointmentPayload<ExtArgs>, T, 'findUnique'> | null, null, ExtArgs>

    /**
     * Find one Appointment that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {appointmentFindUniqueOrThrowArgs} args - Arguments to find a Appointment
     * @example
     * // Get one Appointment
     * const appointment = await prisma.appointment.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends appointmentFindUniqueOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, appointmentFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__appointmentClient<$Result.GetResult<Prisma.$appointmentPayload<ExtArgs>, T, 'findUniqueOrThrow'>, never, ExtArgs>

    /**
     * Find the first Appointment that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {appointmentFindFirstArgs} args - Arguments to find a Appointment
     * @example
     * // Get one Appointment
     * const appointment = await prisma.appointment.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends appointmentFindFirstArgs<ExtArgs>>(
      args?: SelectSubset<T, appointmentFindFirstArgs<ExtArgs>>
    ): Prisma__appointmentClient<$Result.GetResult<Prisma.$appointmentPayload<ExtArgs>, T, 'findFirst'> | null, null, ExtArgs>

    /**
     * Find the first Appointment that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {appointmentFindFirstOrThrowArgs} args - Arguments to find a Appointment
     * @example
     * // Get one Appointment
     * const appointment = await prisma.appointment.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends appointmentFindFirstOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, appointmentFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__appointmentClient<$Result.GetResult<Prisma.$appointmentPayload<ExtArgs>, T, 'findFirstOrThrow'>, never, ExtArgs>

    /**
     * Find zero or more Appointments that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {appointmentFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Appointments
     * const appointments = await prisma.appointment.findMany()
     * 
     * // Get first 10 Appointments
     * const appointments = await prisma.appointment.findMany({ take: 10 })
     * 
     * // Only select the `appointmentID`
     * const appointmentWithAppointmentIDOnly = await prisma.appointment.findMany({ select: { appointmentID: true } })
     * 
    **/
    findMany<T extends appointmentFindManyArgs<ExtArgs>>(
      args?: SelectSubset<T, appointmentFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<$Result.GetResult<Prisma.$appointmentPayload<ExtArgs>, T, 'findMany'>>

    /**
     * Create a Appointment.
     * @param {appointmentCreateArgs} args - Arguments to create a Appointment.
     * @example
     * // Create one Appointment
     * const Appointment = await prisma.appointment.create({
     *   data: {
     *     // ... data to create a Appointment
     *   }
     * })
     * 
    **/
    create<T extends appointmentCreateArgs<ExtArgs>>(
      args: SelectSubset<T, appointmentCreateArgs<ExtArgs>>
    ): Prisma__appointmentClient<$Result.GetResult<Prisma.$appointmentPayload<ExtArgs>, T, 'create'>, never, ExtArgs>

    /**
     * Create many Appointments.
     *     @param {appointmentCreateManyArgs} args - Arguments to create many Appointments.
     *     @example
     *     // Create many Appointments
     *     const appointment = await prisma.appointment.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends appointmentCreateManyArgs<ExtArgs>>(
      args?: SelectSubset<T, appointmentCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Appointment.
     * @param {appointmentDeleteArgs} args - Arguments to delete one Appointment.
     * @example
     * // Delete one Appointment
     * const Appointment = await prisma.appointment.delete({
     *   where: {
     *     // ... filter to delete one Appointment
     *   }
     * })
     * 
    **/
    delete<T extends appointmentDeleteArgs<ExtArgs>>(
      args: SelectSubset<T, appointmentDeleteArgs<ExtArgs>>
    ): Prisma__appointmentClient<$Result.GetResult<Prisma.$appointmentPayload<ExtArgs>, T, 'delete'>, never, ExtArgs>

    /**
     * Update one Appointment.
     * @param {appointmentUpdateArgs} args - Arguments to update one Appointment.
     * @example
     * // Update one Appointment
     * const appointment = await prisma.appointment.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends appointmentUpdateArgs<ExtArgs>>(
      args: SelectSubset<T, appointmentUpdateArgs<ExtArgs>>
    ): Prisma__appointmentClient<$Result.GetResult<Prisma.$appointmentPayload<ExtArgs>, T, 'update'>, never, ExtArgs>

    /**
     * Delete zero or more Appointments.
     * @param {appointmentDeleteManyArgs} args - Arguments to filter Appointments to delete.
     * @example
     * // Delete a few Appointments
     * const { count } = await prisma.appointment.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends appointmentDeleteManyArgs<ExtArgs>>(
      args?: SelectSubset<T, appointmentDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Appointments.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {appointmentUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Appointments
     * const appointment = await prisma.appointment.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends appointmentUpdateManyArgs<ExtArgs>>(
      args: SelectSubset<T, appointmentUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Appointment.
     * @param {appointmentUpsertArgs} args - Arguments to update or create a Appointment.
     * @example
     * // Update or create a Appointment
     * const appointment = await prisma.appointment.upsert({
     *   create: {
     *     // ... data to create a Appointment
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Appointment we want to update
     *   }
     * })
    **/
    upsert<T extends appointmentUpsertArgs<ExtArgs>>(
      args: SelectSubset<T, appointmentUpsertArgs<ExtArgs>>
    ): Prisma__appointmentClient<$Result.GetResult<Prisma.$appointmentPayload<ExtArgs>, T, 'upsert'>, never, ExtArgs>

    /**
     * Count the number of Appointments.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {appointmentCountArgs} args - Arguments to filter Appointments to count.
     * @example
     * // Count the number of Appointments
     * const count = await prisma.appointment.count({
     *   where: {
     *     // ... the filter for the Appointments we want to count
     *   }
     * })
    **/
    count<T extends appointmentCountArgs>(
      args?: Subset<T, appointmentCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], AppointmentCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Appointment.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AppointmentAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends AppointmentAggregateArgs>(args: Subset<T, AppointmentAggregateArgs>): Prisma.PrismaPromise<GetAppointmentAggregateType<T>>

    /**
     * Group by Appointment.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {appointmentGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends appointmentGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: appointmentGroupByArgs['orderBy'] }
        : { orderBy?: appointmentGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, appointmentGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetAppointmentGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the appointment model
   */
  readonly fields: appointmentFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for appointment.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__appointmentClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: 'PrismaPromise';

    user<T extends appointment$userArgs<ExtArgs> = {}>(args?: Subset<T, appointment$userArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$userPayload<ExtArgs>, T, 'findMany'> | Null>;

    feedback<T extends appointment$feedbackArgs<ExtArgs> = {}>(args?: Subset<T, appointment$feedbackArgs<ExtArgs>>): Prisma__feedbackClient<$Result.GetResult<Prisma.$feedbackPayload<ExtArgs>, T, 'findUniqueOrThrow'> | null, null, ExtArgs>;

    service<T extends appointment$serviceArgs<ExtArgs> = {}>(args?: Subset<T, appointment$serviceArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$servicesPayload<ExtArgs>, T, 'findMany'> | Null>;

    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>;
  }



  /**
   * Fields of the appointment model
   */ 
  interface appointmentFieldRefs {
    readonly appointmentID: FieldRef<"appointment", 'String'>
    readonly date: FieldRef<"appointment", 'DateTime'>
    readonly time: FieldRef<"appointment", 'String'>
    readonly services: FieldRef<"appointment", 'String'>
    readonly platform: FieldRef<"appointment", 'platform'>
    readonly link: FieldRef<"appointment", 'String'>
    readonly amount: FieldRef<"appointment", 'Int'>
    readonly status: FieldRef<"appointment", 'status'>
    readonly createdAt: FieldRef<"appointment", 'DateTime'>
    readonly updatedAt: FieldRef<"appointment", 'DateTime'>
    readonly feedbackID: FieldRef<"appointment", 'String'>
  }
    

  // Custom InputTypes

  /**
   * appointment findUnique
   */
  export type appointmentFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the appointment
     */
    select?: appointmentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: appointmentInclude<ExtArgs> | null
    /**
     * Filter, which appointment to fetch.
     */
    where: appointmentWhereUniqueInput
  }


  /**
   * appointment findUniqueOrThrow
   */
  export type appointmentFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the appointment
     */
    select?: appointmentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: appointmentInclude<ExtArgs> | null
    /**
     * Filter, which appointment to fetch.
     */
    where: appointmentWhereUniqueInput
  }


  /**
   * appointment findFirst
   */
  export type appointmentFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the appointment
     */
    select?: appointmentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: appointmentInclude<ExtArgs> | null
    /**
     * Filter, which appointment to fetch.
     */
    where?: appointmentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of appointments to fetch.
     */
    orderBy?: appointmentOrderByWithRelationInput | appointmentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for appointments.
     */
    cursor?: appointmentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` appointments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` appointments.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of appointments.
     */
    distinct?: AppointmentScalarFieldEnum | AppointmentScalarFieldEnum[]
  }


  /**
   * appointment findFirstOrThrow
   */
  export type appointmentFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the appointment
     */
    select?: appointmentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: appointmentInclude<ExtArgs> | null
    /**
     * Filter, which appointment to fetch.
     */
    where?: appointmentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of appointments to fetch.
     */
    orderBy?: appointmentOrderByWithRelationInput | appointmentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for appointments.
     */
    cursor?: appointmentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` appointments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` appointments.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of appointments.
     */
    distinct?: AppointmentScalarFieldEnum | AppointmentScalarFieldEnum[]
  }


  /**
   * appointment findMany
   */
  export type appointmentFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the appointment
     */
    select?: appointmentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: appointmentInclude<ExtArgs> | null
    /**
     * Filter, which appointments to fetch.
     */
    where?: appointmentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of appointments to fetch.
     */
    orderBy?: appointmentOrderByWithRelationInput | appointmentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing appointments.
     */
    cursor?: appointmentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` appointments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` appointments.
     */
    skip?: number
    distinct?: AppointmentScalarFieldEnum | AppointmentScalarFieldEnum[]
  }


  /**
   * appointment create
   */
  export type appointmentCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the appointment
     */
    select?: appointmentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: appointmentInclude<ExtArgs> | null
    /**
     * The data needed to create a appointment.
     */
    data: XOR<appointmentCreateInput, appointmentUncheckedCreateInput>
  }


  /**
   * appointment createMany
   */
  export type appointmentCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many appointments.
     */
    data: appointmentCreateManyInput | appointmentCreateManyInput[]
    skipDuplicates?: boolean
  }


  /**
   * appointment update
   */
  export type appointmentUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the appointment
     */
    select?: appointmentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: appointmentInclude<ExtArgs> | null
    /**
     * The data needed to update a appointment.
     */
    data: XOR<appointmentUpdateInput, appointmentUncheckedUpdateInput>
    /**
     * Choose, which appointment to update.
     */
    where: appointmentWhereUniqueInput
  }


  /**
   * appointment updateMany
   */
  export type appointmentUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update appointments.
     */
    data: XOR<appointmentUpdateManyMutationInput, appointmentUncheckedUpdateManyInput>
    /**
     * Filter which appointments to update
     */
    where?: appointmentWhereInput
  }


  /**
   * appointment upsert
   */
  export type appointmentUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the appointment
     */
    select?: appointmentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: appointmentInclude<ExtArgs> | null
    /**
     * The filter to search for the appointment to update in case it exists.
     */
    where: appointmentWhereUniqueInput
    /**
     * In case the appointment found by the `where` argument doesn't exist, create a new appointment with this data.
     */
    create: XOR<appointmentCreateInput, appointmentUncheckedCreateInput>
    /**
     * In case the appointment was found with the provided `where` argument, update it with this data.
     */
    update: XOR<appointmentUpdateInput, appointmentUncheckedUpdateInput>
  }


  /**
   * appointment delete
   */
  export type appointmentDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the appointment
     */
    select?: appointmentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: appointmentInclude<ExtArgs> | null
    /**
     * Filter which appointment to delete.
     */
    where: appointmentWhereUniqueInput
  }


  /**
   * appointment deleteMany
   */
  export type appointmentDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which appointments to delete
     */
    where?: appointmentWhereInput
  }


  /**
   * appointment.user
   */
  export type appointment$userArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the user
     */
    select?: userSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: userInclude<ExtArgs> | null
    where?: userWhereInput
    orderBy?: userOrderByWithRelationInput | userOrderByWithRelationInput[]
    cursor?: userWhereUniqueInput
    take?: number
    skip?: number
    distinct?: UserScalarFieldEnum | UserScalarFieldEnum[]
  }


  /**
   * appointment.feedback
   */
  export type appointment$feedbackArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the feedback
     */
    select?: feedbackSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: feedbackInclude<ExtArgs> | null
    where?: feedbackWhereInput
  }


  /**
   * appointment.service
   */
  export type appointment$serviceArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the services
     */
    select?: servicesSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: servicesInclude<ExtArgs> | null
    where?: servicesWhereInput
    orderBy?: servicesOrderByWithRelationInput | servicesOrderByWithRelationInput[]
    cursor?: servicesWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ServicesScalarFieldEnum | ServicesScalarFieldEnum[]
  }


  /**
   * appointment without action
   */
  export type appointmentDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the appointment
     */
    select?: appointmentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: appointmentInclude<ExtArgs> | null
  }



  /**
   * Model equipment
   */

  export type AggregateEquipment = {
    _count: EquipmentCountAggregateOutputType | null
    _avg: EquipmentAvgAggregateOutputType | null
    _sum: EquipmentSumAggregateOutputType | null
    _min: EquipmentMinAggregateOutputType | null
    _max: EquipmentMaxAggregateOutputType | null
  }

  export type EquipmentAvgAggregateOutputType = {
    quantity: number | null
  }

  export type EquipmentSumAggregateOutputType = {
    quantity: number | null
  }

  export type EquipmentMinAggregateOutputType = {
    equipmentID: string | null
    name: string | null
    inventory: $Enums.inventory | null
    description: string | null
    quantity: number | null
    expireDate: Date | null
    creatdAt: Date | null
    updateAt: Date | null
  }

  export type EquipmentMaxAggregateOutputType = {
    equipmentID: string | null
    name: string | null
    inventory: $Enums.inventory | null
    description: string | null
    quantity: number | null
    expireDate: Date | null
    creatdAt: Date | null
    updateAt: Date | null
  }

  export type EquipmentCountAggregateOutputType = {
    equipmentID: number
    name: number
    inventory: number
    description: number
    quantity: number
    expireDate: number
    creatdAt: number
    updateAt: number
    _all: number
  }


  export type EquipmentAvgAggregateInputType = {
    quantity?: true
  }

  export type EquipmentSumAggregateInputType = {
    quantity?: true
  }

  export type EquipmentMinAggregateInputType = {
    equipmentID?: true
    name?: true
    inventory?: true
    description?: true
    quantity?: true
    expireDate?: true
    creatdAt?: true
    updateAt?: true
  }

  export type EquipmentMaxAggregateInputType = {
    equipmentID?: true
    name?: true
    inventory?: true
    description?: true
    quantity?: true
    expireDate?: true
    creatdAt?: true
    updateAt?: true
  }

  export type EquipmentCountAggregateInputType = {
    equipmentID?: true
    name?: true
    inventory?: true
    description?: true
    quantity?: true
    expireDate?: true
    creatdAt?: true
    updateAt?: true
    _all?: true
  }

  export type EquipmentAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which equipment to aggregate.
     */
    where?: equipmentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of equipment to fetch.
     */
    orderBy?: equipmentOrderByWithRelationInput | equipmentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: equipmentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` equipment from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` equipment.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned equipment
    **/
    _count?: true | EquipmentCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: EquipmentAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: EquipmentSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: EquipmentMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: EquipmentMaxAggregateInputType
  }

  export type GetEquipmentAggregateType<T extends EquipmentAggregateArgs> = {
        [P in keyof T & keyof AggregateEquipment]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateEquipment[P]>
      : GetScalarType<T[P], AggregateEquipment[P]>
  }




  export type equipmentGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: equipmentWhereInput
    orderBy?: equipmentOrderByWithAggregationInput | equipmentOrderByWithAggregationInput[]
    by: EquipmentScalarFieldEnum[] | EquipmentScalarFieldEnum
    having?: equipmentScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: EquipmentCountAggregateInputType | true
    _avg?: EquipmentAvgAggregateInputType
    _sum?: EquipmentSumAggregateInputType
    _min?: EquipmentMinAggregateInputType
    _max?: EquipmentMaxAggregateInputType
  }

  export type EquipmentGroupByOutputType = {
    equipmentID: string
    name: string
    inventory: $Enums.inventory
    description: string
    quantity: number
    expireDate: Date
    creatdAt: Date
    updateAt: Date
    _count: EquipmentCountAggregateOutputType | null
    _avg: EquipmentAvgAggregateOutputType | null
    _sum: EquipmentSumAggregateOutputType | null
    _min: EquipmentMinAggregateOutputType | null
    _max: EquipmentMaxAggregateOutputType | null
  }

  type GetEquipmentGroupByPayload<T extends equipmentGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<EquipmentGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof EquipmentGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], EquipmentGroupByOutputType[P]>
            : GetScalarType<T[P], EquipmentGroupByOutputType[P]>
        }
      >
    >


  export type equipmentSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    equipmentID?: boolean
    name?: boolean
    inventory?: boolean
    description?: boolean
    quantity?: boolean
    expireDate?: boolean
    creatdAt?: boolean
    updateAt?: boolean
    user?: boolean | equipment$userArgs<ExtArgs>
    _count?: boolean | EquipmentCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["equipment"]>

  export type equipmentSelectScalar = {
    equipmentID?: boolean
    name?: boolean
    inventory?: boolean
    description?: boolean
    quantity?: boolean
    expireDate?: boolean
    creatdAt?: boolean
    updateAt?: boolean
  }

  export type equipmentInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | equipment$userArgs<ExtArgs>
    _count?: boolean | EquipmentCountOutputTypeDefaultArgs<ExtArgs>
  }


  export type $equipmentPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "equipment"
    objects: {
      user: Prisma.$userPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      equipmentID: string
      name: string
      inventory: $Enums.inventory
      description: string
      quantity: number
      expireDate: Date
      creatdAt: Date
      updateAt: Date
    }, ExtArgs["result"]["equipment"]>
    composites: {}
  }


  type equipmentGetPayload<S extends boolean | null | undefined | equipmentDefaultArgs> = $Result.GetResult<Prisma.$equipmentPayload, S>

  type equipmentCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<equipmentFindManyArgs, 'select' | 'include' | 'distinct' > & {
      select?: EquipmentCountAggregateInputType | true
    }

  export interface equipmentDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['equipment'], meta: { name: 'equipment' } }
    /**
     * Find zero or one Equipment that matches the filter.
     * @param {equipmentFindUniqueArgs} args - Arguments to find a Equipment
     * @example
     * // Get one Equipment
     * const equipment = await prisma.equipment.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends equipmentFindUniqueArgs<ExtArgs>>(
      args: SelectSubset<T, equipmentFindUniqueArgs<ExtArgs>>
    ): Prisma__equipmentClient<$Result.GetResult<Prisma.$equipmentPayload<ExtArgs>, T, 'findUnique'> | null, null, ExtArgs>

    /**
     * Find one Equipment that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {equipmentFindUniqueOrThrowArgs} args - Arguments to find a Equipment
     * @example
     * // Get one Equipment
     * const equipment = await prisma.equipment.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends equipmentFindUniqueOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, equipmentFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__equipmentClient<$Result.GetResult<Prisma.$equipmentPayload<ExtArgs>, T, 'findUniqueOrThrow'>, never, ExtArgs>

    /**
     * Find the first Equipment that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {equipmentFindFirstArgs} args - Arguments to find a Equipment
     * @example
     * // Get one Equipment
     * const equipment = await prisma.equipment.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends equipmentFindFirstArgs<ExtArgs>>(
      args?: SelectSubset<T, equipmentFindFirstArgs<ExtArgs>>
    ): Prisma__equipmentClient<$Result.GetResult<Prisma.$equipmentPayload<ExtArgs>, T, 'findFirst'> | null, null, ExtArgs>

    /**
     * Find the first Equipment that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {equipmentFindFirstOrThrowArgs} args - Arguments to find a Equipment
     * @example
     * // Get one Equipment
     * const equipment = await prisma.equipment.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends equipmentFindFirstOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, equipmentFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__equipmentClient<$Result.GetResult<Prisma.$equipmentPayload<ExtArgs>, T, 'findFirstOrThrow'>, never, ExtArgs>

    /**
     * Find zero or more Equipment that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {equipmentFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Equipment
     * const equipment = await prisma.equipment.findMany()
     * 
     * // Get first 10 Equipment
     * const equipment = await prisma.equipment.findMany({ take: 10 })
     * 
     * // Only select the `equipmentID`
     * const equipmentWithEquipmentIDOnly = await prisma.equipment.findMany({ select: { equipmentID: true } })
     * 
    **/
    findMany<T extends equipmentFindManyArgs<ExtArgs>>(
      args?: SelectSubset<T, equipmentFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<$Result.GetResult<Prisma.$equipmentPayload<ExtArgs>, T, 'findMany'>>

    /**
     * Create a Equipment.
     * @param {equipmentCreateArgs} args - Arguments to create a Equipment.
     * @example
     * // Create one Equipment
     * const Equipment = await prisma.equipment.create({
     *   data: {
     *     // ... data to create a Equipment
     *   }
     * })
     * 
    **/
    create<T extends equipmentCreateArgs<ExtArgs>>(
      args: SelectSubset<T, equipmentCreateArgs<ExtArgs>>
    ): Prisma__equipmentClient<$Result.GetResult<Prisma.$equipmentPayload<ExtArgs>, T, 'create'>, never, ExtArgs>

    /**
     * Create many Equipment.
     *     @param {equipmentCreateManyArgs} args - Arguments to create many Equipment.
     *     @example
     *     // Create many Equipment
     *     const equipment = await prisma.equipment.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends equipmentCreateManyArgs<ExtArgs>>(
      args?: SelectSubset<T, equipmentCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Equipment.
     * @param {equipmentDeleteArgs} args - Arguments to delete one Equipment.
     * @example
     * // Delete one Equipment
     * const Equipment = await prisma.equipment.delete({
     *   where: {
     *     // ... filter to delete one Equipment
     *   }
     * })
     * 
    **/
    delete<T extends equipmentDeleteArgs<ExtArgs>>(
      args: SelectSubset<T, equipmentDeleteArgs<ExtArgs>>
    ): Prisma__equipmentClient<$Result.GetResult<Prisma.$equipmentPayload<ExtArgs>, T, 'delete'>, never, ExtArgs>

    /**
     * Update one Equipment.
     * @param {equipmentUpdateArgs} args - Arguments to update one Equipment.
     * @example
     * // Update one Equipment
     * const equipment = await prisma.equipment.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends equipmentUpdateArgs<ExtArgs>>(
      args: SelectSubset<T, equipmentUpdateArgs<ExtArgs>>
    ): Prisma__equipmentClient<$Result.GetResult<Prisma.$equipmentPayload<ExtArgs>, T, 'update'>, never, ExtArgs>

    /**
     * Delete zero or more Equipment.
     * @param {equipmentDeleteManyArgs} args - Arguments to filter Equipment to delete.
     * @example
     * // Delete a few Equipment
     * const { count } = await prisma.equipment.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends equipmentDeleteManyArgs<ExtArgs>>(
      args?: SelectSubset<T, equipmentDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Equipment.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {equipmentUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Equipment
     * const equipment = await prisma.equipment.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends equipmentUpdateManyArgs<ExtArgs>>(
      args: SelectSubset<T, equipmentUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Equipment.
     * @param {equipmentUpsertArgs} args - Arguments to update or create a Equipment.
     * @example
     * // Update or create a Equipment
     * const equipment = await prisma.equipment.upsert({
     *   create: {
     *     // ... data to create a Equipment
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Equipment we want to update
     *   }
     * })
    **/
    upsert<T extends equipmentUpsertArgs<ExtArgs>>(
      args: SelectSubset<T, equipmentUpsertArgs<ExtArgs>>
    ): Prisma__equipmentClient<$Result.GetResult<Prisma.$equipmentPayload<ExtArgs>, T, 'upsert'>, never, ExtArgs>

    /**
     * Count the number of Equipment.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {equipmentCountArgs} args - Arguments to filter Equipment to count.
     * @example
     * // Count the number of Equipment
     * const count = await prisma.equipment.count({
     *   where: {
     *     // ... the filter for the Equipment we want to count
     *   }
     * })
    **/
    count<T extends equipmentCountArgs>(
      args?: Subset<T, equipmentCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], EquipmentCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Equipment.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EquipmentAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends EquipmentAggregateArgs>(args: Subset<T, EquipmentAggregateArgs>): Prisma.PrismaPromise<GetEquipmentAggregateType<T>>

    /**
     * Group by Equipment.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {equipmentGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends equipmentGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: equipmentGroupByArgs['orderBy'] }
        : { orderBy?: equipmentGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, equipmentGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetEquipmentGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the equipment model
   */
  readonly fields: equipmentFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for equipment.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__equipmentClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: 'PrismaPromise';

    user<T extends equipment$userArgs<ExtArgs> = {}>(args?: Subset<T, equipment$userArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$userPayload<ExtArgs>, T, 'findMany'> | Null>;

    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>;
  }



  /**
   * Fields of the equipment model
   */ 
  interface equipmentFieldRefs {
    readonly equipmentID: FieldRef<"equipment", 'String'>
    readonly name: FieldRef<"equipment", 'String'>
    readonly inventory: FieldRef<"equipment", 'inventory'>
    readonly description: FieldRef<"equipment", 'String'>
    readonly quantity: FieldRef<"equipment", 'Int'>
    readonly expireDate: FieldRef<"equipment", 'DateTime'>
    readonly creatdAt: FieldRef<"equipment", 'DateTime'>
    readonly updateAt: FieldRef<"equipment", 'DateTime'>
  }
    

  // Custom InputTypes

  /**
   * equipment findUnique
   */
  export type equipmentFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the equipment
     */
    select?: equipmentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: equipmentInclude<ExtArgs> | null
    /**
     * Filter, which equipment to fetch.
     */
    where: equipmentWhereUniqueInput
  }


  /**
   * equipment findUniqueOrThrow
   */
  export type equipmentFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the equipment
     */
    select?: equipmentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: equipmentInclude<ExtArgs> | null
    /**
     * Filter, which equipment to fetch.
     */
    where: equipmentWhereUniqueInput
  }


  /**
   * equipment findFirst
   */
  export type equipmentFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the equipment
     */
    select?: equipmentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: equipmentInclude<ExtArgs> | null
    /**
     * Filter, which equipment to fetch.
     */
    where?: equipmentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of equipment to fetch.
     */
    orderBy?: equipmentOrderByWithRelationInput | equipmentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for equipment.
     */
    cursor?: equipmentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` equipment from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` equipment.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of equipment.
     */
    distinct?: EquipmentScalarFieldEnum | EquipmentScalarFieldEnum[]
  }


  /**
   * equipment findFirstOrThrow
   */
  export type equipmentFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the equipment
     */
    select?: equipmentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: equipmentInclude<ExtArgs> | null
    /**
     * Filter, which equipment to fetch.
     */
    where?: equipmentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of equipment to fetch.
     */
    orderBy?: equipmentOrderByWithRelationInput | equipmentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for equipment.
     */
    cursor?: equipmentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` equipment from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` equipment.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of equipment.
     */
    distinct?: EquipmentScalarFieldEnum | EquipmentScalarFieldEnum[]
  }


  /**
   * equipment findMany
   */
  export type equipmentFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the equipment
     */
    select?: equipmentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: equipmentInclude<ExtArgs> | null
    /**
     * Filter, which equipment to fetch.
     */
    where?: equipmentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of equipment to fetch.
     */
    orderBy?: equipmentOrderByWithRelationInput | equipmentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing equipment.
     */
    cursor?: equipmentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` equipment from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` equipment.
     */
    skip?: number
    distinct?: EquipmentScalarFieldEnum | EquipmentScalarFieldEnum[]
  }


  /**
   * equipment create
   */
  export type equipmentCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the equipment
     */
    select?: equipmentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: equipmentInclude<ExtArgs> | null
    /**
     * The data needed to create a equipment.
     */
    data: XOR<equipmentCreateInput, equipmentUncheckedCreateInput>
  }


  /**
   * equipment createMany
   */
  export type equipmentCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many equipment.
     */
    data: equipmentCreateManyInput | equipmentCreateManyInput[]
    skipDuplicates?: boolean
  }


  /**
   * equipment update
   */
  export type equipmentUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the equipment
     */
    select?: equipmentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: equipmentInclude<ExtArgs> | null
    /**
     * The data needed to update a equipment.
     */
    data: XOR<equipmentUpdateInput, equipmentUncheckedUpdateInput>
    /**
     * Choose, which equipment to update.
     */
    where: equipmentWhereUniqueInput
  }


  /**
   * equipment updateMany
   */
  export type equipmentUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update equipment.
     */
    data: XOR<equipmentUpdateManyMutationInput, equipmentUncheckedUpdateManyInput>
    /**
     * Filter which equipment to update
     */
    where?: equipmentWhereInput
  }


  /**
   * equipment upsert
   */
  export type equipmentUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the equipment
     */
    select?: equipmentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: equipmentInclude<ExtArgs> | null
    /**
     * The filter to search for the equipment to update in case it exists.
     */
    where: equipmentWhereUniqueInput
    /**
     * In case the equipment found by the `where` argument doesn't exist, create a new equipment with this data.
     */
    create: XOR<equipmentCreateInput, equipmentUncheckedCreateInput>
    /**
     * In case the equipment was found with the provided `where` argument, update it with this data.
     */
    update: XOR<equipmentUpdateInput, equipmentUncheckedUpdateInput>
  }


  /**
   * equipment delete
   */
  export type equipmentDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the equipment
     */
    select?: equipmentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: equipmentInclude<ExtArgs> | null
    /**
     * Filter which equipment to delete.
     */
    where: equipmentWhereUniqueInput
  }


  /**
   * equipment deleteMany
   */
  export type equipmentDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which equipment to delete
     */
    where?: equipmentWhereInput
  }


  /**
   * equipment.user
   */
  export type equipment$userArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the user
     */
    select?: userSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: userInclude<ExtArgs> | null
    where?: userWhereInput
    orderBy?: userOrderByWithRelationInput | userOrderByWithRelationInput[]
    cursor?: userWhereUniqueInput
    take?: number
    skip?: number
    distinct?: UserScalarFieldEnum | UserScalarFieldEnum[]
  }


  /**
   * equipment without action
   */
  export type equipmentDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the equipment
     */
    select?: equipmentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: equipmentInclude<ExtArgs> | null
  }



  /**
   * Model blogs
   */

  export type AggregateBlogs = {
    _count: BlogsCountAggregateOutputType | null
    _min: BlogsMinAggregateOutputType | null
    _max: BlogsMaxAggregateOutputType | null
  }

  export type BlogsMinAggregateOutputType = {
    blogsID: string | null
    title: string | null
    content: string | null
    expertise: string | null
    image: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type BlogsMaxAggregateOutputType = {
    blogsID: string | null
    title: string | null
    content: string | null
    expertise: string | null
    image: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type BlogsCountAggregateOutputType = {
    blogsID: number
    title: number
    content: number
    expertise: number
    image: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type BlogsMinAggregateInputType = {
    blogsID?: true
    title?: true
    content?: true
    expertise?: true
    image?: true
    createdAt?: true
    updatedAt?: true
  }

  export type BlogsMaxAggregateInputType = {
    blogsID?: true
    title?: true
    content?: true
    expertise?: true
    image?: true
    createdAt?: true
    updatedAt?: true
  }

  export type BlogsCountAggregateInputType = {
    blogsID?: true
    title?: true
    content?: true
    expertise?: true
    image?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type BlogsAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which blogs to aggregate.
     */
    where?: blogsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of blogs to fetch.
     */
    orderBy?: blogsOrderByWithRelationInput | blogsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: blogsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` blogs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` blogs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned blogs
    **/
    _count?: true | BlogsCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: BlogsMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: BlogsMaxAggregateInputType
  }

  export type GetBlogsAggregateType<T extends BlogsAggregateArgs> = {
        [P in keyof T & keyof AggregateBlogs]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateBlogs[P]>
      : GetScalarType<T[P], AggregateBlogs[P]>
  }




  export type blogsGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: blogsWhereInput
    orderBy?: blogsOrderByWithAggregationInput | blogsOrderByWithAggregationInput[]
    by: BlogsScalarFieldEnum[] | BlogsScalarFieldEnum
    having?: blogsScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: BlogsCountAggregateInputType | true
    _min?: BlogsMinAggregateInputType
    _max?: BlogsMaxAggregateInputType
  }

  export type BlogsGroupByOutputType = {
    blogsID: string
    title: string
    content: string
    expertise: string
    image: string
    createdAt: Date
    updatedAt: Date
    _count: BlogsCountAggregateOutputType | null
    _min: BlogsMinAggregateOutputType | null
    _max: BlogsMaxAggregateOutputType | null
  }

  type GetBlogsGroupByPayload<T extends blogsGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<BlogsGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof BlogsGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], BlogsGroupByOutputType[P]>
            : GetScalarType<T[P], BlogsGroupByOutputType[P]>
        }
      >
    >


  export type blogsSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    blogsID?: boolean
    title?: boolean
    content?: boolean
    expertise?: boolean
    image?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    user?: boolean | blogs$userArgs<ExtArgs>
    _count?: boolean | BlogsCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["blogs"]>

  export type blogsSelectScalar = {
    blogsID?: boolean
    title?: boolean
    content?: boolean
    expertise?: boolean
    image?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type blogsInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | blogs$userArgs<ExtArgs>
    _count?: boolean | BlogsCountOutputTypeDefaultArgs<ExtArgs>
  }


  export type $blogsPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "blogs"
    objects: {
      user: Prisma.$userPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      blogsID: string
      title: string
      content: string
      expertise: string
      image: string
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["blogs"]>
    composites: {}
  }


  type blogsGetPayload<S extends boolean | null | undefined | blogsDefaultArgs> = $Result.GetResult<Prisma.$blogsPayload, S>

  type blogsCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<blogsFindManyArgs, 'select' | 'include' | 'distinct' > & {
      select?: BlogsCountAggregateInputType | true
    }

  export interface blogsDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['blogs'], meta: { name: 'blogs' } }
    /**
     * Find zero or one Blogs that matches the filter.
     * @param {blogsFindUniqueArgs} args - Arguments to find a Blogs
     * @example
     * // Get one Blogs
     * const blogs = await prisma.blogs.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends blogsFindUniqueArgs<ExtArgs>>(
      args: SelectSubset<T, blogsFindUniqueArgs<ExtArgs>>
    ): Prisma__blogsClient<$Result.GetResult<Prisma.$blogsPayload<ExtArgs>, T, 'findUnique'> | null, null, ExtArgs>

    /**
     * Find one Blogs that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {blogsFindUniqueOrThrowArgs} args - Arguments to find a Blogs
     * @example
     * // Get one Blogs
     * const blogs = await prisma.blogs.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends blogsFindUniqueOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, blogsFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__blogsClient<$Result.GetResult<Prisma.$blogsPayload<ExtArgs>, T, 'findUniqueOrThrow'>, never, ExtArgs>

    /**
     * Find the first Blogs that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {blogsFindFirstArgs} args - Arguments to find a Blogs
     * @example
     * // Get one Blogs
     * const blogs = await prisma.blogs.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends blogsFindFirstArgs<ExtArgs>>(
      args?: SelectSubset<T, blogsFindFirstArgs<ExtArgs>>
    ): Prisma__blogsClient<$Result.GetResult<Prisma.$blogsPayload<ExtArgs>, T, 'findFirst'> | null, null, ExtArgs>

    /**
     * Find the first Blogs that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {blogsFindFirstOrThrowArgs} args - Arguments to find a Blogs
     * @example
     * // Get one Blogs
     * const blogs = await prisma.blogs.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends blogsFindFirstOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, blogsFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__blogsClient<$Result.GetResult<Prisma.$blogsPayload<ExtArgs>, T, 'findFirstOrThrow'>, never, ExtArgs>

    /**
     * Find zero or more Blogs that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {blogsFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Blogs
     * const blogs = await prisma.blogs.findMany()
     * 
     * // Get first 10 Blogs
     * const blogs = await prisma.blogs.findMany({ take: 10 })
     * 
     * // Only select the `blogsID`
     * const blogsWithBlogsIDOnly = await prisma.blogs.findMany({ select: { blogsID: true } })
     * 
    **/
    findMany<T extends blogsFindManyArgs<ExtArgs>>(
      args?: SelectSubset<T, blogsFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<$Result.GetResult<Prisma.$blogsPayload<ExtArgs>, T, 'findMany'>>

    /**
     * Create a Blogs.
     * @param {blogsCreateArgs} args - Arguments to create a Blogs.
     * @example
     * // Create one Blogs
     * const Blogs = await prisma.blogs.create({
     *   data: {
     *     // ... data to create a Blogs
     *   }
     * })
     * 
    **/
    create<T extends blogsCreateArgs<ExtArgs>>(
      args: SelectSubset<T, blogsCreateArgs<ExtArgs>>
    ): Prisma__blogsClient<$Result.GetResult<Prisma.$blogsPayload<ExtArgs>, T, 'create'>, never, ExtArgs>

    /**
     * Create many Blogs.
     *     @param {blogsCreateManyArgs} args - Arguments to create many Blogs.
     *     @example
     *     // Create many Blogs
     *     const blogs = await prisma.blogs.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends blogsCreateManyArgs<ExtArgs>>(
      args?: SelectSubset<T, blogsCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Blogs.
     * @param {blogsDeleteArgs} args - Arguments to delete one Blogs.
     * @example
     * // Delete one Blogs
     * const Blogs = await prisma.blogs.delete({
     *   where: {
     *     // ... filter to delete one Blogs
     *   }
     * })
     * 
    **/
    delete<T extends blogsDeleteArgs<ExtArgs>>(
      args: SelectSubset<T, blogsDeleteArgs<ExtArgs>>
    ): Prisma__blogsClient<$Result.GetResult<Prisma.$blogsPayload<ExtArgs>, T, 'delete'>, never, ExtArgs>

    /**
     * Update one Blogs.
     * @param {blogsUpdateArgs} args - Arguments to update one Blogs.
     * @example
     * // Update one Blogs
     * const blogs = await prisma.blogs.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends blogsUpdateArgs<ExtArgs>>(
      args: SelectSubset<T, blogsUpdateArgs<ExtArgs>>
    ): Prisma__blogsClient<$Result.GetResult<Prisma.$blogsPayload<ExtArgs>, T, 'update'>, never, ExtArgs>

    /**
     * Delete zero or more Blogs.
     * @param {blogsDeleteManyArgs} args - Arguments to filter Blogs to delete.
     * @example
     * // Delete a few Blogs
     * const { count } = await prisma.blogs.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends blogsDeleteManyArgs<ExtArgs>>(
      args?: SelectSubset<T, blogsDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Blogs.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {blogsUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Blogs
     * const blogs = await prisma.blogs.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends blogsUpdateManyArgs<ExtArgs>>(
      args: SelectSubset<T, blogsUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Blogs.
     * @param {blogsUpsertArgs} args - Arguments to update or create a Blogs.
     * @example
     * // Update or create a Blogs
     * const blogs = await prisma.blogs.upsert({
     *   create: {
     *     // ... data to create a Blogs
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Blogs we want to update
     *   }
     * })
    **/
    upsert<T extends blogsUpsertArgs<ExtArgs>>(
      args: SelectSubset<T, blogsUpsertArgs<ExtArgs>>
    ): Prisma__blogsClient<$Result.GetResult<Prisma.$blogsPayload<ExtArgs>, T, 'upsert'>, never, ExtArgs>

    /**
     * Count the number of Blogs.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {blogsCountArgs} args - Arguments to filter Blogs to count.
     * @example
     * // Count the number of Blogs
     * const count = await prisma.blogs.count({
     *   where: {
     *     // ... the filter for the Blogs we want to count
     *   }
     * })
    **/
    count<T extends blogsCountArgs>(
      args?: Subset<T, blogsCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], BlogsCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Blogs.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BlogsAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends BlogsAggregateArgs>(args: Subset<T, BlogsAggregateArgs>): Prisma.PrismaPromise<GetBlogsAggregateType<T>>

    /**
     * Group by Blogs.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {blogsGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends blogsGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: blogsGroupByArgs['orderBy'] }
        : { orderBy?: blogsGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, blogsGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetBlogsGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the blogs model
   */
  readonly fields: blogsFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for blogs.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__blogsClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: 'PrismaPromise';

    user<T extends blogs$userArgs<ExtArgs> = {}>(args?: Subset<T, blogs$userArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$userPayload<ExtArgs>, T, 'findMany'> | Null>;

    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>;
  }



  /**
   * Fields of the blogs model
   */ 
  interface blogsFieldRefs {
    readonly blogsID: FieldRef<"blogs", 'String'>
    readonly title: FieldRef<"blogs", 'String'>
    readonly content: FieldRef<"blogs", 'String'>
    readonly expertise: FieldRef<"blogs", 'String'>
    readonly image: FieldRef<"blogs", 'String'>
    readonly createdAt: FieldRef<"blogs", 'DateTime'>
    readonly updatedAt: FieldRef<"blogs", 'DateTime'>
  }
    

  // Custom InputTypes

  /**
   * blogs findUnique
   */
  export type blogsFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the blogs
     */
    select?: blogsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: blogsInclude<ExtArgs> | null
    /**
     * Filter, which blogs to fetch.
     */
    where: blogsWhereUniqueInput
  }


  /**
   * blogs findUniqueOrThrow
   */
  export type blogsFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the blogs
     */
    select?: blogsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: blogsInclude<ExtArgs> | null
    /**
     * Filter, which blogs to fetch.
     */
    where: blogsWhereUniqueInput
  }


  /**
   * blogs findFirst
   */
  export type blogsFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the blogs
     */
    select?: blogsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: blogsInclude<ExtArgs> | null
    /**
     * Filter, which blogs to fetch.
     */
    where?: blogsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of blogs to fetch.
     */
    orderBy?: blogsOrderByWithRelationInput | blogsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for blogs.
     */
    cursor?: blogsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` blogs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` blogs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of blogs.
     */
    distinct?: BlogsScalarFieldEnum | BlogsScalarFieldEnum[]
  }


  /**
   * blogs findFirstOrThrow
   */
  export type blogsFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the blogs
     */
    select?: blogsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: blogsInclude<ExtArgs> | null
    /**
     * Filter, which blogs to fetch.
     */
    where?: blogsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of blogs to fetch.
     */
    orderBy?: blogsOrderByWithRelationInput | blogsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for blogs.
     */
    cursor?: blogsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` blogs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` blogs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of blogs.
     */
    distinct?: BlogsScalarFieldEnum | BlogsScalarFieldEnum[]
  }


  /**
   * blogs findMany
   */
  export type blogsFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the blogs
     */
    select?: blogsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: blogsInclude<ExtArgs> | null
    /**
     * Filter, which blogs to fetch.
     */
    where?: blogsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of blogs to fetch.
     */
    orderBy?: blogsOrderByWithRelationInput | blogsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing blogs.
     */
    cursor?: blogsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` blogs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` blogs.
     */
    skip?: number
    distinct?: BlogsScalarFieldEnum | BlogsScalarFieldEnum[]
  }


  /**
   * blogs create
   */
  export type blogsCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the blogs
     */
    select?: blogsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: blogsInclude<ExtArgs> | null
    /**
     * The data needed to create a blogs.
     */
    data: XOR<blogsCreateInput, blogsUncheckedCreateInput>
  }


  /**
   * blogs createMany
   */
  export type blogsCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many blogs.
     */
    data: blogsCreateManyInput | blogsCreateManyInput[]
    skipDuplicates?: boolean
  }


  /**
   * blogs update
   */
  export type blogsUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the blogs
     */
    select?: blogsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: blogsInclude<ExtArgs> | null
    /**
     * The data needed to update a blogs.
     */
    data: XOR<blogsUpdateInput, blogsUncheckedUpdateInput>
    /**
     * Choose, which blogs to update.
     */
    where: blogsWhereUniqueInput
  }


  /**
   * blogs updateMany
   */
  export type blogsUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update blogs.
     */
    data: XOR<blogsUpdateManyMutationInput, blogsUncheckedUpdateManyInput>
    /**
     * Filter which blogs to update
     */
    where?: blogsWhereInput
  }


  /**
   * blogs upsert
   */
  export type blogsUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the blogs
     */
    select?: blogsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: blogsInclude<ExtArgs> | null
    /**
     * The filter to search for the blogs to update in case it exists.
     */
    where: blogsWhereUniqueInput
    /**
     * In case the blogs found by the `where` argument doesn't exist, create a new blogs with this data.
     */
    create: XOR<blogsCreateInput, blogsUncheckedCreateInput>
    /**
     * In case the blogs was found with the provided `where` argument, update it with this data.
     */
    update: XOR<blogsUpdateInput, blogsUncheckedUpdateInput>
  }


  /**
   * blogs delete
   */
  export type blogsDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the blogs
     */
    select?: blogsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: blogsInclude<ExtArgs> | null
    /**
     * Filter which blogs to delete.
     */
    where: blogsWhereUniqueInput
  }


  /**
   * blogs deleteMany
   */
  export type blogsDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which blogs to delete
     */
    where?: blogsWhereInput
  }


  /**
   * blogs.user
   */
  export type blogs$userArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the user
     */
    select?: userSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: userInclude<ExtArgs> | null
    where?: userWhereInput
    orderBy?: userOrderByWithRelationInput | userOrderByWithRelationInput[]
    cursor?: userWhereUniqueInput
    take?: number
    skip?: number
    distinct?: UserScalarFieldEnum | UserScalarFieldEnum[]
  }


  /**
   * blogs without action
   */
  export type blogsDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the blogs
     */
    select?: blogsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: blogsInclude<ExtArgs> | null
  }



  /**
   * Model faqs
   */

  export type AggregateFaqs = {
    _count: FaqsCountAggregateOutputType | null
    _min: FaqsMinAggregateOutputType | null
    _max: FaqsMaxAggregateOutputType | null
  }

  export type FaqsMinAggregateOutputType = {
    faqsID: string | null
    faqs: string | null
    answer: string | null
    creatdAt: Date | null
    updateAt: Date | null
  }

  export type FaqsMaxAggregateOutputType = {
    faqsID: string | null
    faqs: string | null
    answer: string | null
    creatdAt: Date | null
    updateAt: Date | null
  }

  export type FaqsCountAggregateOutputType = {
    faqsID: number
    faqs: number
    answer: number
    creatdAt: number
    updateAt: number
    _all: number
  }


  export type FaqsMinAggregateInputType = {
    faqsID?: true
    faqs?: true
    answer?: true
    creatdAt?: true
    updateAt?: true
  }

  export type FaqsMaxAggregateInputType = {
    faqsID?: true
    faqs?: true
    answer?: true
    creatdAt?: true
    updateAt?: true
  }

  export type FaqsCountAggregateInputType = {
    faqsID?: true
    faqs?: true
    answer?: true
    creatdAt?: true
    updateAt?: true
    _all?: true
  }

  export type FaqsAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which faqs to aggregate.
     */
    where?: faqsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of faqs to fetch.
     */
    orderBy?: faqsOrderByWithRelationInput | faqsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: faqsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` faqs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` faqs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned faqs
    **/
    _count?: true | FaqsCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: FaqsMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: FaqsMaxAggregateInputType
  }

  export type GetFaqsAggregateType<T extends FaqsAggregateArgs> = {
        [P in keyof T & keyof AggregateFaqs]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateFaqs[P]>
      : GetScalarType<T[P], AggregateFaqs[P]>
  }




  export type faqsGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: faqsWhereInput
    orderBy?: faqsOrderByWithAggregationInput | faqsOrderByWithAggregationInput[]
    by: FaqsScalarFieldEnum[] | FaqsScalarFieldEnum
    having?: faqsScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: FaqsCountAggregateInputType | true
    _min?: FaqsMinAggregateInputType
    _max?: FaqsMaxAggregateInputType
  }

  export type FaqsGroupByOutputType = {
    faqsID: string
    faqs: string
    answer: string
    creatdAt: Date
    updateAt: Date
    _count: FaqsCountAggregateOutputType | null
    _min: FaqsMinAggregateOutputType | null
    _max: FaqsMaxAggregateOutputType | null
  }

  type GetFaqsGroupByPayload<T extends faqsGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<FaqsGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof FaqsGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], FaqsGroupByOutputType[P]>
            : GetScalarType<T[P], FaqsGroupByOutputType[P]>
        }
      >
    >


  export type faqsSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    faqsID?: boolean
    faqs?: boolean
    answer?: boolean
    creatdAt?: boolean
    updateAt?: boolean
    user?: boolean | faqs$userArgs<ExtArgs>
    _count?: boolean | FaqsCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["faqs"]>

  export type faqsSelectScalar = {
    faqsID?: boolean
    faqs?: boolean
    answer?: boolean
    creatdAt?: boolean
    updateAt?: boolean
  }

  export type faqsInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | faqs$userArgs<ExtArgs>
    _count?: boolean | FaqsCountOutputTypeDefaultArgs<ExtArgs>
  }


  export type $faqsPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "faqs"
    objects: {
      user: Prisma.$userPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      faqsID: string
      faqs: string
      answer: string
      creatdAt: Date
      updateAt: Date
    }, ExtArgs["result"]["faqs"]>
    composites: {}
  }


  type faqsGetPayload<S extends boolean | null | undefined | faqsDefaultArgs> = $Result.GetResult<Prisma.$faqsPayload, S>

  type faqsCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<faqsFindManyArgs, 'select' | 'include' | 'distinct' > & {
      select?: FaqsCountAggregateInputType | true
    }

  export interface faqsDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['faqs'], meta: { name: 'faqs' } }
    /**
     * Find zero or one Faqs that matches the filter.
     * @param {faqsFindUniqueArgs} args - Arguments to find a Faqs
     * @example
     * // Get one Faqs
     * const faqs = await prisma.faqs.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends faqsFindUniqueArgs<ExtArgs>>(
      args: SelectSubset<T, faqsFindUniqueArgs<ExtArgs>>
    ): Prisma__faqsClient<$Result.GetResult<Prisma.$faqsPayload<ExtArgs>, T, 'findUnique'> | null, null, ExtArgs>

    /**
     * Find one Faqs that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {faqsFindUniqueOrThrowArgs} args - Arguments to find a Faqs
     * @example
     * // Get one Faqs
     * const faqs = await prisma.faqs.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends faqsFindUniqueOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, faqsFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__faqsClient<$Result.GetResult<Prisma.$faqsPayload<ExtArgs>, T, 'findUniqueOrThrow'>, never, ExtArgs>

    /**
     * Find the first Faqs that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {faqsFindFirstArgs} args - Arguments to find a Faqs
     * @example
     * // Get one Faqs
     * const faqs = await prisma.faqs.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends faqsFindFirstArgs<ExtArgs>>(
      args?: SelectSubset<T, faqsFindFirstArgs<ExtArgs>>
    ): Prisma__faqsClient<$Result.GetResult<Prisma.$faqsPayload<ExtArgs>, T, 'findFirst'> | null, null, ExtArgs>

    /**
     * Find the first Faqs that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {faqsFindFirstOrThrowArgs} args - Arguments to find a Faqs
     * @example
     * // Get one Faqs
     * const faqs = await prisma.faqs.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends faqsFindFirstOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, faqsFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__faqsClient<$Result.GetResult<Prisma.$faqsPayload<ExtArgs>, T, 'findFirstOrThrow'>, never, ExtArgs>

    /**
     * Find zero or more Faqs that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {faqsFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Faqs
     * const faqs = await prisma.faqs.findMany()
     * 
     * // Get first 10 Faqs
     * const faqs = await prisma.faqs.findMany({ take: 10 })
     * 
     * // Only select the `faqsID`
     * const faqsWithFaqsIDOnly = await prisma.faqs.findMany({ select: { faqsID: true } })
     * 
    **/
    findMany<T extends faqsFindManyArgs<ExtArgs>>(
      args?: SelectSubset<T, faqsFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<$Result.GetResult<Prisma.$faqsPayload<ExtArgs>, T, 'findMany'>>

    /**
     * Create a Faqs.
     * @param {faqsCreateArgs} args - Arguments to create a Faqs.
     * @example
     * // Create one Faqs
     * const Faqs = await prisma.faqs.create({
     *   data: {
     *     // ... data to create a Faqs
     *   }
     * })
     * 
    **/
    create<T extends faqsCreateArgs<ExtArgs>>(
      args: SelectSubset<T, faqsCreateArgs<ExtArgs>>
    ): Prisma__faqsClient<$Result.GetResult<Prisma.$faqsPayload<ExtArgs>, T, 'create'>, never, ExtArgs>

    /**
     * Create many Faqs.
     *     @param {faqsCreateManyArgs} args - Arguments to create many Faqs.
     *     @example
     *     // Create many Faqs
     *     const faqs = await prisma.faqs.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends faqsCreateManyArgs<ExtArgs>>(
      args?: SelectSubset<T, faqsCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Faqs.
     * @param {faqsDeleteArgs} args - Arguments to delete one Faqs.
     * @example
     * // Delete one Faqs
     * const Faqs = await prisma.faqs.delete({
     *   where: {
     *     // ... filter to delete one Faqs
     *   }
     * })
     * 
    **/
    delete<T extends faqsDeleteArgs<ExtArgs>>(
      args: SelectSubset<T, faqsDeleteArgs<ExtArgs>>
    ): Prisma__faqsClient<$Result.GetResult<Prisma.$faqsPayload<ExtArgs>, T, 'delete'>, never, ExtArgs>

    /**
     * Update one Faqs.
     * @param {faqsUpdateArgs} args - Arguments to update one Faqs.
     * @example
     * // Update one Faqs
     * const faqs = await prisma.faqs.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends faqsUpdateArgs<ExtArgs>>(
      args: SelectSubset<T, faqsUpdateArgs<ExtArgs>>
    ): Prisma__faqsClient<$Result.GetResult<Prisma.$faqsPayload<ExtArgs>, T, 'update'>, never, ExtArgs>

    /**
     * Delete zero or more Faqs.
     * @param {faqsDeleteManyArgs} args - Arguments to filter Faqs to delete.
     * @example
     * // Delete a few Faqs
     * const { count } = await prisma.faqs.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends faqsDeleteManyArgs<ExtArgs>>(
      args?: SelectSubset<T, faqsDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Faqs.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {faqsUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Faqs
     * const faqs = await prisma.faqs.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends faqsUpdateManyArgs<ExtArgs>>(
      args: SelectSubset<T, faqsUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Faqs.
     * @param {faqsUpsertArgs} args - Arguments to update or create a Faqs.
     * @example
     * // Update or create a Faqs
     * const faqs = await prisma.faqs.upsert({
     *   create: {
     *     // ... data to create a Faqs
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Faqs we want to update
     *   }
     * })
    **/
    upsert<T extends faqsUpsertArgs<ExtArgs>>(
      args: SelectSubset<T, faqsUpsertArgs<ExtArgs>>
    ): Prisma__faqsClient<$Result.GetResult<Prisma.$faqsPayload<ExtArgs>, T, 'upsert'>, never, ExtArgs>

    /**
     * Count the number of Faqs.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {faqsCountArgs} args - Arguments to filter Faqs to count.
     * @example
     * // Count the number of Faqs
     * const count = await prisma.faqs.count({
     *   where: {
     *     // ... the filter for the Faqs we want to count
     *   }
     * })
    **/
    count<T extends faqsCountArgs>(
      args?: Subset<T, faqsCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], FaqsCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Faqs.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FaqsAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends FaqsAggregateArgs>(args: Subset<T, FaqsAggregateArgs>): Prisma.PrismaPromise<GetFaqsAggregateType<T>>

    /**
     * Group by Faqs.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {faqsGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends faqsGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: faqsGroupByArgs['orderBy'] }
        : { orderBy?: faqsGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, faqsGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetFaqsGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the faqs model
   */
  readonly fields: faqsFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for faqs.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__faqsClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: 'PrismaPromise';

    user<T extends faqs$userArgs<ExtArgs> = {}>(args?: Subset<T, faqs$userArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$userPayload<ExtArgs>, T, 'findMany'> | Null>;

    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>;
  }



  /**
   * Fields of the faqs model
   */ 
  interface faqsFieldRefs {
    readonly faqsID: FieldRef<"faqs", 'String'>
    readonly faqs: FieldRef<"faqs", 'String'>
    readonly answer: FieldRef<"faqs", 'String'>
    readonly creatdAt: FieldRef<"faqs", 'DateTime'>
    readonly updateAt: FieldRef<"faqs", 'DateTime'>
  }
    

  // Custom InputTypes

  /**
   * faqs findUnique
   */
  export type faqsFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the faqs
     */
    select?: faqsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: faqsInclude<ExtArgs> | null
    /**
     * Filter, which faqs to fetch.
     */
    where: faqsWhereUniqueInput
  }


  /**
   * faqs findUniqueOrThrow
   */
  export type faqsFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the faqs
     */
    select?: faqsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: faqsInclude<ExtArgs> | null
    /**
     * Filter, which faqs to fetch.
     */
    where: faqsWhereUniqueInput
  }


  /**
   * faqs findFirst
   */
  export type faqsFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the faqs
     */
    select?: faqsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: faqsInclude<ExtArgs> | null
    /**
     * Filter, which faqs to fetch.
     */
    where?: faqsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of faqs to fetch.
     */
    orderBy?: faqsOrderByWithRelationInput | faqsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for faqs.
     */
    cursor?: faqsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` faqs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` faqs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of faqs.
     */
    distinct?: FaqsScalarFieldEnum | FaqsScalarFieldEnum[]
  }


  /**
   * faqs findFirstOrThrow
   */
  export type faqsFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the faqs
     */
    select?: faqsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: faqsInclude<ExtArgs> | null
    /**
     * Filter, which faqs to fetch.
     */
    where?: faqsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of faqs to fetch.
     */
    orderBy?: faqsOrderByWithRelationInput | faqsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for faqs.
     */
    cursor?: faqsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` faqs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` faqs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of faqs.
     */
    distinct?: FaqsScalarFieldEnum | FaqsScalarFieldEnum[]
  }


  /**
   * faqs findMany
   */
  export type faqsFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the faqs
     */
    select?: faqsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: faqsInclude<ExtArgs> | null
    /**
     * Filter, which faqs to fetch.
     */
    where?: faqsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of faqs to fetch.
     */
    orderBy?: faqsOrderByWithRelationInput | faqsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing faqs.
     */
    cursor?: faqsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` faqs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` faqs.
     */
    skip?: number
    distinct?: FaqsScalarFieldEnum | FaqsScalarFieldEnum[]
  }


  /**
   * faqs create
   */
  export type faqsCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the faqs
     */
    select?: faqsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: faqsInclude<ExtArgs> | null
    /**
     * The data needed to create a faqs.
     */
    data: XOR<faqsCreateInput, faqsUncheckedCreateInput>
  }


  /**
   * faqs createMany
   */
  export type faqsCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many faqs.
     */
    data: faqsCreateManyInput | faqsCreateManyInput[]
    skipDuplicates?: boolean
  }


  /**
   * faqs update
   */
  export type faqsUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the faqs
     */
    select?: faqsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: faqsInclude<ExtArgs> | null
    /**
     * The data needed to update a faqs.
     */
    data: XOR<faqsUpdateInput, faqsUncheckedUpdateInput>
    /**
     * Choose, which faqs to update.
     */
    where: faqsWhereUniqueInput
  }


  /**
   * faqs updateMany
   */
  export type faqsUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update faqs.
     */
    data: XOR<faqsUpdateManyMutationInput, faqsUncheckedUpdateManyInput>
    /**
     * Filter which faqs to update
     */
    where?: faqsWhereInput
  }


  /**
   * faqs upsert
   */
  export type faqsUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the faqs
     */
    select?: faqsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: faqsInclude<ExtArgs> | null
    /**
     * The filter to search for the faqs to update in case it exists.
     */
    where: faqsWhereUniqueInput
    /**
     * In case the faqs found by the `where` argument doesn't exist, create a new faqs with this data.
     */
    create: XOR<faqsCreateInput, faqsUncheckedCreateInput>
    /**
     * In case the faqs was found with the provided `where` argument, update it with this data.
     */
    update: XOR<faqsUpdateInput, faqsUncheckedUpdateInput>
  }


  /**
   * faqs delete
   */
  export type faqsDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the faqs
     */
    select?: faqsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: faqsInclude<ExtArgs> | null
    /**
     * Filter which faqs to delete.
     */
    where: faqsWhereUniqueInput
  }


  /**
   * faqs deleteMany
   */
  export type faqsDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which faqs to delete
     */
    where?: faqsWhereInput
  }


  /**
   * faqs.user
   */
  export type faqs$userArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the user
     */
    select?: userSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: userInclude<ExtArgs> | null
    where?: userWhereInput
    orderBy?: userOrderByWithRelationInput | userOrderByWithRelationInput[]
    cursor?: userWhereUniqueInput
    take?: number
    skip?: number
    distinct?: UserScalarFieldEnum | UserScalarFieldEnum[]
  }


  /**
   * faqs without action
   */
  export type faqsDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the faqs
     */
    select?: faqsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: faqsInclude<ExtArgs> | null
  }



  /**
   * Model avatar
   */

  export type AggregateAvatar = {
    _count: AvatarCountAggregateOutputType | null
    _min: AvatarMinAggregateOutputType | null
    _max: AvatarMaxAggregateOutputType | null
  }

  export type AvatarMinAggregateOutputType = {
    avatarID: string | null
    avatar: string | null
    creatdAt: Date | null
    updateAt: Date | null
    profileID: string | null
  }

  export type AvatarMaxAggregateOutputType = {
    avatarID: string | null
    avatar: string | null
    creatdAt: Date | null
    updateAt: Date | null
    profileID: string | null
  }

  export type AvatarCountAggregateOutputType = {
    avatarID: number
    avatar: number
    creatdAt: number
    updateAt: number
    profileID: number
    _all: number
  }


  export type AvatarMinAggregateInputType = {
    avatarID?: true
    avatar?: true
    creatdAt?: true
    updateAt?: true
    profileID?: true
  }

  export type AvatarMaxAggregateInputType = {
    avatarID?: true
    avatar?: true
    creatdAt?: true
    updateAt?: true
    profileID?: true
  }

  export type AvatarCountAggregateInputType = {
    avatarID?: true
    avatar?: true
    creatdAt?: true
    updateAt?: true
    profileID?: true
    _all?: true
  }

  export type AvatarAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which avatar to aggregate.
     */
    where?: avatarWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of avatars to fetch.
     */
    orderBy?: avatarOrderByWithRelationInput | avatarOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: avatarWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` avatars from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` avatars.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned avatars
    **/
    _count?: true | AvatarCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: AvatarMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: AvatarMaxAggregateInputType
  }

  export type GetAvatarAggregateType<T extends AvatarAggregateArgs> = {
        [P in keyof T & keyof AggregateAvatar]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateAvatar[P]>
      : GetScalarType<T[P], AggregateAvatar[P]>
  }




  export type avatarGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: avatarWhereInput
    orderBy?: avatarOrderByWithAggregationInput | avatarOrderByWithAggregationInput[]
    by: AvatarScalarFieldEnum[] | AvatarScalarFieldEnum
    having?: avatarScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: AvatarCountAggregateInputType | true
    _min?: AvatarMinAggregateInputType
    _max?: AvatarMaxAggregateInputType
  }

  export type AvatarGroupByOutputType = {
    avatarID: string
    avatar: string
    creatdAt: Date
    updateAt: Date
    profileID: string | null
    _count: AvatarCountAggregateOutputType | null
    _min: AvatarMinAggregateOutputType | null
    _max: AvatarMaxAggregateOutputType | null
  }

  type GetAvatarGroupByPayload<T extends avatarGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<AvatarGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof AvatarGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], AvatarGroupByOutputType[P]>
            : GetScalarType<T[P], AvatarGroupByOutputType[P]>
        }
      >
    >


  export type avatarSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    avatarID?: boolean
    avatar?: boolean
    creatdAt?: boolean
    updateAt?: boolean
    profileID?: boolean
    profile?: boolean | avatar$profileArgs<ExtArgs>
  }, ExtArgs["result"]["avatar"]>

  export type avatarSelectScalar = {
    avatarID?: boolean
    avatar?: boolean
    creatdAt?: boolean
    updateAt?: boolean
    profileID?: boolean
  }

  export type avatarInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    profile?: boolean | avatar$profileArgs<ExtArgs>
  }


  export type $avatarPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "avatar"
    objects: {
      profile: Prisma.$profilePayload<ExtArgs> | null
    }
    scalars: $Extensions.GetPayloadResult<{
      avatarID: string
      avatar: string
      creatdAt: Date
      updateAt: Date
      profileID: string | null
    }, ExtArgs["result"]["avatar"]>
    composites: {}
  }


  type avatarGetPayload<S extends boolean | null | undefined | avatarDefaultArgs> = $Result.GetResult<Prisma.$avatarPayload, S>

  type avatarCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<avatarFindManyArgs, 'select' | 'include' | 'distinct' > & {
      select?: AvatarCountAggregateInputType | true
    }

  export interface avatarDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['avatar'], meta: { name: 'avatar' } }
    /**
     * Find zero or one Avatar that matches the filter.
     * @param {avatarFindUniqueArgs} args - Arguments to find a Avatar
     * @example
     * // Get one Avatar
     * const avatar = await prisma.avatar.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends avatarFindUniqueArgs<ExtArgs>>(
      args: SelectSubset<T, avatarFindUniqueArgs<ExtArgs>>
    ): Prisma__avatarClient<$Result.GetResult<Prisma.$avatarPayload<ExtArgs>, T, 'findUnique'> | null, null, ExtArgs>

    /**
     * Find one Avatar that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {avatarFindUniqueOrThrowArgs} args - Arguments to find a Avatar
     * @example
     * // Get one Avatar
     * const avatar = await prisma.avatar.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends avatarFindUniqueOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, avatarFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__avatarClient<$Result.GetResult<Prisma.$avatarPayload<ExtArgs>, T, 'findUniqueOrThrow'>, never, ExtArgs>

    /**
     * Find the first Avatar that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {avatarFindFirstArgs} args - Arguments to find a Avatar
     * @example
     * // Get one Avatar
     * const avatar = await prisma.avatar.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends avatarFindFirstArgs<ExtArgs>>(
      args?: SelectSubset<T, avatarFindFirstArgs<ExtArgs>>
    ): Prisma__avatarClient<$Result.GetResult<Prisma.$avatarPayload<ExtArgs>, T, 'findFirst'> | null, null, ExtArgs>

    /**
     * Find the first Avatar that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {avatarFindFirstOrThrowArgs} args - Arguments to find a Avatar
     * @example
     * // Get one Avatar
     * const avatar = await prisma.avatar.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends avatarFindFirstOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, avatarFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__avatarClient<$Result.GetResult<Prisma.$avatarPayload<ExtArgs>, T, 'findFirstOrThrow'>, never, ExtArgs>

    /**
     * Find zero or more Avatars that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {avatarFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Avatars
     * const avatars = await prisma.avatar.findMany()
     * 
     * // Get first 10 Avatars
     * const avatars = await prisma.avatar.findMany({ take: 10 })
     * 
     * // Only select the `avatarID`
     * const avatarWithAvatarIDOnly = await prisma.avatar.findMany({ select: { avatarID: true } })
     * 
    **/
    findMany<T extends avatarFindManyArgs<ExtArgs>>(
      args?: SelectSubset<T, avatarFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<$Result.GetResult<Prisma.$avatarPayload<ExtArgs>, T, 'findMany'>>

    /**
     * Create a Avatar.
     * @param {avatarCreateArgs} args - Arguments to create a Avatar.
     * @example
     * // Create one Avatar
     * const Avatar = await prisma.avatar.create({
     *   data: {
     *     // ... data to create a Avatar
     *   }
     * })
     * 
    **/
    create<T extends avatarCreateArgs<ExtArgs>>(
      args: SelectSubset<T, avatarCreateArgs<ExtArgs>>
    ): Prisma__avatarClient<$Result.GetResult<Prisma.$avatarPayload<ExtArgs>, T, 'create'>, never, ExtArgs>

    /**
     * Create many Avatars.
     *     @param {avatarCreateManyArgs} args - Arguments to create many Avatars.
     *     @example
     *     // Create many Avatars
     *     const avatar = await prisma.avatar.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends avatarCreateManyArgs<ExtArgs>>(
      args?: SelectSubset<T, avatarCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Avatar.
     * @param {avatarDeleteArgs} args - Arguments to delete one Avatar.
     * @example
     * // Delete one Avatar
     * const Avatar = await prisma.avatar.delete({
     *   where: {
     *     // ... filter to delete one Avatar
     *   }
     * })
     * 
    **/
    delete<T extends avatarDeleteArgs<ExtArgs>>(
      args: SelectSubset<T, avatarDeleteArgs<ExtArgs>>
    ): Prisma__avatarClient<$Result.GetResult<Prisma.$avatarPayload<ExtArgs>, T, 'delete'>, never, ExtArgs>

    /**
     * Update one Avatar.
     * @param {avatarUpdateArgs} args - Arguments to update one Avatar.
     * @example
     * // Update one Avatar
     * const avatar = await prisma.avatar.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends avatarUpdateArgs<ExtArgs>>(
      args: SelectSubset<T, avatarUpdateArgs<ExtArgs>>
    ): Prisma__avatarClient<$Result.GetResult<Prisma.$avatarPayload<ExtArgs>, T, 'update'>, never, ExtArgs>

    /**
     * Delete zero or more Avatars.
     * @param {avatarDeleteManyArgs} args - Arguments to filter Avatars to delete.
     * @example
     * // Delete a few Avatars
     * const { count } = await prisma.avatar.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends avatarDeleteManyArgs<ExtArgs>>(
      args?: SelectSubset<T, avatarDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Avatars.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {avatarUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Avatars
     * const avatar = await prisma.avatar.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends avatarUpdateManyArgs<ExtArgs>>(
      args: SelectSubset<T, avatarUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Avatar.
     * @param {avatarUpsertArgs} args - Arguments to update or create a Avatar.
     * @example
     * // Update or create a Avatar
     * const avatar = await prisma.avatar.upsert({
     *   create: {
     *     // ... data to create a Avatar
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Avatar we want to update
     *   }
     * })
    **/
    upsert<T extends avatarUpsertArgs<ExtArgs>>(
      args: SelectSubset<T, avatarUpsertArgs<ExtArgs>>
    ): Prisma__avatarClient<$Result.GetResult<Prisma.$avatarPayload<ExtArgs>, T, 'upsert'>, never, ExtArgs>

    /**
     * Count the number of Avatars.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {avatarCountArgs} args - Arguments to filter Avatars to count.
     * @example
     * // Count the number of Avatars
     * const count = await prisma.avatar.count({
     *   where: {
     *     // ... the filter for the Avatars we want to count
     *   }
     * })
    **/
    count<T extends avatarCountArgs>(
      args?: Subset<T, avatarCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], AvatarCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Avatar.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AvatarAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends AvatarAggregateArgs>(args: Subset<T, AvatarAggregateArgs>): Prisma.PrismaPromise<GetAvatarAggregateType<T>>

    /**
     * Group by Avatar.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {avatarGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends avatarGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: avatarGroupByArgs['orderBy'] }
        : { orderBy?: avatarGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, avatarGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetAvatarGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the avatar model
   */
  readonly fields: avatarFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for avatar.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__avatarClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: 'PrismaPromise';

    profile<T extends avatar$profileArgs<ExtArgs> = {}>(args?: Subset<T, avatar$profileArgs<ExtArgs>>): Prisma__profileClient<$Result.GetResult<Prisma.$profilePayload<ExtArgs>, T, 'findUniqueOrThrow'> | null, null, ExtArgs>;

    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>;
  }



  /**
   * Fields of the avatar model
   */ 
  interface avatarFieldRefs {
    readonly avatarID: FieldRef<"avatar", 'String'>
    readonly avatar: FieldRef<"avatar", 'String'>
    readonly creatdAt: FieldRef<"avatar", 'DateTime'>
    readonly updateAt: FieldRef<"avatar", 'DateTime'>
    readonly profileID: FieldRef<"avatar", 'String'>
  }
    

  // Custom InputTypes

  /**
   * avatar findUnique
   */
  export type avatarFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the avatar
     */
    select?: avatarSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: avatarInclude<ExtArgs> | null
    /**
     * Filter, which avatar to fetch.
     */
    where: avatarWhereUniqueInput
  }


  /**
   * avatar findUniqueOrThrow
   */
  export type avatarFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the avatar
     */
    select?: avatarSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: avatarInclude<ExtArgs> | null
    /**
     * Filter, which avatar to fetch.
     */
    where: avatarWhereUniqueInput
  }


  /**
   * avatar findFirst
   */
  export type avatarFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the avatar
     */
    select?: avatarSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: avatarInclude<ExtArgs> | null
    /**
     * Filter, which avatar to fetch.
     */
    where?: avatarWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of avatars to fetch.
     */
    orderBy?: avatarOrderByWithRelationInput | avatarOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for avatars.
     */
    cursor?: avatarWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` avatars from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` avatars.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of avatars.
     */
    distinct?: AvatarScalarFieldEnum | AvatarScalarFieldEnum[]
  }


  /**
   * avatar findFirstOrThrow
   */
  export type avatarFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the avatar
     */
    select?: avatarSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: avatarInclude<ExtArgs> | null
    /**
     * Filter, which avatar to fetch.
     */
    where?: avatarWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of avatars to fetch.
     */
    orderBy?: avatarOrderByWithRelationInput | avatarOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for avatars.
     */
    cursor?: avatarWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` avatars from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` avatars.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of avatars.
     */
    distinct?: AvatarScalarFieldEnum | AvatarScalarFieldEnum[]
  }


  /**
   * avatar findMany
   */
  export type avatarFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the avatar
     */
    select?: avatarSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: avatarInclude<ExtArgs> | null
    /**
     * Filter, which avatars to fetch.
     */
    where?: avatarWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of avatars to fetch.
     */
    orderBy?: avatarOrderByWithRelationInput | avatarOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing avatars.
     */
    cursor?: avatarWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` avatars from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` avatars.
     */
    skip?: number
    distinct?: AvatarScalarFieldEnum | AvatarScalarFieldEnum[]
  }


  /**
   * avatar create
   */
  export type avatarCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the avatar
     */
    select?: avatarSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: avatarInclude<ExtArgs> | null
    /**
     * The data needed to create a avatar.
     */
    data: XOR<avatarCreateInput, avatarUncheckedCreateInput>
  }


  /**
   * avatar createMany
   */
  export type avatarCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many avatars.
     */
    data: avatarCreateManyInput | avatarCreateManyInput[]
    skipDuplicates?: boolean
  }


  /**
   * avatar update
   */
  export type avatarUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the avatar
     */
    select?: avatarSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: avatarInclude<ExtArgs> | null
    /**
     * The data needed to update a avatar.
     */
    data: XOR<avatarUpdateInput, avatarUncheckedUpdateInput>
    /**
     * Choose, which avatar to update.
     */
    where: avatarWhereUniqueInput
  }


  /**
   * avatar updateMany
   */
  export type avatarUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update avatars.
     */
    data: XOR<avatarUpdateManyMutationInput, avatarUncheckedUpdateManyInput>
    /**
     * Filter which avatars to update
     */
    where?: avatarWhereInput
  }


  /**
   * avatar upsert
   */
  export type avatarUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the avatar
     */
    select?: avatarSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: avatarInclude<ExtArgs> | null
    /**
     * The filter to search for the avatar to update in case it exists.
     */
    where: avatarWhereUniqueInput
    /**
     * In case the avatar found by the `where` argument doesn't exist, create a new avatar with this data.
     */
    create: XOR<avatarCreateInput, avatarUncheckedCreateInput>
    /**
     * In case the avatar was found with the provided `where` argument, update it with this data.
     */
    update: XOR<avatarUpdateInput, avatarUncheckedUpdateInput>
  }


  /**
   * avatar delete
   */
  export type avatarDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the avatar
     */
    select?: avatarSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: avatarInclude<ExtArgs> | null
    /**
     * Filter which avatar to delete.
     */
    where: avatarWhereUniqueInput
  }


  /**
   * avatar deleteMany
   */
  export type avatarDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which avatars to delete
     */
    where?: avatarWhereInput
  }


  /**
   * avatar.profile
   */
  export type avatar$profileArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the profile
     */
    select?: profileSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: profileInclude<ExtArgs> | null
    where?: profileWhereInput
  }


  /**
   * avatar without action
   */
  export type avatarDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the avatar
     */
    select?: avatarSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: avatarInclude<ExtArgs> | null
  }



  /**
   * Model profile
   */

  export type AggregateProfile = {
    _count: ProfileCountAggregateOutputType | null
    _min: ProfileMinAggregateOutputType | null
    _max: ProfileMaxAggregateOutputType | null
  }

  export type ProfileMinAggregateOutputType = {
    profileID: string | null
    firstname: string | null
    lastname: string | null
    phone: string | null
    designation: string | null
    expertise: string | null
    emergencyPhone: string | null
    userID: string | null
  }

  export type ProfileMaxAggregateOutputType = {
    profileID: string | null
    firstname: string | null
    lastname: string | null
    phone: string | null
    designation: string | null
    expertise: string | null
    emergencyPhone: string | null
    userID: string | null
  }

  export type ProfileCountAggregateOutputType = {
    profileID: number
    firstname: number
    lastname: number
    phone: number
    designation: number
    expertise: number
    emergencyPhone: number
    userID: number
    _all: number
  }


  export type ProfileMinAggregateInputType = {
    profileID?: true
    firstname?: true
    lastname?: true
    phone?: true
    designation?: true
    expertise?: true
    emergencyPhone?: true
    userID?: true
  }

  export type ProfileMaxAggregateInputType = {
    profileID?: true
    firstname?: true
    lastname?: true
    phone?: true
    designation?: true
    expertise?: true
    emergencyPhone?: true
    userID?: true
  }

  export type ProfileCountAggregateInputType = {
    profileID?: true
    firstname?: true
    lastname?: true
    phone?: true
    designation?: true
    expertise?: true
    emergencyPhone?: true
    userID?: true
    _all?: true
  }

  export type ProfileAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which profile to aggregate.
     */
    where?: profileWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of profiles to fetch.
     */
    orderBy?: profileOrderByWithRelationInput | profileOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: profileWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` profiles from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` profiles.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned profiles
    **/
    _count?: true | ProfileCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ProfileMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ProfileMaxAggregateInputType
  }

  export type GetProfileAggregateType<T extends ProfileAggregateArgs> = {
        [P in keyof T & keyof AggregateProfile]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateProfile[P]>
      : GetScalarType<T[P], AggregateProfile[P]>
  }




  export type profileGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: profileWhereInput
    orderBy?: profileOrderByWithAggregationInput | profileOrderByWithAggregationInput[]
    by: ProfileScalarFieldEnum[] | ProfileScalarFieldEnum
    having?: profileScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ProfileCountAggregateInputType | true
    _min?: ProfileMinAggregateInputType
    _max?: ProfileMaxAggregateInputType
  }

  export type ProfileGroupByOutputType = {
    profileID: string
    firstname: string
    lastname: string
    phone: string
    designation: string | null
    expertise: string | null
    emergencyPhone: string | null
    userID: string | null
    _count: ProfileCountAggregateOutputType | null
    _min: ProfileMinAggregateOutputType | null
    _max: ProfileMaxAggregateOutputType | null
  }

  type GetProfileGroupByPayload<T extends profileGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ProfileGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ProfileGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ProfileGroupByOutputType[P]>
            : GetScalarType<T[P], ProfileGroupByOutputType[P]>
        }
      >
    >


  export type profileSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    profileID?: boolean
    firstname?: boolean
    lastname?: boolean
    phone?: boolean
    designation?: boolean
    expertise?: boolean
    emergencyPhone?: boolean
    userID?: boolean
    avatar?: boolean | profile$avatarArgs<ExtArgs>
    user?: boolean | profile$userArgs<ExtArgs>
  }, ExtArgs["result"]["profile"]>

  export type profileSelectScalar = {
    profileID?: boolean
    firstname?: boolean
    lastname?: boolean
    phone?: boolean
    designation?: boolean
    expertise?: boolean
    emergencyPhone?: boolean
    userID?: boolean
  }

  export type profileInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    avatar?: boolean | profile$avatarArgs<ExtArgs>
    user?: boolean | profile$userArgs<ExtArgs>
  }


  export type $profilePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "profile"
    objects: {
      avatar: Prisma.$avatarPayload<ExtArgs> | null
      user: Prisma.$userPayload<ExtArgs> | null
    }
    scalars: $Extensions.GetPayloadResult<{
      profileID: string
      firstname: string
      lastname: string
      phone: string
      designation: string | null
      expertise: string | null
      emergencyPhone: string | null
      userID: string | null
    }, ExtArgs["result"]["profile"]>
    composites: {}
  }


  type profileGetPayload<S extends boolean | null | undefined | profileDefaultArgs> = $Result.GetResult<Prisma.$profilePayload, S>

  type profileCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<profileFindManyArgs, 'select' | 'include' | 'distinct' > & {
      select?: ProfileCountAggregateInputType | true
    }

  export interface profileDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['profile'], meta: { name: 'profile' } }
    /**
     * Find zero or one Profile that matches the filter.
     * @param {profileFindUniqueArgs} args - Arguments to find a Profile
     * @example
     * // Get one Profile
     * const profile = await prisma.profile.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends profileFindUniqueArgs<ExtArgs>>(
      args: SelectSubset<T, profileFindUniqueArgs<ExtArgs>>
    ): Prisma__profileClient<$Result.GetResult<Prisma.$profilePayload<ExtArgs>, T, 'findUnique'> | null, null, ExtArgs>

    /**
     * Find one Profile that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {profileFindUniqueOrThrowArgs} args - Arguments to find a Profile
     * @example
     * // Get one Profile
     * const profile = await prisma.profile.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends profileFindUniqueOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, profileFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__profileClient<$Result.GetResult<Prisma.$profilePayload<ExtArgs>, T, 'findUniqueOrThrow'>, never, ExtArgs>

    /**
     * Find the first Profile that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {profileFindFirstArgs} args - Arguments to find a Profile
     * @example
     * // Get one Profile
     * const profile = await prisma.profile.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends profileFindFirstArgs<ExtArgs>>(
      args?: SelectSubset<T, profileFindFirstArgs<ExtArgs>>
    ): Prisma__profileClient<$Result.GetResult<Prisma.$profilePayload<ExtArgs>, T, 'findFirst'> | null, null, ExtArgs>

    /**
     * Find the first Profile that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {profileFindFirstOrThrowArgs} args - Arguments to find a Profile
     * @example
     * // Get one Profile
     * const profile = await prisma.profile.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends profileFindFirstOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, profileFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__profileClient<$Result.GetResult<Prisma.$profilePayload<ExtArgs>, T, 'findFirstOrThrow'>, never, ExtArgs>

    /**
     * Find zero or more Profiles that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {profileFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Profiles
     * const profiles = await prisma.profile.findMany()
     * 
     * // Get first 10 Profiles
     * const profiles = await prisma.profile.findMany({ take: 10 })
     * 
     * // Only select the `profileID`
     * const profileWithProfileIDOnly = await prisma.profile.findMany({ select: { profileID: true } })
     * 
    **/
    findMany<T extends profileFindManyArgs<ExtArgs>>(
      args?: SelectSubset<T, profileFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<$Result.GetResult<Prisma.$profilePayload<ExtArgs>, T, 'findMany'>>

    /**
     * Create a Profile.
     * @param {profileCreateArgs} args - Arguments to create a Profile.
     * @example
     * // Create one Profile
     * const Profile = await prisma.profile.create({
     *   data: {
     *     // ... data to create a Profile
     *   }
     * })
     * 
    **/
    create<T extends profileCreateArgs<ExtArgs>>(
      args: SelectSubset<T, profileCreateArgs<ExtArgs>>
    ): Prisma__profileClient<$Result.GetResult<Prisma.$profilePayload<ExtArgs>, T, 'create'>, never, ExtArgs>

    /**
     * Create many Profiles.
     *     @param {profileCreateManyArgs} args - Arguments to create many Profiles.
     *     @example
     *     // Create many Profiles
     *     const profile = await prisma.profile.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends profileCreateManyArgs<ExtArgs>>(
      args?: SelectSubset<T, profileCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Profile.
     * @param {profileDeleteArgs} args - Arguments to delete one Profile.
     * @example
     * // Delete one Profile
     * const Profile = await prisma.profile.delete({
     *   where: {
     *     // ... filter to delete one Profile
     *   }
     * })
     * 
    **/
    delete<T extends profileDeleteArgs<ExtArgs>>(
      args: SelectSubset<T, profileDeleteArgs<ExtArgs>>
    ): Prisma__profileClient<$Result.GetResult<Prisma.$profilePayload<ExtArgs>, T, 'delete'>, never, ExtArgs>

    /**
     * Update one Profile.
     * @param {profileUpdateArgs} args - Arguments to update one Profile.
     * @example
     * // Update one Profile
     * const profile = await prisma.profile.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends profileUpdateArgs<ExtArgs>>(
      args: SelectSubset<T, profileUpdateArgs<ExtArgs>>
    ): Prisma__profileClient<$Result.GetResult<Prisma.$profilePayload<ExtArgs>, T, 'update'>, never, ExtArgs>

    /**
     * Delete zero or more Profiles.
     * @param {profileDeleteManyArgs} args - Arguments to filter Profiles to delete.
     * @example
     * // Delete a few Profiles
     * const { count } = await prisma.profile.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends profileDeleteManyArgs<ExtArgs>>(
      args?: SelectSubset<T, profileDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Profiles.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {profileUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Profiles
     * const profile = await prisma.profile.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends profileUpdateManyArgs<ExtArgs>>(
      args: SelectSubset<T, profileUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Profile.
     * @param {profileUpsertArgs} args - Arguments to update or create a Profile.
     * @example
     * // Update or create a Profile
     * const profile = await prisma.profile.upsert({
     *   create: {
     *     // ... data to create a Profile
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Profile we want to update
     *   }
     * })
    **/
    upsert<T extends profileUpsertArgs<ExtArgs>>(
      args: SelectSubset<T, profileUpsertArgs<ExtArgs>>
    ): Prisma__profileClient<$Result.GetResult<Prisma.$profilePayload<ExtArgs>, T, 'upsert'>, never, ExtArgs>

    /**
     * Count the number of Profiles.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {profileCountArgs} args - Arguments to filter Profiles to count.
     * @example
     * // Count the number of Profiles
     * const count = await prisma.profile.count({
     *   where: {
     *     // ... the filter for the Profiles we want to count
     *   }
     * })
    **/
    count<T extends profileCountArgs>(
      args?: Subset<T, profileCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ProfileCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Profile.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProfileAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ProfileAggregateArgs>(args: Subset<T, ProfileAggregateArgs>): Prisma.PrismaPromise<GetProfileAggregateType<T>>

    /**
     * Group by Profile.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {profileGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends profileGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: profileGroupByArgs['orderBy'] }
        : { orderBy?: profileGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, profileGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetProfileGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the profile model
   */
  readonly fields: profileFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for profile.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__profileClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: 'PrismaPromise';

    avatar<T extends profile$avatarArgs<ExtArgs> = {}>(args?: Subset<T, profile$avatarArgs<ExtArgs>>): Prisma__avatarClient<$Result.GetResult<Prisma.$avatarPayload<ExtArgs>, T, 'findUniqueOrThrow'> | null, null, ExtArgs>;

    user<T extends profile$userArgs<ExtArgs> = {}>(args?: Subset<T, profile$userArgs<ExtArgs>>): Prisma__userClient<$Result.GetResult<Prisma.$userPayload<ExtArgs>, T, 'findUniqueOrThrow'> | null, null, ExtArgs>;

    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>;
  }



  /**
   * Fields of the profile model
   */ 
  interface profileFieldRefs {
    readonly profileID: FieldRef<"profile", 'String'>
    readonly firstname: FieldRef<"profile", 'String'>
    readonly lastname: FieldRef<"profile", 'String'>
    readonly phone: FieldRef<"profile", 'String'>
    readonly designation: FieldRef<"profile", 'String'>
    readonly expertise: FieldRef<"profile", 'String'>
    readonly emergencyPhone: FieldRef<"profile", 'String'>
    readonly userID: FieldRef<"profile", 'String'>
  }
    

  // Custom InputTypes

  /**
   * profile findUnique
   */
  export type profileFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the profile
     */
    select?: profileSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: profileInclude<ExtArgs> | null
    /**
     * Filter, which profile to fetch.
     */
    where: profileWhereUniqueInput
  }


  /**
   * profile findUniqueOrThrow
   */
  export type profileFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the profile
     */
    select?: profileSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: profileInclude<ExtArgs> | null
    /**
     * Filter, which profile to fetch.
     */
    where: profileWhereUniqueInput
  }


  /**
   * profile findFirst
   */
  export type profileFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the profile
     */
    select?: profileSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: profileInclude<ExtArgs> | null
    /**
     * Filter, which profile to fetch.
     */
    where?: profileWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of profiles to fetch.
     */
    orderBy?: profileOrderByWithRelationInput | profileOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for profiles.
     */
    cursor?: profileWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` profiles from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` profiles.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of profiles.
     */
    distinct?: ProfileScalarFieldEnum | ProfileScalarFieldEnum[]
  }


  /**
   * profile findFirstOrThrow
   */
  export type profileFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the profile
     */
    select?: profileSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: profileInclude<ExtArgs> | null
    /**
     * Filter, which profile to fetch.
     */
    where?: profileWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of profiles to fetch.
     */
    orderBy?: profileOrderByWithRelationInput | profileOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for profiles.
     */
    cursor?: profileWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` profiles from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` profiles.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of profiles.
     */
    distinct?: ProfileScalarFieldEnum | ProfileScalarFieldEnum[]
  }


  /**
   * profile findMany
   */
  export type profileFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the profile
     */
    select?: profileSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: profileInclude<ExtArgs> | null
    /**
     * Filter, which profiles to fetch.
     */
    where?: profileWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of profiles to fetch.
     */
    orderBy?: profileOrderByWithRelationInput | profileOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing profiles.
     */
    cursor?: profileWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` profiles from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` profiles.
     */
    skip?: number
    distinct?: ProfileScalarFieldEnum | ProfileScalarFieldEnum[]
  }


  /**
   * profile create
   */
  export type profileCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the profile
     */
    select?: profileSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: profileInclude<ExtArgs> | null
    /**
     * The data needed to create a profile.
     */
    data: XOR<profileCreateInput, profileUncheckedCreateInput>
  }


  /**
   * profile createMany
   */
  export type profileCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many profiles.
     */
    data: profileCreateManyInput | profileCreateManyInput[]
    skipDuplicates?: boolean
  }


  /**
   * profile update
   */
  export type profileUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the profile
     */
    select?: profileSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: profileInclude<ExtArgs> | null
    /**
     * The data needed to update a profile.
     */
    data: XOR<profileUpdateInput, profileUncheckedUpdateInput>
    /**
     * Choose, which profile to update.
     */
    where: profileWhereUniqueInput
  }


  /**
   * profile updateMany
   */
  export type profileUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update profiles.
     */
    data: XOR<profileUpdateManyMutationInput, profileUncheckedUpdateManyInput>
    /**
     * Filter which profiles to update
     */
    where?: profileWhereInput
  }


  /**
   * profile upsert
   */
  export type profileUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the profile
     */
    select?: profileSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: profileInclude<ExtArgs> | null
    /**
     * The filter to search for the profile to update in case it exists.
     */
    where: profileWhereUniqueInput
    /**
     * In case the profile found by the `where` argument doesn't exist, create a new profile with this data.
     */
    create: XOR<profileCreateInput, profileUncheckedCreateInput>
    /**
     * In case the profile was found with the provided `where` argument, update it with this data.
     */
    update: XOR<profileUpdateInput, profileUncheckedUpdateInput>
  }


  /**
   * profile delete
   */
  export type profileDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the profile
     */
    select?: profileSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: profileInclude<ExtArgs> | null
    /**
     * Filter which profile to delete.
     */
    where: profileWhereUniqueInput
  }


  /**
   * profile deleteMany
   */
  export type profileDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which profiles to delete
     */
    where?: profileWhereInput
  }


  /**
   * profile.avatar
   */
  export type profile$avatarArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the avatar
     */
    select?: avatarSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: avatarInclude<ExtArgs> | null
    where?: avatarWhereInput
  }


  /**
   * profile.user
   */
  export type profile$userArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the user
     */
    select?: userSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: userInclude<ExtArgs> | null
    where?: userWhereInput
  }


  /**
   * profile without action
   */
  export type profileDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the profile
     */
    select?: profileSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: profileInclude<ExtArgs> | null
  }



  /**
   * Model diagnosis
   */

  export type AggregateDiagnosis = {
    _count: DiagnosisCountAggregateOutputType | null
    _min: DiagnosisMinAggregateOutputType | null
    _max: DiagnosisMaxAggregateOutputType | null
  }

  export type DiagnosisMinAggregateOutputType = {
    diagnosisID: string | null
    diagnosis: string | null
    createdAt: Date | null
    updatedAt: Date | null
    userID: string | null
  }

  export type DiagnosisMaxAggregateOutputType = {
    diagnosisID: string | null
    diagnosis: string | null
    createdAt: Date | null
    updatedAt: Date | null
    userID: string | null
  }

  export type DiagnosisCountAggregateOutputType = {
    diagnosisID: number
    diagnosis: number
    createdAt: number
    updatedAt: number
    userID: number
    _all: number
  }


  export type DiagnosisMinAggregateInputType = {
    diagnosisID?: true
    diagnosis?: true
    createdAt?: true
    updatedAt?: true
    userID?: true
  }

  export type DiagnosisMaxAggregateInputType = {
    diagnosisID?: true
    diagnosis?: true
    createdAt?: true
    updatedAt?: true
    userID?: true
  }

  export type DiagnosisCountAggregateInputType = {
    diagnosisID?: true
    diagnosis?: true
    createdAt?: true
    updatedAt?: true
    userID?: true
    _all?: true
  }

  export type DiagnosisAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which diagnosis to aggregate.
     */
    where?: diagnosisWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of diagnoses to fetch.
     */
    orderBy?: diagnosisOrderByWithRelationInput | diagnosisOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: diagnosisWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` diagnoses from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` diagnoses.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned diagnoses
    **/
    _count?: true | DiagnosisCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: DiagnosisMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: DiagnosisMaxAggregateInputType
  }

  export type GetDiagnosisAggregateType<T extends DiagnosisAggregateArgs> = {
        [P in keyof T & keyof AggregateDiagnosis]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateDiagnosis[P]>
      : GetScalarType<T[P], AggregateDiagnosis[P]>
  }




  export type diagnosisGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: diagnosisWhereInput
    orderBy?: diagnosisOrderByWithAggregationInput | diagnosisOrderByWithAggregationInput[]
    by: DiagnosisScalarFieldEnum[] | DiagnosisScalarFieldEnum
    having?: diagnosisScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: DiagnosisCountAggregateInputType | true
    _min?: DiagnosisMinAggregateInputType
    _max?: DiagnosisMaxAggregateInputType
  }

  export type DiagnosisGroupByOutputType = {
    diagnosisID: string
    diagnosis: string
    createdAt: Date
    updatedAt: Date
    userID: string | null
    _count: DiagnosisCountAggregateOutputType | null
    _min: DiagnosisMinAggregateOutputType | null
    _max: DiagnosisMaxAggregateOutputType | null
  }

  type GetDiagnosisGroupByPayload<T extends diagnosisGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<DiagnosisGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof DiagnosisGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], DiagnosisGroupByOutputType[P]>
            : GetScalarType<T[P], DiagnosisGroupByOutputType[P]>
        }
      >
    >


  export type diagnosisSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    diagnosisID?: boolean
    diagnosis?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    userID?: boolean
    user?: boolean | diagnosis$userArgs<ExtArgs>
  }, ExtArgs["result"]["diagnosis"]>

  export type diagnosisSelectScalar = {
    diagnosisID?: boolean
    diagnosis?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    userID?: boolean
  }

  export type diagnosisInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | diagnosis$userArgs<ExtArgs>
  }


  export type $diagnosisPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "diagnosis"
    objects: {
      user: Prisma.$userPayload<ExtArgs> | null
    }
    scalars: $Extensions.GetPayloadResult<{
      diagnosisID: string
      diagnosis: string
      createdAt: Date
      updatedAt: Date
      userID: string | null
    }, ExtArgs["result"]["diagnosis"]>
    composites: {}
  }


  type diagnosisGetPayload<S extends boolean | null | undefined | diagnosisDefaultArgs> = $Result.GetResult<Prisma.$diagnosisPayload, S>

  type diagnosisCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<diagnosisFindManyArgs, 'select' | 'include' | 'distinct' > & {
      select?: DiagnosisCountAggregateInputType | true
    }

  export interface diagnosisDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['diagnosis'], meta: { name: 'diagnosis' } }
    /**
     * Find zero or one Diagnosis that matches the filter.
     * @param {diagnosisFindUniqueArgs} args - Arguments to find a Diagnosis
     * @example
     * // Get one Diagnosis
     * const diagnosis = await prisma.diagnosis.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends diagnosisFindUniqueArgs<ExtArgs>>(
      args: SelectSubset<T, diagnosisFindUniqueArgs<ExtArgs>>
    ): Prisma__diagnosisClient<$Result.GetResult<Prisma.$diagnosisPayload<ExtArgs>, T, 'findUnique'> | null, null, ExtArgs>

    /**
     * Find one Diagnosis that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {diagnosisFindUniqueOrThrowArgs} args - Arguments to find a Diagnosis
     * @example
     * // Get one Diagnosis
     * const diagnosis = await prisma.diagnosis.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends diagnosisFindUniqueOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, diagnosisFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__diagnosisClient<$Result.GetResult<Prisma.$diagnosisPayload<ExtArgs>, T, 'findUniqueOrThrow'>, never, ExtArgs>

    /**
     * Find the first Diagnosis that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {diagnosisFindFirstArgs} args - Arguments to find a Diagnosis
     * @example
     * // Get one Diagnosis
     * const diagnosis = await prisma.diagnosis.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends diagnosisFindFirstArgs<ExtArgs>>(
      args?: SelectSubset<T, diagnosisFindFirstArgs<ExtArgs>>
    ): Prisma__diagnosisClient<$Result.GetResult<Prisma.$diagnosisPayload<ExtArgs>, T, 'findFirst'> | null, null, ExtArgs>

    /**
     * Find the first Diagnosis that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {diagnosisFindFirstOrThrowArgs} args - Arguments to find a Diagnosis
     * @example
     * // Get one Diagnosis
     * const diagnosis = await prisma.diagnosis.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends diagnosisFindFirstOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, diagnosisFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__diagnosisClient<$Result.GetResult<Prisma.$diagnosisPayload<ExtArgs>, T, 'findFirstOrThrow'>, never, ExtArgs>

    /**
     * Find zero or more Diagnoses that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {diagnosisFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Diagnoses
     * const diagnoses = await prisma.diagnosis.findMany()
     * 
     * // Get first 10 Diagnoses
     * const diagnoses = await prisma.diagnosis.findMany({ take: 10 })
     * 
     * // Only select the `diagnosisID`
     * const diagnosisWithDiagnosisIDOnly = await prisma.diagnosis.findMany({ select: { diagnosisID: true } })
     * 
    **/
    findMany<T extends diagnosisFindManyArgs<ExtArgs>>(
      args?: SelectSubset<T, diagnosisFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<$Result.GetResult<Prisma.$diagnosisPayload<ExtArgs>, T, 'findMany'>>

    /**
     * Create a Diagnosis.
     * @param {diagnosisCreateArgs} args - Arguments to create a Diagnosis.
     * @example
     * // Create one Diagnosis
     * const Diagnosis = await prisma.diagnosis.create({
     *   data: {
     *     // ... data to create a Diagnosis
     *   }
     * })
     * 
    **/
    create<T extends diagnosisCreateArgs<ExtArgs>>(
      args: SelectSubset<T, diagnosisCreateArgs<ExtArgs>>
    ): Prisma__diagnosisClient<$Result.GetResult<Prisma.$diagnosisPayload<ExtArgs>, T, 'create'>, never, ExtArgs>

    /**
     * Create many Diagnoses.
     *     @param {diagnosisCreateManyArgs} args - Arguments to create many Diagnoses.
     *     @example
     *     // Create many Diagnoses
     *     const diagnosis = await prisma.diagnosis.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends diagnosisCreateManyArgs<ExtArgs>>(
      args?: SelectSubset<T, diagnosisCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Diagnosis.
     * @param {diagnosisDeleteArgs} args - Arguments to delete one Diagnosis.
     * @example
     * // Delete one Diagnosis
     * const Diagnosis = await prisma.diagnosis.delete({
     *   where: {
     *     // ... filter to delete one Diagnosis
     *   }
     * })
     * 
    **/
    delete<T extends diagnosisDeleteArgs<ExtArgs>>(
      args: SelectSubset<T, diagnosisDeleteArgs<ExtArgs>>
    ): Prisma__diagnosisClient<$Result.GetResult<Prisma.$diagnosisPayload<ExtArgs>, T, 'delete'>, never, ExtArgs>

    /**
     * Update one Diagnosis.
     * @param {diagnosisUpdateArgs} args - Arguments to update one Diagnosis.
     * @example
     * // Update one Diagnosis
     * const diagnosis = await prisma.diagnosis.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends diagnosisUpdateArgs<ExtArgs>>(
      args: SelectSubset<T, diagnosisUpdateArgs<ExtArgs>>
    ): Prisma__diagnosisClient<$Result.GetResult<Prisma.$diagnosisPayload<ExtArgs>, T, 'update'>, never, ExtArgs>

    /**
     * Delete zero or more Diagnoses.
     * @param {diagnosisDeleteManyArgs} args - Arguments to filter Diagnoses to delete.
     * @example
     * // Delete a few Diagnoses
     * const { count } = await prisma.diagnosis.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends diagnosisDeleteManyArgs<ExtArgs>>(
      args?: SelectSubset<T, diagnosisDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Diagnoses.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {diagnosisUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Diagnoses
     * const diagnosis = await prisma.diagnosis.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends diagnosisUpdateManyArgs<ExtArgs>>(
      args: SelectSubset<T, diagnosisUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Diagnosis.
     * @param {diagnosisUpsertArgs} args - Arguments to update or create a Diagnosis.
     * @example
     * // Update or create a Diagnosis
     * const diagnosis = await prisma.diagnosis.upsert({
     *   create: {
     *     // ... data to create a Diagnosis
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Diagnosis we want to update
     *   }
     * })
    **/
    upsert<T extends diagnosisUpsertArgs<ExtArgs>>(
      args: SelectSubset<T, diagnosisUpsertArgs<ExtArgs>>
    ): Prisma__diagnosisClient<$Result.GetResult<Prisma.$diagnosisPayload<ExtArgs>, T, 'upsert'>, never, ExtArgs>

    /**
     * Count the number of Diagnoses.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {diagnosisCountArgs} args - Arguments to filter Diagnoses to count.
     * @example
     * // Count the number of Diagnoses
     * const count = await prisma.diagnosis.count({
     *   where: {
     *     // ... the filter for the Diagnoses we want to count
     *   }
     * })
    **/
    count<T extends diagnosisCountArgs>(
      args?: Subset<T, diagnosisCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], DiagnosisCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Diagnosis.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DiagnosisAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends DiagnosisAggregateArgs>(args: Subset<T, DiagnosisAggregateArgs>): Prisma.PrismaPromise<GetDiagnosisAggregateType<T>>

    /**
     * Group by Diagnosis.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {diagnosisGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends diagnosisGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: diagnosisGroupByArgs['orderBy'] }
        : { orderBy?: diagnosisGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, diagnosisGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetDiagnosisGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the diagnosis model
   */
  readonly fields: diagnosisFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for diagnosis.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__diagnosisClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: 'PrismaPromise';

    user<T extends diagnosis$userArgs<ExtArgs> = {}>(args?: Subset<T, diagnosis$userArgs<ExtArgs>>): Prisma__userClient<$Result.GetResult<Prisma.$userPayload<ExtArgs>, T, 'findUniqueOrThrow'> | null, null, ExtArgs>;

    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>;
  }



  /**
   * Fields of the diagnosis model
   */ 
  interface diagnosisFieldRefs {
    readonly diagnosisID: FieldRef<"diagnosis", 'String'>
    readonly diagnosis: FieldRef<"diagnosis", 'String'>
    readonly createdAt: FieldRef<"diagnosis", 'DateTime'>
    readonly updatedAt: FieldRef<"diagnosis", 'DateTime'>
    readonly userID: FieldRef<"diagnosis", 'String'>
  }
    

  // Custom InputTypes

  /**
   * diagnosis findUnique
   */
  export type diagnosisFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the diagnosis
     */
    select?: diagnosisSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: diagnosisInclude<ExtArgs> | null
    /**
     * Filter, which diagnosis to fetch.
     */
    where: diagnosisWhereUniqueInput
  }


  /**
   * diagnosis findUniqueOrThrow
   */
  export type diagnosisFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the diagnosis
     */
    select?: diagnosisSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: diagnosisInclude<ExtArgs> | null
    /**
     * Filter, which diagnosis to fetch.
     */
    where: diagnosisWhereUniqueInput
  }


  /**
   * diagnosis findFirst
   */
  export type diagnosisFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the diagnosis
     */
    select?: diagnosisSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: diagnosisInclude<ExtArgs> | null
    /**
     * Filter, which diagnosis to fetch.
     */
    where?: diagnosisWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of diagnoses to fetch.
     */
    orderBy?: diagnosisOrderByWithRelationInput | diagnosisOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for diagnoses.
     */
    cursor?: diagnosisWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` diagnoses from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` diagnoses.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of diagnoses.
     */
    distinct?: DiagnosisScalarFieldEnum | DiagnosisScalarFieldEnum[]
  }


  /**
   * diagnosis findFirstOrThrow
   */
  export type diagnosisFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the diagnosis
     */
    select?: diagnosisSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: diagnosisInclude<ExtArgs> | null
    /**
     * Filter, which diagnosis to fetch.
     */
    where?: diagnosisWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of diagnoses to fetch.
     */
    orderBy?: diagnosisOrderByWithRelationInput | diagnosisOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for diagnoses.
     */
    cursor?: diagnosisWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` diagnoses from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` diagnoses.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of diagnoses.
     */
    distinct?: DiagnosisScalarFieldEnum | DiagnosisScalarFieldEnum[]
  }


  /**
   * diagnosis findMany
   */
  export type diagnosisFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the diagnosis
     */
    select?: diagnosisSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: diagnosisInclude<ExtArgs> | null
    /**
     * Filter, which diagnoses to fetch.
     */
    where?: diagnosisWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of diagnoses to fetch.
     */
    orderBy?: diagnosisOrderByWithRelationInput | diagnosisOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing diagnoses.
     */
    cursor?: diagnosisWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` diagnoses from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` diagnoses.
     */
    skip?: number
    distinct?: DiagnosisScalarFieldEnum | DiagnosisScalarFieldEnum[]
  }


  /**
   * diagnosis create
   */
  export type diagnosisCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the diagnosis
     */
    select?: diagnosisSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: diagnosisInclude<ExtArgs> | null
    /**
     * The data needed to create a diagnosis.
     */
    data?: XOR<diagnosisCreateInput, diagnosisUncheckedCreateInput>
  }


  /**
   * diagnosis createMany
   */
  export type diagnosisCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many diagnoses.
     */
    data: diagnosisCreateManyInput | diagnosisCreateManyInput[]
    skipDuplicates?: boolean
  }


  /**
   * diagnosis update
   */
  export type diagnosisUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the diagnosis
     */
    select?: diagnosisSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: diagnosisInclude<ExtArgs> | null
    /**
     * The data needed to update a diagnosis.
     */
    data: XOR<diagnosisUpdateInput, diagnosisUncheckedUpdateInput>
    /**
     * Choose, which diagnosis to update.
     */
    where: diagnosisWhereUniqueInput
  }


  /**
   * diagnosis updateMany
   */
  export type diagnosisUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update diagnoses.
     */
    data: XOR<diagnosisUpdateManyMutationInput, diagnosisUncheckedUpdateManyInput>
    /**
     * Filter which diagnoses to update
     */
    where?: diagnosisWhereInput
  }


  /**
   * diagnosis upsert
   */
  export type diagnosisUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the diagnosis
     */
    select?: diagnosisSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: diagnosisInclude<ExtArgs> | null
    /**
     * The filter to search for the diagnosis to update in case it exists.
     */
    where: diagnosisWhereUniqueInput
    /**
     * In case the diagnosis found by the `where` argument doesn't exist, create a new diagnosis with this data.
     */
    create: XOR<diagnosisCreateInput, diagnosisUncheckedCreateInput>
    /**
     * In case the diagnosis was found with the provided `where` argument, update it with this data.
     */
    update: XOR<diagnosisUpdateInput, diagnosisUncheckedUpdateInput>
  }


  /**
   * diagnosis delete
   */
  export type diagnosisDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the diagnosis
     */
    select?: diagnosisSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: diagnosisInclude<ExtArgs> | null
    /**
     * Filter which diagnosis to delete.
     */
    where: diagnosisWhereUniqueInput
  }


  /**
   * diagnosis deleteMany
   */
  export type diagnosisDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which diagnoses to delete
     */
    where?: diagnosisWhereInput
  }


  /**
   * diagnosis.user
   */
  export type diagnosis$userArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the user
     */
    select?: userSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: userInclude<ExtArgs> | null
    where?: userWhereInput
  }


  /**
   * diagnosis without action
   */
  export type diagnosisDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the diagnosis
     */
    select?: diagnosisSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: diagnosisInclude<ExtArgs> | null
  }



  /**
   * Model presciption
   */

  export type AggregatePresciption = {
    _count: PresciptionCountAggregateOutputType | null
    _min: PresciptionMinAggregateOutputType | null
    _max: PresciptionMaxAggregateOutputType | null
  }

  export type PresciptionMinAggregateOutputType = {
    prescriptionID: string | null
    prescription: string | null
    createdAt: Date | null
    updatedAt: Date | null
    userID: string | null
  }

  export type PresciptionMaxAggregateOutputType = {
    prescriptionID: string | null
    prescription: string | null
    createdAt: Date | null
    updatedAt: Date | null
    userID: string | null
  }

  export type PresciptionCountAggregateOutputType = {
    prescriptionID: number
    prescription: number
    createdAt: number
    updatedAt: number
    userID: number
    _all: number
  }


  export type PresciptionMinAggregateInputType = {
    prescriptionID?: true
    prescription?: true
    createdAt?: true
    updatedAt?: true
    userID?: true
  }

  export type PresciptionMaxAggregateInputType = {
    prescriptionID?: true
    prescription?: true
    createdAt?: true
    updatedAt?: true
    userID?: true
  }

  export type PresciptionCountAggregateInputType = {
    prescriptionID?: true
    prescription?: true
    createdAt?: true
    updatedAt?: true
    userID?: true
    _all?: true
  }

  export type PresciptionAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which presciption to aggregate.
     */
    where?: presciptionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of presciptions to fetch.
     */
    orderBy?: presciptionOrderByWithRelationInput | presciptionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: presciptionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` presciptions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` presciptions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned presciptions
    **/
    _count?: true | PresciptionCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: PresciptionMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: PresciptionMaxAggregateInputType
  }

  export type GetPresciptionAggregateType<T extends PresciptionAggregateArgs> = {
        [P in keyof T & keyof AggregatePresciption]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregatePresciption[P]>
      : GetScalarType<T[P], AggregatePresciption[P]>
  }




  export type presciptionGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: presciptionWhereInput
    orderBy?: presciptionOrderByWithAggregationInput | presciptionOrderByWithAggregationInput[]
    by: PresciptionScalarFieldEnum[] | PresciptionScalarFieldEnum
    having?: presciptionScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: PresciptionCountAggregateInputType | true
    _min?: PresciptionMinAggregateInputType
    _max?: PresciptionMaxAggregateInputType
  }

  export type PresciptionGroupByOutputType = {
    prescriptionID: string
    prescription: string
    createdAt: Date
    updatedAt: Date
    userID: string | null
    _count: PresciptionCountAggregateOutputType | null
    _min: PresciptionMinAggregateOutputType | null
    _max: PresciptionMaxAggregateOutputType | null
  }

  type GetPresciptionGroupByPayload<T extends presciptionGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<PresciptionGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof PresciptionGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], PresciptionGroupByOutputType[P]>
            : GetScalarType<T[P], PresciptionGroupByOutputType[P]>
        }
      >
    >


  export type presciptionSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    prescriptionID?: boolean
    prescription?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    userID?: boolean
    patinet?: boolean | presciption$patinetArgs<ExtArgs>
  }, ExtArgs["result"]["presciption"]>

  export type presciptionSelectScalar = {
    prescriptionID?: boolean
    prescription?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    userID?: boolean
  }

  export type presciptionInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    patinet?: boolean | presciption$patinetArgs<ExtArgs>
  }


  export type $presciptionPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "presciption"
    objects: {
      patinet: Prisma.$userPayload<ExtArgs> | null
    }
    scalars: $Extensions.GetPayloadResult<{
      prescriptionID: string
      prescription: string
      createdAt: Date
      updatedAt: Date
      userID: string | null
    }, ExtArgs["result"]["presciption"]>
    composites: {}
  }


  type presciptionGetPayload<S extends boolean | null | undefined | presciptionDefaultArgs> = $Result.GetResult<Prisma.$presciptionPayload, S>

  type presciptionCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<presciptionFindManyArgs, 'select' | 'include' | 'distinct' > & {
      select?: PresciptionCountAggregateInputType | true
    }

  export interface presciptionDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['presciption'], meta: { name: 'presciption' } }
    /**
     * Find zero or one Presciption that matches the filter.
     * @param {presciptionFindUniqueArgs} args - Arguments to find a Presciption
     * @example
     * // Get one Presciption
     * const presciption = await prisma.presciption.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends presciptionFindUniqueArgs<ExtArgs>>(
      args: SelectSubset<T, presciptionFindUniqueArgs<ExtArgs>>
    ): Prisma__presciptionClient<$Result.GetResult<Prisma.$presciptionPayload<ExtArgs>, T, 'findUnique'> | null, null, ExtArgs>

    /**
     * Find one Presciption that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {presciptionFindUniqueOrThrowArgs} args - Arguments to find a Presciption
     * @example
     * // Get one Presciption
     * const presciption = await prisma.presciption.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends presciptionFindUniqueOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, presciptionFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__presciptionClient<$Result.GetResult<Prisma.$presciptionPayload<ExtArgs>, T, 'findUniqueOrThrow'>, never, ExtArgs>

    /**
     * Find the first Presciption that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {presciptionFindFirstArgs} args - Arguments to find a Presciption
     * @example
     * // Get one Presciption
     * const presciption = await prisma.presciption.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends presciptionFindFirstArgs<ExtArgs>>(
      args?: SelectSubset<T, presciptionFindFirstArgs<ExtArgs>>
    ): Prisma__presciptionClient<$Result.GetResult<Prisma.$presciptionPayload<ExtArgs>, T, 'findFirst'> | null, null, ExtArgs>

    /**
     * Find the first Presciption that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {presciptionFindFirstOrThrowArgs} args - Arguments to find a Presciption
     * @example
     * // Get one Presciption
     * const presciption = await prisma.presciption.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends presciptionFindFirstOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, presciptionFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__presciptionClient<$Result.GetResult<Prisma.$presciptionPayload<ExtArgs>, T, 'findFirstOrThrow'>, never, ExtArgs>

    /**
     * Find zero or more Presciptions that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {presciptionFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Presciptions
     * const presciptions = await prisma.presciption.findMany()
     * 
     * // Get first 10 Presciptions
     * const presciptions = await prisma.presciption.findMany({ take: 10 })
     * 
     * // Only select the `prescriptionID`
     * const presciptionWithPrescriptionIDOnly = await prisma.presciption.findMany({ select: { prescriptionID: true } })
     * 
    **/
    findMany<T extends presciptionFindManyArgs<ExtArgs>>(
      args?: SelectSubset<T, presciptionFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<$Result.GetResult<Prisma.$presciptionPayload<ExtArgs>, T, 'findMany'>>

    /**
     * Create a Presciption.
     * @param {presciptionCreateArgs} args - Arguments to create a Presciption.
     * @example
     * // Create one Presciption
     * const Presciption = await prisma.presciption.create({
     *   data: {
     *     // ... data to create a Presciption
     *   }
     * })
     * 
    **/
    create<T extends presciptionCreateArgs<ExtArgs>>(
      args: SelectSubset<T, presciptionCreateArgs<ExtArgs>>
    ): Prisma__presciptionClient<$Result.GetResult<Prisma.$presciptionPayload<ExtArgs>, T, 'create'>, never, ExtArgs>

    /**
     * Create many Presciptions.
     *     @param {presciptionCreateManyArgs} args - Arguments to create many Presciptions.
     *     @example
     *     // Create many Presciptions
     *     const presciption = await prisma.presciption.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends presciptionCreateManyArgs<ExtArgs>>(
      args?: SelectSubset<T, presciptionCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Presciption.
     * @param {presciptionDeleteArgs} args - Arguments to delete one Presciption.
     * @example
     * // Delete one Presciption
     * const Presciption = await prisma.presciption.delete({
     *   where: {
     *     // ... filter to delete one Presciption
     *   }
     * })
     * 
    **/
    delete<T extends presciptionDeleteArgs<ExtArgs>>(
      args: SelectSubset<T, presciptionDeleteArgs<ExtArgs>>
    ): Prisma__presciptionClient<$Result.GetResult<Prisma.$presciptionPayload<ExtArgs>, T, 'delete'>, never, ExtArgs>

    /**
     * Update one Presciption.
     * @param {presciptionUpdateArgs} args - Arguments to update one Presciption.
     * @example
     * // Update one Presciption
     * const presciption = await prisma.presciption.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends presciptionUpdateArgs<ExtArgs>>(
      args: SelectSubset<T, presciptionUpdateArgs<ExtArgs>>
    ): Prisma__presciptionClient<$Result.GetResult<Prisma.$presciptionPayload<ExtArgs>, T, 'update'>, never, ExtArgs>

    /**
     * Delete zero or more Presciptions.
     * @param {presciptionDeleteManyArgs} args - Arguments to filter Presciptions to delete.
     * @example
     * // Delete a few Presciptions
     * const { count } = await prisma.presciption.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends presciptionDeleteManyArgs<ExtArgs>>(
      args?: SelectSubset<T, presciptionDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Presciptions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {presciptionUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Presciptions
     * const presciption = await prisma.presciption.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends presciptionUpdateManyArgs<ExtArgs>>(
      args: SelectSubset<T, presciptionUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Presciption.
     * @param {presciptionUpsertArgs} args - Arguments to update or create a Presciption.
     * @example
     * // Update or create a Presciption
     * const presciption = await prisma.presciption.upsert({
     *   create: {
     *     // ... data to create a Presciption
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Presciption we want to update
     *   }
     * })
    **/
    upsert<T extends presciptionUpsertArgs<ExtArgs>>(
      args: SelectSubset<T, presciptionUpsertArgs<ExtArgs>>
    ): Prisma__presciptionClient<$Result.GetResult<Prisma.$presciptionPayload<ExtArgs>, T, 'upsert'>, never, ExtArgs>

    /**
     * Count the number of Presciptions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {presciptionCountArgs} args - Arguments to filter Presciptions to count.
     * @example
     * // Count the number of Presciptions
     * const count = await prisma.presciption.count({
     *   where: {
     *     // ... the filter for the Presciptions we want to count
     *   }
     * })
    **/
    count<T extends presciptionCountArgs>(
      args?: Subset<T, presciptionCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], PresciptionCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Presciption.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PresciptionAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends PresciptionAggregateArgs>(args: Subset<T, PresciptionAggregateArgs>): Prisma.PrismaPromise<GetPresciptionAggregateType<T>>

    /**
     * Group by Presciption.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {presciptionGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends presciptionGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: presciptionGroupByArgs['orderBy'] }
        : { orderBy?: presciptionGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, presciptionGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetPresciptionGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the presciption model
   */
  readonly fields: presciptionFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for presciption.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__presciptionClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: 'PrismaPromise';

    patinet<T extends presciption$patinetArgs<ExtArgs> = {}>(args?: Subset<T, presciption$patinetArgs<ExtArgs>>): Prisma__userClient<$Result.GetResult<Prisma.$userPayload<ExtArgs>, T, 'findUniqueOrThrow'> | null, null, ExtArgs>;

    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>;
  }



  /**
   * Fields of the presciption model
   */ 
  interface presciptionFieldRefs {
    readonly prescriptionID: FieldRef<"presciption", 'String'>
    readonly prescription: FieldRef<"presciption", 'String'>
    readonly createdAt: FieldRef<"presciption", 'DateTime'>
    readonly updatedAt: FieldRef<"presciption", 'DateTime'>
    readonly userID: FieldRef<"presciption", 'String'>
  }
    

  // Custom InputTypes

  /**
   * presciption findUnique
   */
  export type presciptionFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the presciption
     */
    select?: presciptionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: presciptionInclude<ExtArgs> | null
    /**
     * Filter, which presciption to fetch.
     */
    where: presciptionWhereUniqueInput
  }


  /**
   * presciption findUniqueOrThrow
   */
  export type presciptionFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the presciption
     */
    select?: presciptionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: presciptionInclude<ExtArgs> | null
    /**
     * Filter, which presciption to fetch.
     */
    where: presciptionWhereUniqueInput
  }


  /**
   * presciption findFirst
   */
  export type presciptionFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the presciption
     */
    select?: presciptionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: presciptionInclude<ExtArgs> | null
    /**
     * Filter, which presciption to fetch.
     */
    where?: presciptionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of presciptions to fetch.
     */
    orderBy?: presciptionOrderByWithRelationInput | presciptionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for presciptions.
     */
    cursor?: presciptionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` presciptions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` presciptions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of presciptions.
     */
    distinct?: PresciptionScalarFieldEnum | PresciptionScalarFieldEnum[]
  }


  /**
   * presciption findFirstOrThrow
   */
  export type presciptionFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the presciption
     */
    select?: presciptionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: presciptionInclude<ExtArgs> | null
    /**
     * Filter, which presciption to fetch.
     */
    where?: presciptionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of presciptions to fetch.
     */
    orderBy?: presciptionOrderByWithRelationInput | presciptionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for presciptions.
     */
    cursor?: presciptionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` presciptions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` presciptions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of presciptions.
     */
    distinct?: PresciptionScalarFieldEnum | PresciptionScalarFieldEnum[]
  }


  /**
   * presciption findMany
   */
  export type presciptionFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the presciption
     */
    select?: presciptionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: presciptionInclude<ExtArgs> | null
    /**
     * Filter, which presciptions to fetch.
     */
    where?: presciptionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of presciptions to fetch.
     */
    orderBy?: presciptionOrderByWithRelationInput | presciptionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing presciptions.
     */
    cursor?: presciptionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` presciptions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` presciptions.
     */
    skip?: number
    distinct?: PresciptionScalarFieldEnum | PresciptionScalarFieldEnum[]
  }


  /**
   * presciption create
   */
  export type presciptionCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the presciption
     */
    select?: presciptionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: presciptionInclude<ExtArgs> | null
    /**
     * The data needed to create a presciption.
     */
    data: XOR<presciptionCreateInput, presciptionUncheckedCreateInput>
  }


  /**
   * presciption createMany
   */
  export type presciptionCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many presciptions.
     */
    data: presciptionCreateManyInput | presciptionCreateManyInput[]
    skipDuplicates?: boolean
  }


  /**
   * presciption update
   */
  export type presciptionUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the presciption
     */
    select?: presciptionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: presciptionInclude<ExtArgs> | null
    /**
     * The data needed to update a presciption.
     */
    data: XOR<presciptionUpdateInput, presciptionUncheckedUpdateInput>
    /**
     * Choose, which presciption to update.
     */
    where: presciptionWhereUniqueInput
  }


  /**
   * presciption updateMany
   */
  export type presciptionUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update presciptions.
     */
    data: XOR<presciptionUpdateManyMutationInput, presciptionUncheckedUpdateManyInput>
    /**
     * Filter which presciptions to update
     */
    where?: presciptionWhereInput
  }


  /**
   * presciption upsert
   */
  export type presciptionUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the presciption
     */
    select?: presciptionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: presciptionInclude<ExtArgs> | null
    /**
     * The filter to search for the presciption to update in case it exists.
     */
    where: presciptionWhereUniqueInput
    /**
     * In case the presciption found by the `where` argument doesn't exist, create a new presciption with this data.
     */
    create: XOR<presciptionCreateInput, presciptionUncheckedCreateInput>
    /**
     * In case the presciption was found with the provided `where` argument, update it with this data.
     */
    update: XOR<presciptionUpdateInput, presciptionUncheckedUpdateInput>
  }


  /**
   * presciption delete
   */
  export type presciptionDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the presciption
     */
    select?: presciptionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: presciptionInclude<ExtArgs> | null
    /**
     * Filter which presciption to delete.
     */
    where: presciptionWhereUniqueInput
  }


  /**
   * presciption deleteMany
   */
  export type presciptionDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which presciptions to delete
     */
    where?: presciptionWhereInput
  }


  /**
   * presciption.patinet
   */
  export type presciption$patinetArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the user
     */
    select?: userSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: userInclude<ExtArgs> | null
    where?: userWhereInput
  }


  /**
   * presciption without action
   */
  export type presciptionDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the presciption
     */
    select?: presciptionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: presciptionInclude<ExtArgs> | null
  }



  /**
   * Model feedback
   */

  export type AggregateFeedback = {
    _count: FeedbackCountAggregateOutputType | null
    _avg: FeedbackAvgAggregateOutputType | null
    _sum: FeedbackSumAggregateOutputType | null
    _min: FeedbackMinAggregateOutputType | null
    _max: FeedbackMaxAggregateOutputType | null
  }

  export type FeedbackAvgAggregateOutputType = {
    rating: number | null
  }

  export type FeedbackSumAggregateOutputType = {
    rating: number | null
  }

  export type FeedbackMinAggregateOutputType = {
    feedbackID: string | null
    therapistName: string | null
    date: string | null
    time: string | null
    question1: string | null
    question2: string | null
    question3: string | null
    question4: string | null
    question5: string | null
    question6: string | null
    question7: string | null
    question8: string | null
    feedback: string | null
    rating: number | null
    creatdAt: Date | null
    updatedAt: Date | null
  }

  export type FeedbackMaxAggregateOutputType = {
    feedbackID: string | null
    therapistName: string | null
    date: string | null
    time: string | null
    question1: string | null
    question2: string | null
    question3: string | null
    question4: string | null
    question5: string | null
    question6: string | null
    question7: string | null
    question8: string | null
    feedback: string | null
    rating: number | null
    creatdAt: Date | null
    updatedAt: Date | null
  }

  export type FeedbackCountAggregateOutputType = {
    feedbackID: number
    therapistName: number
    date: number
    time: number
    question1: number
    question2: number
    question3: number
    question4: number
    question5: number
    question6: number
    question7: number
    question8: number
    feedback: number
    rating: number
    creatdAt: number
    updatedAt: number
    _all: number
  }


  export type FeedbackAvgAggregateInputType = {
    rating?: true
  }

  export type FeedbackSumAggregateInputType = {
    rating?: true
  }

  export type FeedbackMinAggregateInputType = {
    feedbackID?: true
    therapistName?: true
    date?: true
    time?: true
    question1?: true
    question2?: true
    question3?: true
    question4?: true
    question5?: true
    question6?: true
    question7?: true
    question8?: true
    feedback?: true
    rating?: true
    creatdAt?: true
    updatedAt?: true
  }

  export type FeedbackMaxAggregateInputType = {
    feedbackID?: true
    therapistName?: true
    date?: true
    time?: true
    question1?: true
    question2?: true
    question3?: true
    question4?: true
    question5?: true
    question6?: true
    question7?: true
    question8?: true
    feedback?: true
    rating?: true
    creatdAt?: true
    updatedAt?: true
  }

  export type FeedbackCountAggregateInputType = {
    feedbackID?: true
    therapistName?: true
    date?: true
    time?: true
    question1?: true
    question2?: true
    question3?: true
    question4?: true
    question5?: true
    question6?: true
    question7?: true
    question8?: true
    feedback?: true
    rating?: true
    creatdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type FeedbackAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which feedback to aggregate.
     */
    where?: feedbackWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of feedbacks to fetch.
     */
    orderBy?: feedbackOrderByWithRelationInput | feedbackOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: feedbackWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` feedbacks from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` feedbacks.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned feedbacks
    **/
    _count?: true | FeedbackCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: FeedbackAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: FeedbackSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: FeedbackMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: FeedbackMaxAggregateInputType
  }

  export type GetFeedbackAggregateType<T extends FeedbackAggregateArgs> = {
        [P in keyof T & keyof AggregateFeedback]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateFeedback[P]>
      : GetScalarType<T[P], AggregateFeedback[P]>
  }




  export type feedbackGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: feedbackWhereInput
    orderBy?: feedbackOrderByWithAggregationInput | feedbackOrderByWithAggregationInput[]
    by: FeedbackScalarFieldEnum[] | FeedbackScalarFieldEnum
    having?: feedbackScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: FeedbackCountAggregateInputType | true
    _avg?: FeedbackAvgAggregateInputType
    _sum?: FeedbackSumAggregateInputType
    _min?: FeedbackMinAggregateInputType
    _max?: FeedbackMaxAggregateInputType
  }

  export type FeedbackGroupByOutputType = {
    feedbackID: string
    therapistName: string
    date: string
    time: string
    question1: string
    question2: string
    question3: string
    question4: string
    question5: string
    question6: string
    question7: string
    question8: string
    feedback: string
    rating: number
    creatdAt: Date
    updatedAt: Date
    _count: FeedbackCountAggregateOutputType | null
    _avg: FeedbackAvgAggregateOutputType | null
    _sum: FeedbackSumAggregateOutputType | null
    _min: FeedbackMinAggregateOutputType | null
    _max: FeedbackMaxAggregateOutputType | null
  }

  type GetFeedbackGroupByPayload<T extends feedbackGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<FeedbackGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof FeedbackGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], FeedbackGroupByOutputType[P]>
            : GetScalarType<T[P], FeedbackGroupByOutputType[P]>
        }
      >
    >


  export type feedbackSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    feedbackID?: boolean
    therapistName?: boolean
    date?: boolean
    time?: boolean
    question1?: boolean
    question2?: boolean
    question3?: boolean
    question4?: boolean
    question5?: boolean
    question6?: boolean
    question7?: boolean
    question8?: boolean
    feedback?: boolean
    rating?: boolean
    creatdAt?: boolean
    updatedAt?: boolean
    appointment?: boolean | feedback$appointmentArgs<ExtArgs>
    user?: boolean | feedback$userArgs<ExtArgs>
    _count?: boolean | FeedbackCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["feedback"]>

  export type feedbackSelectScalar = {
    feedbackID?: boolean
    therapistName?: boolean
    date?: boolean
    time?: boolean
    question1?: boolean
    question2?: boolean
    question3?: boolean
    question4?: boolean
    question5?: boolean
    question6?: boolean
    question7?: boolean
    question8?: boolean
    feedback?: boolean
    rating?: boolean
    creatdAt?: boolean
    updatedAt?: boolean
  }

  export type feedbackInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    appointment?: boolean | feedback$appointmentArgs<ExtArgs>
    user?: boolean | feedback$userArgs<ExtArgs>
    _count?: boolean | FeedbackCountOutputTypeDefaultArgs<ExtArgs>
  }


  export type $feedbackPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "feedback"
    objects: {
      appointment: Prisma.$appointmentPayload<ExtArgs>[]
      user: Prisma.$userPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      feedbackID: string
      therapistName: string
      date: string
      time: string
      question1: string
      question2: string
      question3: string
      question4: string
      question5: string
      question6: string
      question7: string
      question8: string
      feedback: string
      rating: number
      creatdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["feedback"]>
    composites: {}
  }


  type feedbackGetPayload<S extends boolean | null | undefined | feedbackDefaultArgs> = $Result.GetResult<Prisma.$feedbackPayload, S>

  type feedbackCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<feedbackFindManyArgs, 'select' | 'include' | 'distinct' > & {
      select?: FeedbackCountAggregateInputType | true
    }

  export interface feedbackDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['feedback'], meta: { name: 'feedback' } }
    /**
     * Find zero or one Feedback that matches the filter.
     * @param {feedbackFindUniqueArgs} args - Arguments to find a Feedback
     * @example
     * // Get one Feedback
     * const feedback = await prisma.feedback.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends feedbackFindUniqueArgs<ExtArgs>>(
      args: SelectSubset<T, feedbackFindUniqueArgs<ExtArgs>>
    ): Prisma__feedbackClient<$Result.GetResult<Prisma.$feedbackPayload<ExtArgs>, T, 'findUnique'> | null, null, ExtArgs>

    /**
     * Find one Feedback that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {feedbackFindUniqueOrThrowArgs} args - Arguments to find a Feedback
     * @example
     * // Get one Feedback
     * const feedback = await prisma.feedback.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends feedbackFindUniqueOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, feedbackFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__feedbackClient<$Result.GetResult<Prisma.$feedbackPayload<ExtArgs>, T, 'findUniqueOrThrow'>, never, ExtArgs>

    /**
     * Find the first Feedback that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {feedbackFindFirstArgs} args - Arguments to find a Feedback
     * @example
     * // Get one Feedback
     * const feedback = await prisma.feedback.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends feedbackFindFirstArgs<ExtArgs>>(
      args?: SelectSubset<T, feedbackFindFirstArgs<ExtArgs>>
    ): Prisma__feedbackClient<$Result.GetResult<Prisma.$feedbackPayload<ExtArgs>, T, 'findFirst'> | null, null, ExtArgs>

    /**
     * Find the first Feedback that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {feedbackFindFirstOrThrowArgs} args - Arguments to find a Feedback
     * @example
     * // Get one Feedback
     * const feedback = await prisma.feedback.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends feedbackFindFirstOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, feedbackFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__feedbackClient<$Result.GetResult<Prisma.$feedbackPayload<ExtArgs>, T, 'findFirstOrThrow'>, never, ExtArgs>

    /**
     * Find zero or more Feedbacks that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {feedbackFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Feedbacks
     * const feedbacks = await prisma.feedback.findMany()
     * 
     * // Get first 10 Feedbacks
     * const feedbacks = await prisma.feedback.findMany({ take: 10 })
     * 
     * // Only select the `feedbackID`
     * const feedbackWithFeedbackIDOnly = await prisma.feedback.findMany({ select: { feedbackID: true } })
     * 
    **/
    findMany<T extends feedbackFindManyArgs<ExtArgs>>(
      args?: SelectSubset<T, feedbackFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<$Result.GetResult<Prisma.$feedbackPayload<ExtArgs>, T, 'findMany'>>

    /**
     * Create a Feedback.
     * @param {feedbackCreateArgs} args - Arguments to create a Feedback.
     * @example
     * // Create one Feedback
     * const Feedback = await prisma.feedback.create({
     *   data: {
     *     // ... data to create a Feedback
     *   }
     * })
     * 
    **/
    create<T extends feedbackCreateArgs<ExtArgs>>(
      args: SelectSubset<T, feedbackCreateArgs<ExtArgs>>
    ): Prisma__feedbackClient<$Result.GetResult<Prisma.$feedbackPayload<ExtArgs>, T, 'create'>, never, ExtArgs>

    /**
     * Create many Feedbacks.
     *     @param {feedbackCreateManyArgs} args - Arguments to create many Feedbacks.
     *     @example
     *     // Create many Feedbacks
     *     const feedback = await prisma.feedback.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends feedbackCreateManyArgs<ExtArgs>>(
      args?: SelectSubset<T, feedbackCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Feedback.
     * @param {feedbackDeleteArgs} args - Arguments to delete one Feedback.
     * @example
     * // Delete one Feedback
     * const Feedback = await prisma.feedback.delete({
     *   where: {
     *     // ... filter to delete one Feedback
     *   }
     * })
     * 
    **/
    delete<T extends feedbackDeleteArgs<ExtArgs>>(
      args: SelectSubset<T, feedbackDeleteArgs<ExtArgs>>
    ): Prisma__feedbackClient<$Result.GetResult<Prisma.$feedbackPayload<ExtArgs>, T, 'delete'>, never, ExtArgs>

    /**
     * Update one Feedback.
     * @param {feedbackUpdateArgs} args - Arguments to update one Feedback.
     * @example
     * // Update one Feedback
     * const feedback = await prisma.feedback.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends feedbackUpdateArgs<ExtArgs>>(
      args: SelectSubset<T, feedbackUpdateArgs<ExtArgs>>
    ): Prisma__feedbackClient<$Result.GetResult<Prisma.$feedbackPayload<ExtArgs>, T, 'update'>, never, ExtArgs>

    /**
     * Delete zero or more Feedbacks.
     * @param {feedbackDeleteManyArgs} args - Arguments to filter Feedbacks to delete.
     * @example
     * // Delete a few Feedbacks
     * const { count } = await prisma.feedback.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends feedbackDeleteManyArgs<ExtArgs>>(
      args?: SelectSubset<T, feedbackDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Feedbacks.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {feedbackUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Feedbacks
     * const feedback = await prisma.feedback.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends feedbackUpdateManyArgs<ExtArgs>>(
      args: SelectSubset<T, feedbackUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Feedback.
     * @param {feedbackUpsertArgs} args - Arguments to update or create a Feedback.
     * @example
     * // Update or create a Feedback
     * const feedback = await prisma.feedback.upsert({
     *   create: {
     *     // ... data to create a Feedback
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Feedback we want to update
     *   }
     * })
    **/
    upsert<T extends feedbackUpsertArgs<ExtArgs>>(
      args: SelectSubset<T, feedbackUpsertArgs<ExtArgs>>
    ): Prisma__feedbackClient<$Result.GetResult<Prisma.$feedbackPayload<ExtArgs>, T, 'upsert'>, never, ExtArgs>

    /**
     * Count the number of Feedbacks.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {feedbackCountArgs} args - Arguments to filter Feedbacks to count.
     * @example
     * // Count the number of Feedbacks
     * const count = await prisma.feedback.count({
     *   where: {
     *     // ... the filter for the Feedbacks we want to count
     *   }
     * })
    **/
    count<T extends feedbackCountArgs>(
      args?: Subset<T, feedbackCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], FeedbackCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Feedback.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FeedbackAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends FeedbackAggregateArgs>(args: Subset<T, FeedbackAggregateArgs>): Prisma.PrismaPromise<GetFeedbackAggregateType<T>>

    /**
     * Group by Feedback.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {feedbackGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends feedbackGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: feedbackGroupByArgs['orderBy'] }
        : { orderBy?: feedbackGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, feedbackGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetFeedbackGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the feedback model
   */
  readonly fields: feedbackFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for feedback.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__feedbackClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: 'PrismaPromise';

    appointment<T extends feedback$appointmentArgs<ExtArgs> = {}>(args?: Subset<T, feedback$appointmentArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$appointmentPayload<ExtArgs>, T, 'findMany'> | Null>;

    user<T extends feedback$userArgs<ExtArgs> = {}>(args?: Subset<T, feedback$userArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$userPayload<ExtArgs>, T, 'findMany'> | Null>;

    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>;
  }



  /**
   * Fields of the feedback model
   */ 
  interface feedbackFieldRefs {
    readonly feedbackID: FieldRef<"feedback", 'String'>
    readonly therapistName: FieldRef<"feedback", 'String'>
    readonly date: FieldRef<"feedback", 'String'>
    readonly time: FieldRef<"feedback", 'String'>
    readonly question1: FieldRef<"feedback", 'String'>
    readonly question2: FieldRef<"feedback", 'String'>
    readonly question3: FieldRef<"feedback", 'String'>
    readonly question4: FieldRef<"feedback", 'String'>
    readonly question5: FieldRef<"feedback", 'String'>
    readonly question6: FieldRef<"feedback", 'String'>
    readonly question7: FieldRef<"feedback", 'String'>
    readonly question8: FieldRef<"feedback", 'String'>
    readonly feedback: FieldRef<"feedback", 'String'>
    readonly rating: FieldRef<"feedback", 'Int'>
    readonly creatdAt: FieldRef<"feedback", 'DateTime'>
    readonly updatedAt: FieldRef<"feedback", 'DateTime'>
  }
    

  // Custom InputTypes

  /**
   * feedback findUnique
   */
  export type feedbackFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the feedback
     */
    select?: feedbackSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: feedbackInclude<ExtArgs> | null
    /**
     * Filter, which feedback to fetch.
     */
    where: feedbackWhereUniqueInput
  }


  /**
   * feedback findUniqueOrThrow
   */
  export type feedbackFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the feedback
     */
    select?: feedbackSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: feedbackInclude<ExtArgs> | null
    /**
     * Filter, which feedback to fetch.
     */
    where: feedbackWhereUniqueInput
  }


  /**
   * feedback findFirst
   */
  export type feedbackFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the feedback
     */
    select?: feedbackSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: feedbackInclude<ExtArgs> | null
    /**
     * Filter, which feedback to fetch.
     */
    where?: feedbackWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of feedbacks to fetch.
     */
    orderBy?: feedbackOrderByWithRelationInput | feedbackOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for feedbacks.
     */
    cursor?: feedbackWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` feedbacks from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` feedbacks.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of feedbacks.
     */
    distinct?: FeedbackScalarFieldEnum | FeedbackScalarFieldEnum[]
  }


  /**
   * feedback findFirstOrThrow
   */
  export type feedbackFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the feedback
     */
    select?: feedbackSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: feedbackInclude<ExtArgs> | null
    /**
     * Filter, which feedback to fetch.
     */
    where?: feedbackWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of feedbacks to fetch.
     */
    orderBy?: feedbackOrderByWithRelationInput | feedbackOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for feedbacks.
     */
    cursor?: feedbackWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` feedbacks from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` feedbacks.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of feedbacks.
     */
    distinct?: FeedbackScalarFieldEnum | FeedbackScalarFieldEnum[]
  }


  /**
   * feedback findMany
   */
  export type feedbackFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the feedback
     */
    select?: feedbackSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: feedbackInclude<ExtArgs> | null
    /**
     * Filter, which feedbacks to fetch.
     */
    where?: feedbackWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of feedbacks to fetch.
     */
    orderBy?: feedbackOrderByWithRelationInput | feedbackOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing feedbacks.
     */
    cursor?: feedbackWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` feedbacks from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` feedbacks.
     */
    skip?: number
    distinct?: FeedbackScalarFieldEnum | FeedbackScalarFieldEnum[]
  }


  /**
   * feedback create
   */
  export type feedbackCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the feedback
     */
    select?: feedbackSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: feedbackInclude<ExtArgs> | null
    /**
     * The data needed to create a feedback.
     */
    data: XOR<feedbackCreateInput, feedbackUncheckedCreateInput>
  }


  /**
   * feedback createMany
   */
  export type feedbackCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many feedbacks.
     */
    data: feedbackCreateManyInput | feedbackCreateManyInput[]
    skipDuplicates?: boolean
  }


  /**
   * feedback update
   */
  export type feedbackUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the feedback
     */
    select?: feedbackSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: feedbackInclude<ExtArgs> | null
    /**
     * The data needed to update a feedback.
     */
    data: XOR<feedbackUpdateInput, feedbackUncheckedUpdateInput>
    /**
     * Choose, which feedback to update.
     */
    where: feedbackWhereUniqueInput
  }


  /**
   * feedback updateMany
   */
  export type feedbackUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update feedbacks.
     */
    data: XOR<feedbackUpdateManyMutationInput, feedbackUncheckedUpdateManyInput>
    /**
     * Filter which feedbacks to update
     */
    where?: feedbackWhereInput
  }


  /**
   * feedback upsert
   */
  export type feedbackUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the feedback
     */
    select?: feedbackSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: feedbackInclude<ExtArgs> | null
    /**
     * The filter to search for the feedback to update in case it exists.
     */
    where: feedbackWhereUniqueInput
    /**
     * In case the feedback found by the `where` argument doesn't exist, create a new feedback with this data.
     */
    create: XOR<feedbackCreateInput, feedbackUncheckedCreateInput>
    /**
     * In case the feedback was found with the provided `where` argument, update it with this data.
     */
    update: XOR<feedbackUpdateInput, feedbackUncheckedUpdateInput>
  }


  /**
   * feedback delete
   */
  export type feedbackDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the feedback
     */
    select?: feedbackSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: feedbackInclude<ExtArgs> | null
    /**
     * Filter which feedback to delete.
     */
    where: feedbackWhereUniqueInput
  }


  /**
   * feedback deleteMany
   */
  export type feedbackDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which feedbacks to delete
     */
    where?: feedbackWhereInput
  }


  /**
   * feedback.appointment
   */
  export type feedback$appointmentArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the appointment
     */
    select?: appointmentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: appointmentInclude<ExtArgs> | null
    where?: appointmentWhereInput
    orderBy?: appointmentOrderByWithRelationInput | appointmentOrderByWithRelationInput[]
    cursor?: appointmentWhereUniqueInput
    take?: number
    skip?: number
    distinct?: AppointmentScalarFieldEnum | AppointmentScalarFieldEnum[]
  }


  /**
   * feedback.user
   */
  export type feedback$userArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the user
     */
    select?: userSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: userInclude<ExtArgs> | null
    where?: userWhereInput
    orderBy?: userOrderByWithRelationInput | userOrderByWithRelationInput[]
    cursor?: userWhereUniqueInput
    take?: number
    skip?: number
    distinct?: UserScalarFieldEnum | UserScalarFieldEnum[]
  }


  /**
   * feedback without action
   */
  export type feedbackDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the feedback
     */
    select?: feedbackSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: feedbackInclude<ExtArgs> | null
  }



  /**
   * Model prediag
   */

  export type AggregatePrediag = {
    _count: PrediagCountAggregateOutputType | null
    _min: PrediagMinAggregateOutputType | null
    _max: PrediagMaxAggregateOutputType | null
  }

  export type PrediagMinAggregateOutputType = {
    prediagnosticID: string | null
    age: string | null
    sex: string | null
    date: string | null
    time: string | null
    question1: string | null
    question2: string | null
    question3: string | null
    question4: string | null
    question5: string | null
    question6: string | null
    question7: string | null
    question8: string | null
    question9: string | null
    question10: string | null
    question11: string | null
    question12: string | null
    question13: string | null
    question14: string | null
    question15: string | null
    question16: string | null
    createdAt: Date | null
    updatedAt: Date | null
    userID: string | null
  }

  export type PrediagMaxAggregateOutputType = {
    prediagnosticID: string | null
    age: string | null
    sex: string | null
    date: string | null
    time: string | null
    question1: string | null
    question2: string | null
    question3: string | null
    question4: string | null
    question5: string | null
    question6: string | null
    question7: string | null
    question8: string | null
    question9: string | null
    question10: string | null
    question11: string | null
    question12: string | null
    question13: string | null
    question14: string | null
    question15: string | null
    question16: string | null
    createdAt: Date | null
    updatedAt: Date | null
    userID: string | null
  }

  export type PrediagCountAggregateOutputType = {
    prediagnosticID: number
    age: number
    sex: number
    date: number
    time: number
    question1: number
    question2: number
    question3: number
    question4: number
    question5: number
    question6: number
    question7: number
    question8: number
    question9: number
    question10: number
    question11: number
    question12: number
    question13: number
    question14: number
    question15: number
    question16: number
    createdAt: number
    updatedAt: number
    userID: number
    _all: number
  }


  export type PrediagMinAggregateInputType = {
    prediagnosticID?: true
    age?: true
    sex?: true
    date?: true
    time?: true
    question1?: true
    question2?: true
    question3?: true
    question4?: true
    question5?: true
    question6?: true
    question7?: true
    question8?: true
    question9?: true
    question10?: true
    question11?: true
    question12?: true
    question13?: true
    question14?: true
    question15?: true
    question16?: true
    createdAt?: true
    updatedAt?: true
    userID?: true
  }

  export type PrediagMaxAggregateInputType = {
    prediagnosticID?: true
    age?: true
    sex?: true
    date?: true
    time?: true
    question1?: true
    question2?: true
    question3?: true
    question4?: true
    question5?: true
    question6?: true
    question7?: true
    question8?: true
    question9?: true
    question10?: true
    question11?: true
    question12?: true
    question13?: true
    question14?: true
    question15?: true
    question16?: true
    createdAt?: true
    updatedAt?: true
    userID?: true
  }

  export type PrediagCountAggregateInputType = {
    prediagnosticID?: true
    age?: true
    sex?: true
    date?: true
    time?: true
    question1?: true
    question2?: true
    question3?: true
    question4?: true
    question5?: true
    question6?: true
    question7?: true
    question8?: true
    question9?: true
    question10?: true
    question11?: true
    question12?: true
    question13?: true
    question14?: true
    question15?: true
    question16?: true
    createdAt?: true
    updatedAt?: true
    userID?: true
    _all?: true
  }

  export type PrediagAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which prediag to aggregate.
     */
    where?: prediagWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of prediags to fetch.
     */
    orderBy?: prediagOrderByWithRelationInput | prediagOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: prediagWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` prediags from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` prediags.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned prediags
    **/
    _count?: true | PrediagCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: PrediagMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: PrediagMaxAggregateInputType
  }

  export type GetPrediagAggregateType<T extends PrediagAggregateArgs> = {
        [P in keyof T & keyof AggregatePrediag]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregatePrediag[P]>
      : GetScalarType<T[P], AggregatePrediag[P]>
  }




  export type prediagGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: prediagWhereInput
    orderBy?: prediagOrderByWithAggregationInput | prediagOrderByWithAggregationInput[]
    by: PrediagScalarFieldEnum[] | PrediagScalarFieldEnum
    having?: prediagScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: PrediagCountAggregateInputType | true
    _min?: PrediagMinAggregateInputType
    _max?: PrediagMaxAggregateInputType
  }

  export type PrediagGroupByOutputType = {
    prediagnosticID: string
    age: string
    sex: string
    date: string
    time: string
    question1: string
    question2: string
    question3: string
    question4: string
    question5: string
    question6: string
    question7: string
    question8: string
    question9: string
    question10: string
    question11: string
    question12: string
    question13: string
    question14: string
    question15: string
    question16: string
    createdAt: Date
    updatedAt: Date
    userID: string | null
    _count: PrediagCountAggregateOutputType | null
    _min: PrediagMinAggregateOutputType | null
    _max: PrediagMaxAggregateOutputType | null
  }

  type GetPrediagGroupByPayload<T extends prediagGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<PrediagGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof PrediagGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], PrediagGroupByOutputType[P]>
            : GetScalarType<T[P], PrediagGroupByOutputType[P]>
        }
      >
    >


  export type prediagSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    prediagnosticID?: boolean
    age?: boolean
    sex?: boolean
    date?: boolean
    time?: boolean
    question1?: boolean
    question2?: boolean
    question3?: boolean
    question4?: boolean
    question5?: boolean
    question6?: boolean
    question7?: boolean
    question8?: boolean
    question9?: boolean
    question10?: boolean
    question11?: boolean
    question12?: boolean
    question13?: boolean
    question14?: boolean
    question15?: boolean
    question16?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    userID?: boolean
    user?: boolean | prediag$userArgs<ExtArgs>
  }, ExtArgs["result"]["prediag"]>

  export type prediagSelectScalar = {
    prediagnosticID?: boolean
    age?: boolean
    sex?: boolean
    date?: boolean
    time?: boolean
    question1?: boolean
    question2?: boolean
    question3?: boolean
    question4?: boolean
    question5?: boolean
    question6?: boolean
    question7?: boolean
    question8?: boolean
    question9?: boolean
    question10?: boolean
    question11?: boolean
    question12?: boolean
    question13?: boolean
    question14?: boolean
    question15?: boolean
    question16?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    userID?: boolean
  }

  export type prediagInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | prediag$userArgs<ExtArgs>
  }


  export type $prediagPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "prediag"
    objects: {
      user: Prisma.$userPayload<ExtArgs> | null
    }
    scalars: $Extensions.GetPayloadResult<{
      prediagnosticID: string
      age: string
      sex: string
      date: string
      time: string
      question1: string
      question2: string
      question3: string
      question4: string
      question5: string
      question6: string
      question7: string
      question8: string
      question9: string
      question10: string
      question11: string
      question12: string
      question13: string
      question14: string
      question15: string
      question16: string
      createdAt: Date
      updatedAt: Date
      userID: string | null
    }, ExtArgs["result"]["prediag"]>
    composites: {}
  }


  type prediagGetPayload<S extends boolean | null | undefined | prediagDefaultArgs> = $Result.GetResult<Prisma.$prediagPayload, S>

  type prediagCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<prediagFindManyArgs, 'select' | 'include' | 'distinct' > & {
      select?: PrediagCountAggregateInputType | true
    }

  export interface prediagDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['prediag'], meta: { name: 'prediag' } }
    /**
     * Find zero or one Prediag that matches the filter.
     * @param {prediagFindUniqueArgs} args - Arguments to find a Prediag
     * @example
     * // Get one Prediag
     * const prediag = await prisma.prediag.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends prediagFindUniqueArgs<ExtArgs>>(
      args: SelectSubset<T, prediagFindUniqueArgs<ExtArgs>>
    ): Prisma__prediagClient<$Result.GetResult<Prisma.$prediagPayload<ExtArgs>, T, 'findUnique'> | null, null, ExtArgs>

    /**
     * Find one Prediag that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {prediagFindUniqueOrThrowArgs} args - Arguments to find a Prediag
     * @example
     * // Get one Prediag
     * const prediag = await prisma.prediag.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends prediagFindUniqueOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, prediagFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__prediagClient<$Result.GetResult<Prisma.$prediagPayload<ExtArgs>, T, 'findUniqueOrThrow'>, never, ExtArgs>

    /**
     * Find the first Prediag that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {prediagFindFirstArgs} args - Arguments to find a Prediag
     * @example
     * // Get one Prediag
     * const prediag = await prisma.prediag.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends prediagFindFirstArgs<ExtArgs>>(
      args?: SelectSubset<T, prediagFindFirstArgs<ExtArgs>>
    ): Prisma__prediagClient<$Result.GetResult<Prisma.$prediagPayload<ExtArgs>, T, 'findFirst'> | null, null, ExtArgs>

    /**
     * Find the first Prediag that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {prediagFindFirstOrThrowArgs} args - Arguments to find a Prediag
     * @example
     * // Get one Prediag
     * const prediag = await prisma.prediag.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends prediagFindFirstOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, prediagFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__prediagClient<$Result.GetResult<Prisma.$prediagPayload<ExtArgs>, T, 'findFirstOrThrow'>, never, ExtArgs>

    /**
     * Find zero or more Prediags that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {prediagFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Prediags
     * const prediags = await prisma.prediag.findMany()
     * 
     * // Get first 10 Prediags
     * const prediags = await prisma.prediag.findMany({ take: 10 })
     * 
     * // Only select the `prediagnosticID`
     * const prediagWithPrediagnosticIDOnly = await prisma.prediag.findMany({ select: { prediagnosticID: true } })
     * 
    **/
    findMany<T extends prediagFindManyArgs<ExtArgs>>(
      args?: SelectSubset<T, prediagFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<$Result.GetResult<Prisma.$prediagPayload<ExtArgs>, T, 'findMany'>>

    /**
     * Create a Prediag.
     * @param {prediagCreateArgs} args - Arguments to create a Prediag.
     * @example
     * // Create one Prediag
     * const Prediag = await prisma.prediag.create({
     *   data: {
     *     // ... data to create a Prediag
     *   }
     * })
     * 
    **/
    create<T extends prediagCreateArgs<ExtArgs>>(
      args: SelectSubset<T, prediagCreateArgs<ExtArgs>>
    ): Prisma__prediagClient<$Result.GetResult<Prisma.$prediagPayload<ExtArgs>, T, 'create'>, never, ExtArgs>

    /**
     * Create many Prediags.
     *     @param {prediagCreateManyArgs} args - Arguments to create many Prediags.
     *     @example
     *     // Create many Prediags
     *     const prediag = await prisma.prediag.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends prediagCreateManyArgs<ExtArgs>>(
      args?: SelectSubset<T, prediagCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Prediag.
     * @param {prediagDeleteArgs} args - Arguments to delete one Prediag.
     * @example
     * // Delete one Prediag
     * const Prediag = await prisma.prediag.delete({
     *   where: {
     *     // ... filter to delete one Prediag
     *   }
     * })
     * 
    **/
    delete<T extends prediagDeleteArgs<ExtArgs>>(
      args: SelectSubset<T, prediagDeleteArgs<ExtArgs>>
    ): Prisma__prediagClient<$Result.GetResult<Prisma.$prediagPayload<ExtArgs>, T, 'delete'>, never, ExtArgs>

    /**
     * Update one Prediag.
     * @param {prediagUpdateArgs} args - Arguments to update one Prediag.
     * @example
     * // Update one Prediag
     * const prediag = await prisma.prediag.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends prediagUpdateArgs<ExtArgs>>(
      args: SelectSubset<T, prediagUpdateArgs<ExtArgs>>
    ): Prisma__prediagClient<$Result.GetResult<Prisma.$prediagPayload<ExtArgs>, T, 'update'>, never, ExtArgs>

    /**
     * Delete zero or more Prediags.
     * @param {prediagDeleteManyArgs} args - Arguments to filter Prediags to delete.
     * @example
     * // Delete a few Prediags
     * const { count } = await prisma.prediag.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends prediagDeleteManyArgs<ExtArgs>>(
      args?: SelectSubset<T, prediagDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Prediags.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {prediagUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Prediags
     * const prediag = await prisma.prediag.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends prediagUpdateManyArgs<ExtArgs>>(
      args: SelectSubset<T, prediagUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Prediag.
     * @param {prediagUpsertArgs} args - Arguments to update or create a Prediag.
     * @example
     * // Update or create a Prediag
     * const prediag = await prisma.prediag.upsert({
     *   create: {
     *     // ... data to create a Prediag
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Prediag we want to update
     *   }
     * })
    **/
    upsert<T extends prediagUpsertArgs<ExtArgs>>(
      args: SelectSubset<T, prediagUpsertArgs<ExtArgs>>
    ): Prisma__prediagClient<$Result.GetResult<Prisma.$prediagPayload<ExtArgs>, T, 'upsert'>, never, ExtArgs>

    /**
     * Count the number of Prediags.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {prediagCountArgs} args - Arguments to filter Prediags to count.
     * @example
     * // Count the number of Prediags
     * const count = await prisma.prediag.count({
     *   where: {
     *     // ... the filter for the Prediags we want to count
     *   }
     * })
    **/
    count<T extends prediagCountArgs>(
      args?: Subset<T, prediagCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], PrediagCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Prediag.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PrediagAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends PrediagAggregateArgs>(args: Subset<T, PrediagAggregateArgs>): Prisma.PrismaPromise<GetPrediagAggregateType<T>>

    /**
     * Group by Prediag.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {prediagGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends prediagGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: prediagGroupByArgs['orderBy'] }
        : { orderBy?: prediagGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, prediagGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetPrediagGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the prediag model
   */
  readonly fields: prediagFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for prediag.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__prediagClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: 'PrismaPromise';

    user<T extends prediag$userArgs<ExtArgs> = {}>(args?: Subset<T, prediag$userArgs<ExtArgs>>): Prisma__userClient<$Result.GetResult<Prisma.$userPayload<ExtArgs>, T, 'findUniqueOrThrow'> | null, null, ExtArgs>;

    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>;
  }



  /**
   * Fields of the prediag model
   */ 
  interface prediagFieldRefs {
    readonly prediagnosticID: FieldRef<"prediag", 'String'>
    readonly age: FieldRef<"prediag", 'String'>
    readonly sex: FieldRef<"prediag", 'String'>
    readonly date: FieldRef<"prediag", 'String'>
    readonly time: FieldRef<"prediag", 'String'>
    readonly question1: FieldRef<"prediag", 'String'>
    readonly question2: FieldRef<"prediag", 'String'>
    readonly question3: FieldRef<"prediag", 'String'>
    readonly question4: FieldRef<"prediag", 'String'>
    readonly question5: FieldRef<"prediag", 'String'>
    readonly question6: FieldRef<"prediag", 'String'>
    readonly question7: FieldRef<"prediag", 'String'>
    readonly question8: FieldRef<"prediag", 'String'>
    readonly question9: FieldRef<"prediag", 'String'>
    readonly question10: FieldRef<"prediag", 'String'>
    readonly question11: FieldRef<"prediag", 'String'>
    readonly question12: FieldRef<"prediag", 'String'>
    readonly question13: FieldRef<"prediag", 'String'>
    readonly question14: FieldRef<"prediag", 'String'>
    readonly question15: FieldRef<"prediag", 'String'>
    readonly question16: FieldRef<"prediag", 'String'>
    readonly createdAt: FieldRef<"prediag", 'DateTime'>
    readonly updatedAt: FieldRef<"prediag", 'DateTime'>
    readonly userID: FieldRef<"prediag", 'String'>
  }
    

  // Custom InputTypes

  /**
   * prediag findUnique
   */
  export type prediagFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the prediag
     */
    select?: prediagSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: prediagInclude<ExtArgs> | null
    /**
     * Filter, which prediag to fetch.
     */
    where: prediagWhereUniqueInput
  }


  /**
   * prediag findUniqueOrThrow
   */
  export type prediagFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the prediag
     */
    select?: prediagSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: prediagInclude<ExtArgs> | null
    /**
     * Filter, which prediag to fetch.
     */
    where: prediagWhereUniqueInput
  }


  /**
   * prediag findFirst
   */
  export type prediagFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the prediag
     */
    select?: prediagSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: prediagInclude<ExtArgs> | null
    /**
     * Filter, which prediag to fetch.
     */
    where?: prediagWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of prediags to fetch.
     */
    orderBy?: prediagOrderByWithRelationInput | prediagOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for prediags.
     */
    cursor?: prediagWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` prediags from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` prediags.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of prediags.
     */
    distinct?: PrediagScalarFieldEnum | PrediagScalarFieldEnum[]
  }


  /**
   * prediag findFirstOrThrow
   */
  export type prediagFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the prediag
     */
    select?: prediagSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: prediagInclude<ExtArgs> | null
    /**
     * Filter, which prediag to fetch.
     */
    where?: prediagWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of prediags to fetch.
     */
    orderBy?: prediagOrderByWithRelationInput | prediagOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for prediags.
     */
    cursor?: prediagWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` prediags from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` prediags.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of prediags.
     */
    distinct?: PrediagScalarFieldEnum | PrediagScalarFieldEnum[]
  }


  /**
   * prediag findMany
   */
  export type prediagFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the prediag
     */
    select?: prediagSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: prediagInclude<ExtArgs> | null
    /**
     * Filter, which prediags to fetch.
     */
    where?: prediagWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of prediags to fetch.
     */
    orderBy?: prediagOrderByWithRelationInput | prediagOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing prediags.
     */
    cursor?: prediagWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` prediags from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` prediags.
     */
    skip?: number
    distinct?: PrediagScalarFieldEnum | PrediagScalarFieldEnum[]
  }


  /**
   * prediag create
   */
  export type prediagCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the prediag
     */
    select?: prediagSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: prediagInclude<ExtArgs> | null
    /**
     * The data needed to create a prediag.
     */
    data: XOR<prediagCreateInput, prediagUncheckedCreateInput>
  }


  /**
   * prediag createMany
   */
  export type prediagCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many prediags.
     */
    data: prediagCreateManyInput | prediagCreateManyInput[]
    skipDuplicates?: boolean
  }


  /**
   * prediag update
   */
  export type prediagUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the prediag
     */
    select?: prediagSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: prediagInclude<ExtArgs> | null
    /**
     * The data needed to update a prediag.
     */
    data: XOR<prediagUpdateInput, prediagUncheckedUpdateInput>
    /**
     * Choose, which prediag to update.
     */
    where: prediagWhereUniqueInput
  }


  /**
   * prediag updateMany
   */
  export type prediagUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update prediags.
     */
    data: XOR<prediagUpdateManyMutationInput, prediagUncheckedUpdateManyInput>
    /**
     * Filter which prediags to update
     */
    where?: prediagWhereInput
  }


  /**
   * prediag upsert
   */
  export type prediagUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the prediag
     */
    select?: prediagSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: prediagInclude<ExtArgs> | null
    /**
     * The filter to search for the prediag to update in case it exists.
     */
    where: prediagWhereUniqueInput
    /**
     * In case the prediag found by the `where` argument doesn't exist, create a new prediag with this data.
     */
    create: XOR<prediagCreateInput, prediagUncheckedCreateInput>
    /**
     * In case the prediag was found with the provided `where` argument, update it with this data.
     */
    update: XOR<prediagUpdateInput, prediagUncheckedUpdateInput>
  }


  /**
   * prediag delete
   */
  export type prediagDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the prediag
     */
    select?: prediagSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: prediagInclude<ExtArgs> | null
    /**
     * Filter which prediag to delete.
     */
    where: prediagWhereUniqueInput
  }


  /**
   * prediag deleteMany
   */
  export type prediagDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which prediags to delete
     */
    where?: prediagWhereInput
  }


  /**
   * prediag.user
   */
  export type prediag$userArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the user
     */
    select?: userSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: userInclude<ExtArgs> | null
    where?: userWhereInput
  }


  /**
   * prediag without action
   */
  export type prediagDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the prediag
     */
    select?: prediagSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: prediagInclude<ExtArgs> | null
  }



  /**
   * Enums
   */

  export const TransactionIsolationLevel: {
    ReadUncommitted: 'ReadUncommitted',
    ReadCommitted: 'ReadCommitted',
    RepeatableRead: 'RepeatableRead',
    Serializable: 'Serializable'
  };

  export type TransactionIsolationLevel = (typeof TransactionIsolationLevel)[keyof typeof TransactionIsolationLevel]


  export const UserScalarFieldEnum: {
    userID: 'userID',
    email: 'email',
    password: 'password',
    role: 'role',
    verified: 'verified',
    creatdAt: 'creatdAt',
    updateAt: 'updateAt'
  };

  export type UserScalarFieldEnum = (typeof UserScalarFieldEnum)[keyof typeof UserScalarFieldEnum]


  export const ServicesScalarFieldEnum: {
    servicesID: 'servicesID',
    services: 'services',
    descriptions: 'descriptions',
    image: 'image',
    price: 'price',
    userID: 'userID'
  };

  export type ServicesScalarFieldEnum = (typeof ServicesScalarFieldEnum)[keyof typeof ServicesScalarFieldEnum]


  export const OtpScalarFieldEnum: {
    otpID: 'otpID',
    otp: 'otp',
    expiredAt: 'expiredAt',
    createdAt: 'createdAt'
  };

  export type OtpScalarFieldEnum = (typeof OtpScalarFieldEnum)[keyof typeof OtpScalarFieldEnum]


  export const AppointmentScalarFieldEnum: {
    appointmentID: 'appointmentID',
    date: 'date',
    time: 'time',
    services: 'services',
    platform: 'platform',
    link: 'link',
    amount: 'amount',
    status: 'status',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt',
    feedbackID: 'feedbackID'
  };

  export type AppointmentScalarFieldEnum = (typeof AppointmentScalarFieldEnum)[keyof typeof AppointmentScalarFieldEnum]


  export const EquipmentScalarFieldEnum: {
    equipmentID: 'equipmentID',
    name: 'name',
    inventory: 'inventory',
    description: 'description',
    quantity: 'quantity',
    expireDate: 'expireDate',
    creatdAt: 'creatdAt',
    updateAt: 'updateAt'
  };

  export type EquipmentScalarFieldEnum = (typeof EquipmentScalarFieldEnum)[keyof typeof EquipmentScalarFieldEnum]


  export const BlogsScalarFieldEnum: {
    blogsID: 'blogsID',
    title: 'title',
    content: 'content',
    expertise: 'expertise',
    image: 'image',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type BlogsScalarFieldEnum = (typeof BlogsScalarFieldEnum)[keyof typeof BlogsScalarFieldEnum]


  export const FaqsScalarFieldEnum: {
    faqsID: 'faqsID',
    faqs: 'faqs',
    answer: 'answer',
    creatdAt: 'creatdAt',
    updateAt: 'updateAt'
  };

  export type FaqsScalarFieldEnum = (typeof FaqsScalarFieldEnum)[keyof typeof FaqsScalarFieldEnum]


  export const AvatarScalarFieldEnum: {
    avatarID: 'avatarID',
    avatar: 'avatar',
    creatdAt: 'creatdAt',
    updateAt: 'updateAt',
    profileID: 'profileID'
  };

  export type AvatarScalarFieldEnum = (typeof AvatarScalarFieldEnum)[keyof typeof AvatarScalarFieldEnum]


  export const ProfileScalarFieldEnum: {
    profileID: 'profileID',
    firstname: 'firstname',
    lastname: 'lastname',
    phone: 'phone',
    designation: 'designation',
    expertise: 'expertise',
    emergencyPhone: 'emergencyPhone',
    userID: 'userID'
  };

  export type ProfileScalarFieldEnum = (typeof ProfileScalarFieldEnum)[keyof typeof ProfileScalarFieldEnum]


  export const DiagnosisScalarFieldEnum: {
    diagnosisID: 'diagnosisID',
    diagnosis: 'diagnosis',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt',
    userID: 'userID'
  };

  export type DiagnosisScalarFieldEnum = (typeof DiagnosisScalarFieldEnum)[keyof typeof DiagnosisScalarFieldEnum]


  export const PresciptionScalarFieldEnum: {
    prescriptionID: 'prescriptionID',
    prescription: 'prescription',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt',
    userID: 'userID'
  };

  export type PresciptionScalarFieldEnum = (typeof PresciptionScalarFieldEnum)[keyof typeof PresciptionScalarFieldEnum]


  export const FeedbackScalarFieldEnum: {
    feedbackID: 'feedbackID',
    therapistName: 'therapistName',
    date: 'date',
    time: 'time',
    question1: 'question1',
    question2: 'question2',
    question3: 'question3',
    question4: 'question4',
    question5: 'question5',
    question6: 'question6',
    question7: 'question7',
    question8: 'question8',
    feedback: 'feedback',
    rating: 'rating',
    creatdAt: 'creatdAt',
    updatedAt: 'updatedAt'
  };

  export type FeedbackScalarFieldEnum = (typeof FeedbackScalarFieldEnum)[keyof typeof FeedbackScalarFieldEnum]


  export const PrediagScalarFieldEnum: {
    prediagnosticID: 'prediagnosticID',
    age: 'age',
    sex: 'sex',
    date: 'date',
    time: 'time',
    question1: 'question1',
    question2: 'question2',
    question3: 'question3',
    question4: 'question4',
    question5: 'question5',
    question6: 'question6',
    question7: 'question7',
    question8: 'question8',
    question9: 'question9',
    question10: 'question10',
    question11: 'question11',
    question12: 'question12',
    question13: 'question13',
    question14: 'question14',
    question15: 'question15',
    question16: 'question16',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt',
    userID: 'userID'
  };

  export type PrediagScalarFieldEnum = (typeof PrediagScalarFieldEnum)[keyof typeof PrediagScalarFieldEnum]


  export const SortOrder: {
    asc: 'asc',
    desc: 'desc'
  };

  export type SortOrder = (typeof SortOrder)[keyof typeof SortOrder]


  export const QueryMode: {
    default: 'default',
    insensitive: 'insensitive'
  };

  export type QueryMode = (typeof QueryMode)[keyof typeof QueryMode]


  export const NullsOrder: {
    first: 'first',
    last: 'last'
  };

  export type NullsOrder = (typeof NullsOrder)[keyof typeof NullsOrder]


  /**
   * Field references 
   */


  /**
   * Reference to a field of type 'String'
   */
  export type StringFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'String'>
    


  /**
   * Reference to a field of type 'String[]'
   */
  export type ListStringFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'String[]'>
    


  /**
   * Reference to a field of type 'roles'
   */
  export type EnumrolesFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'roles'>
    


  /**
   * Reference to a field of type 'roles[]'
   */
  export type ListEnumrolesFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'roles[]'>
    


  /**
   * Reference to a field of type 'Boolean'
   */
  export type BooleanFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Boolean'>
    


  /**
   * Reference to a field of type 'DateTime'
   */
  export type DateTimeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'DateTime'>
    


  /**
   * Reference to a field of type 'DateTime[]'
   */
  export type ListDateTimeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'DateTime[]'>
    


  /**
   * Reference to a field of type 'Float'
   */
  export type FloatFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Float'>
    


  /**
   * Reference to a field of type 'Float[]'
   */
  export type ListFloatFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Float[]'>
    


  /**
   * Reference to a field of type 'platform'
   */
  export type EnumplatformFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'platform'>
    


  /**
   * Reference to a field of type 'platform[]'
   */
  export type ListEnumplatformFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'platform[]'>
    


  /**
   * Reference to a field of type 'Int'
   */
  export type IntFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Int'>
    


  /**
   * Reference to a field of type 'Int[]'
   */
  export type ListIntFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Int[]'>
    


  /**
   * Reference to a field of type 'status'
   */
  export type EnumstatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'status'>
    


  /**
   * Reference to a field of type 'status[]'
   */
  export type ListEnumstatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'status[]'>
    


  /**
   * Reference to a field of type 'inventory'
   */
  export type EnuminventoryFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'inventory'>
    


  /**
   * Reference to a field of type 'inventory[]'
   */
  export type ListEnuminventoryFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'inventory[]'>
    
  /**
   * Deep Input Types
   */


  export type userWhereInput = {
    AND?: userWhereInput | userWhereInput[]
    OR?: userWhereInput[]
    NOT?: userWhereInput | userWhereInput[]
    userID?: StringFilter<"user"> | string
    email?: StringFilter<"user"> | string
    password?: StringFilter<"user"> | string
    role?: EnumrolesFilter<"user"> | $Enums.roles
    verified?: BoolFilter<"user"> | boolean
    creatdAt?: DateTimeFilter<"user"> | Date | string
    updateAt?: DateTimeFilter<"user"> | Date | string
    profile?: XOR<ProfileNullableRelationFilter, profileWhereInput> | null
    blog?: BlogsListRelationFilter
    faqs?: FaqsListRelationFilter
    equipment?: EquipmentListRelationFilter
    prescription?: PresciptionListRelationFilter
    feedback?: FeedbackListRelationFilter
    appointment?: AppointmentListRelationFilter
    diagnosis?: DiagnosisListRelationFilter
    otp?: OtpListRelationFilter
    services?: ServicesListRelationFilter
    preDiagnostic?: PrediagListRelationFilter
  }

  export type userOrderByWithRelationInput = {
    userID?: SortOrder
    email?: SortOrder
    password?: SortOrder
    role?: SortOrder
    verified?: SortOrder
    creatdAt?: SortOrder
    updateAt?: SortOrder
    profile?: profileOrderByWithRelationInput
    blog?: blogsOrderByRelationAggregateInput
    faqs?: faqsOrderByRelationAggregateInput
    equipment?: equipmentOrderByRelationAggregateInput
    prescription?: presciptionOrderByRelationAggregateInput
    feedback?: feedbackOrderByRelationAggregateInput
    appointment?: appointmentOrderByRelationAggregateInput
    diagnosis?: diagnosisOrderByRelationAggregateInput
    otp?: otpOrderByRelationAggregateInput
    services?: servicesOrderByRelationAggregateInput
    preDiagnostic?: prediagOrderByRelationAggregateInput
  }

  export type userWhereUniqueInput = Prisma.AtLeast<{
    userID?: string
    email?: string
    AND?: userWhereInput | userWhereInput[]
    OR?: userWhereInput[]
    NOT?: userWhereInput | userWhereInput[]
    password?: StringFilter<"user"> | string
    role?: EnumrolesFilter<"user"> | $Enums.roles
    verified?: BoolFilter<"user"> | boolean
    creatdAt?: DateTimeFilter<"user"> | Date | string
    updateAt?: DateTimeFilter<"user"> | Date | string
    profile?: XOR<ProfileNullableRelationFilter, profileWhereInput> | null
    blog?: BlogsListRelationFilter
    faqs?: FaqsListRelationFilter
    equipment?: EquipmentListRelationFilter
    prescription?: PresciptionListRelationFilter
    feedback?: FeedbackListRelationFilter
    appointment?: AppointmentListRelationFilter
    diagnosis?: DiagnosisListRelationFilter
    otp?: OtpListRelationFilter
    services?: ServicesListRelationFilter
    preDiagnostic?: PrediagListRelationFilter
  }, "userID" | "email">

  export type userOrderByWithAggregationInput = {
    userID?: SortOrder
    email?: SortOrder
    password?: SortOrder
    role?: SortOrder
    verified?: SortOrder
    creatdAt?: SortOrder
    updateAt?: SortOrder
    _count?: userCountOrderByAggregateInput
    _max?: userMaxOrderByAggregateInput
    _min?: userMinOrderByAggregateInput
  }

  export type userScalarWhereWithAggregatesInput = {
    AND?: userScalarWhereWithAggregatesInput | userScalarWhereWithAggregatesInput[]
    OR?: userScalarWhereWithAggregatesInput[]
    NOT?: userScalarWhereWithAggregatesInput | userScalarWhereWithAggregatesInput[]
    userID?: StringWithAggregatesFilter<"user"> | string
    email?: StringWithAggregatesFilter<"user"> | string
    password?: StringWithAggregatesFilter<"user"> | string
    role?: EnumrolesWithAggregatesFilter<"user"> | $Enums.roles
    verified?: BoolWithAggregatesFilter<"user"> | boolean
    creatdAt?: DateTimeWithAggregatesFilter<"user"> | Date | string
    updateAt?: DateTimeWithAggregatesFilter<"user"> | Date | string
  }

  export type servicesWhereInput = {
    AND?: servicesWhereInput | servicesWhereInput[]
    OR?: servicesWhereInput[]
    NOT?: servicesWhereInput | servicesWhereInput[]
    servicesID?: StringFilter<"services"> | string
    services?: StringFilter<"services"> | string
    descriptions?: StringFilter<"services"> | string
    image?: StringFilter<"services"> | string
    price?: FloatFilter<"services"> | number
    userID?: StringNullableFilter<"services"> | string | null
    user?: XOR<UserNullableRelationFilter, userWhereInput> | null
    appointment?: AppointmentListRelationFilter
  }

  export type servicesOrderByWithRelationInput = {
    servicesID?: SortOrder
    services?: SortOrder
    descriptions?: SortOrder
    image?: SortOrder
    price?: SortOrder
    userID?: SortOrderInput | SortOrder
    user?: userOrderByWithRelationInput
    appointment?: appointmentOrderByRelationAggregateInput
  }

  export type servicesWhereUniqueInput = Prisma.AtLeast<{
    servicesID?: string
    AND?: servicesWhereInput | servicesWhereInput[]
    OR?: servicesWhereInput[]
    NOT?: servicesWhereInput | servicesWhereInput[]
    services?: StringFilter<"services"> | string
    descriptions?: StringFilter<"services"> | string
    image?: StringFilter<"services"> | string
    price?: FloatFilter<"services"> | number
    userID?: StringNullableFilter<"services"> | string | null
    user?: XOR<UserNullableRelationFilter, userWhereInput> | null
    appointment?: AppointmentListRelationFilter
  }, "servicesID">

  export type servicesOrderByWithAggregationInput = {
    servicesID?: SortOrder
    services?: SortOrder
    descriptions?: SortOrder
    image?: SortOrder
    price?: SortOrder
    userID?: SortOrderInput | SortOrder
    _count?: servicesCountOrderByAggregateInput
    _avg?: servicesAvgOrderByAggregateInput
    _max?: servicesMaxOrderByAggregateInput
    _min?: servicesMinOrderByAggregateInput
    _sum?: servicesSumOrderByAggregateInput
  }

  export type servicesScalarWhereWithAggregatesInput = {
    AND?: servicesScalarWhereWithAggregatesInput | servicesScalarWhereWithAggregatesInput[]
    OR?: servicesScalarWhereWithAggregatesInput[]
    NOT?: servicesScalarWhereWithAggregatesInput | servicesScalarWhereWithAggregatesInput[]
    servicesID?: StringWithAggregatesFilter<"services"> | string
    services?: StringWithAggregatesFilter<"services"> | string
    descriptions?: StringWithAggregatesFilter<"services"> | string
    image?: StringWithAggregatesFilter<"services"> | string
    price?: FloatWithAggregatesFilter<"services"> | number
    userID?: StringNullableWithAggregatesFilter<"services"> | string | null
  }

  export type otpWhereInput = {
    AND?: otpWhereInput | otpWhereInput[]
    OR?: otpWhereInput[]
    NOT?: otpWhereInput | otpWhereInput[]
    otpID?: StringFilter<"otp"> | string
    otp?: StringFilter<"otp"> | string
    expiredAt?: DateTimeFilter<"otp"> | Date | string
    createdAt?: DateTimeFilter<"otp"> | Date | string
    user?: UserListRelationFilter
  }

  export type otpOrderByWithRelationInput = {
    otpID?: SortOrder
    otp?: SortOrder
    expiredAt?: SortOrder
    createdAt?: SortOrder
    user?: userOrderByRelationAggregateInput
  }

  export type otpWhereUniqueInput = Prisma.AtLeast<{
    otpID?: string
    otp?: string
    AND?: otpWhereInput | otpWhereInput[]
    OR?: otpWhereInput[]
    NOT?: otpWhereInput | otpWhereInput[]
    expiredAt?: DateTimeFilter<"otp"> | Date | string
    createdAt?: DateTimeFilter<"otp"> | Date | string
    user?: UserListRelationFilter
  }, "otpID" | "otp">

  export type otpOrderByWithAggregationInput = {
    otpID?: SortOrder
    otp?: SortOrder
    expiredAt?: SortOrder
    createdAt?: SortOrder
    _count?: otpCountOrderByAggregateInput
    _max?: otpMaxOrderByAggregateInput
    _min?: otpMinOrderByAggregateInput
  }

  export type otpScalarWhereWithAggregatesInput = {
    AND?: otpScalarWhereWithAggregatesInput | otpScalarWhereWithAggregatesInput[]
    OR?: otpScalarWhereWithAggregatesInput[]
    NOT?: otpScalarWhereWithAggregatesInput | otpScalarWhereWithAggregatesInput[]
    otpID?: StringWithAggregatesFilter<"otp"> | string
    otp?: StringWithAggregatesFilter<"otp"> | string
    expiredAt?: DateTimeWithAggregatesFilter<"otp"> | Date | string
    createdAt?: DateTimeWithAggregatesFilter<"otp"> | Date | string
  }

  export type appointmentWhereInput = {
    AND?: appointmentWhereInput | appointmentWhereInput[]
    OR?: appointmentWhereInput[]
    NOT?: appointmentWhereInput | appointmentWhereInput[]
    appointmentID?: StringFilter<"appointment"> | string
    date?: DateTimeFilter<"appointment"> | Date | string
    time?: StringFilter<"appointment"> | string
    services?: StringNullableFilter<"appointment"> | string | null
    platform?: EnumplatformFilter<"appointment"> | $Enums.platform
    link?: StringNullableFilter<"appointment"> | string | null
    amount?: IntFilter<"appointment"> | number
    status?: EnumstatusFilter<"appointment"> | $Enums.status
    createdAt?: DateTimeFilter<"appointment"> | Date | string
    updatedAt?: DateTimeFilter<"appointment"> | Date | string
    feedbackID?: StringNullableFilter<"appointment"> | string | null
    user?: UserListRelationFilter
    feedback?: XOR<FeedbackNullableRelationFilter, feedbackWhereInput> | null
    service?: ServicesListRelationFilter
  }

  export type appointmentOrderByWithRelationInput = {
    appointmentID?: SortOrder
    date?: SortOrder
    time?: SortOrder
    services?: SortOrderInput | SortOrder
    platform?: SortOrder
    link?: SortOrderInput | SortOrder
    amount?: SortOrder
    status?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    feedbackID?: SortOrderInput | SortOrder
    user?: userOrderByRelationAggregateInput
    feedback?: feedbackOrderByWithRelationInput
    service?: servicesOrderByRelationAggregateInput
  }

  export type appointmentWhereUniqueInput = Prisma.AtLeast<{
    appointmentID?: string
    AND?: appointmentWhereInput | appointmentWhereInput[]
    OR?: appointmentWhereInput[]
    NOT?: appointmentWhereInput | appointmentWhereInput[]
    date?: DateTimeFilter<"appointment"> | Date | string
    time?: StringFilter<"appointment"> | string
    services?: StringNullableFilter<"appointment"> | string | null
    platform?: EnumplatformFilter<"appointment"> | $Enums.platform
    link?: StringNullableFilter<"appointment"> | string | null
    amount?: IntFilter<"appointment"> | number
    status?: EnumstatusFilter<"appointment"> | $Enums.status
    createdAt?: DateTimeFilter<"appointment"> | Date | string
    updatedAt?: DateTimeFilter<"appointment"> | Date | string
    feedbackID?: StringNullableFilter<"appointment"> | string | null
    user?: UserListRelationFilter
    feedback?: XOR<FeedbackNullableRelationFilter, feedbackWhereInput> | null
    service?: ServicesListRelationFilter
  }, "appointmentID">

  export type appointmentOrderByWithAggregationInput = {
    appointmentID?: SortOrder
    date?: SortOrder
    time?: SortOrder
    services?: SortOrderInput | SortOrder
    platform?: SortOrder
    link?: SortOrderInput | SortOrder
    amount?: SortOrder
    status?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    feedbackID?: SortOrderInput | SortOrder
    _count?: appointmentCountOrderByAggregateInput
    _avg?: appointmentAvgOrderByAggregateInput
    _max?: appointmentMaxOrderByAggregateInput
    _min?: appointmentMinOrderByAggregateInput
    _sum?: appointmentSumOrderByAggregateInput
  }

  export type appointmentScalarWhereWithAggregatesInput = {
    AND?: appointmentScalarWhereWithAggregatesInput | appointmentScalarWhereWithAggregatesInput[]
    OR?: appointmentScalarWhereWithAggregatesInput[]
    NOT?: appointmentScalarWhereWithAggregatesInput | appointmentScalarWhereWithAggregatesInput[]
    appointmentID?: StringWithAggregatesFilter<"appointment"> | string
    date?: DateTimeWithAggregatesFilter<"appointment"> | Date | string
    time?: StringWithAggregatesFilter<"appointment"> | string
    services?: StringNullableWithAggregatesFilter<"appointment"> | string | null
    platform?: EnumplatformWithAggregatesFilter<"appointment"> | $Enums.platform
    link?: StringNullableWithAggregatesFilter<"appointment"> | string | null
    amount?: IntWithAggregatesFilter<"appointment"> | number
    status?: EnumstatusWithAggregatesFilter<"appointment"> | $Enums.status
    createdAt?: DateTimeWithAggregatesFilter<"appointment"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"appointment"> | Date | string
    feedbackID?: StringNullableWithAggregatesFilter<"appointment"> | string | null
  }

  export type equipmentWhereInput = {
    AND?: equipmentWhereInput | equipmentWhereInput[]
    OR?: equipmentWhereInput[]
    NOT?: equipmentWhereInput | equipmentWhereInput[]
    equipmentID?: StringFilter<"equipment"> | string
    name?: StringFilter<"equipment"> | string
    inventory?: EnuminventoryFilter<"equipment"> | $Enums.inventory
    description?: StringFilter<"equipment"> | string
    quantity?: IntFilter<"equipment"> | number
    expireDate?: DateTimeFilter<"equipment"> | Date | string
    creatdAt?: DateTimeFilter<"equipment"> | Date | string
    updateAt?: DateTimeFilter<"equipment"> | Date | string
    user?: UserListRelationFilter
  }

  export type equipmentOrderByWithRelationInput = {
    equipmentID?: SortOrder
    name?: SortOrder
    inventory?: SortOrder
    description?: SortOrder
    quantity?: SortOrder
    expireDate?: SortOrder
    creatdAt?: SortOrder
    updateAt?: SortOrder
    user?: userOrderByRelationAggregateInput
  }

  export type equipmentWhereUniqueInput = Prisma.AtLeast<{
    equipmentID?: string
    AND?: equipmentWhereInput | equipmentWhereInput[]
    OR?: equipmentWhereInput[]
    NOT?: equipmentWhereInput | equipmentWhereInput[]
    name?: StringFilter<"equipment"> | string
    inventory?: EnuminventoryFilter<"equipment"> | $Enums.inventory
    description?: StringFilter<"equipment"> | string
    quantity?: IntFilter<"equipment"> | number
    expireDate?: DateTimeFilter<"equipment"> | Date | string
    creatdAt?: DateTimeFilter<"equipment"> | Date | string
    updateAt?: DateTimeFilter<"equipment"> | Date | string
    user?: UserListRelationFilter
  }, "equipmentID">

  export type equipmentOrderByWithAggregationInput = {
    equipmentID?: SortOrder
    name?: SortOrder
    inventory?: SortOrder
    description?: SortOrder
    quantity?: SortOrder
    expireDate?: SortOrder
    creatdAt?: SortOrder
    updateAt?: SortOrder
    _count?: equipmentCountOrderByAggregateInput
    _avg?: equipmentAvgOrderByAggregateInput
    _max?: equipmentMaxOrderByAggregateInput
    _min?: equipmentMinOrderByAggregateInput
    _sum?: equipmentSumOrderByAggregateInput
  }

  export type equipmentScalarWhereWithAggregatesInput = {
    AND?: equipmentScalarWhereWithAggregatesInput | equipmentScalarWhereWithAggregatesInput[]
    OR?: equipmentScalarWhereWithAggregatesInput[]
    NOT?: equipmentScalarWhereWithAggregatesInput | equipmentScalarWhereWithAggregatesInput[]
    equipmentID?: StringWithAggregatesFilter<"equipment"> | string
    name?: StringWithAggregatesFilter<"equipment"> | string
    inventory?: EnuminventoryWithAggregatesFilter<"equipment"> | $Enums.inventory
    description?: StringWithAggregatesFilter<"equipment"> | string
    quantity?: IntWithAggregatesFilter<"equipment"> | number
    expireDate?: DateTimeWithAggregatesFilter<"equipment"> | Date | string
    creatdAt?: DateTimeWithAggregatesFilter<"equipment"> | Date | string
    updateAt?: DateTimeWithAggregatesFilter<"equipment"> | Date | string
  }

  export type blogsWhereInput = {
    AND?: blogsWhereInput | blogsWhereInput[]
    OR?: blogsWhereInput[]
    NOT?: blogsWhereInput | blogsWhereInput[]
    blogsID?: StringFilter<"blogs"> | string
    title?: StringFilter<"blogs"> | string
    content?: StringFilter<"blogs"> | string
    expertise?: StringFilter<"blogs"> | string
    image?: StringFilter<"blogs"> | string
    createdAt?: DateTimeFilter<"blogs"> | Date | string
    updatedAt?: DateTimeFilter<"blogs"> | Date | string
    user?: UserListRelationFilter
  }

  export type blogsOrderByWithRelationInput = {
    blogsID?: SortOrder
    title?: SortOrder
    content?: SortOrder
    expertise?: SortOrder
    image?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    user?: userOrderByRelationAggregateInput
  }

  export type blogsWhereUniqueInput = Prisma.AtLeast<{
    blogsID?: string
    AND?: blogsWhereInput | blogsWhereInput[]
    OR?: blogsWhereInput[]
    NOT?: blogsWhereInput | blogsWhereInput[]
    title?: StringFilter<"blogs"> | string
    content?: StringFilter<"blogs"> | string
    expertise?: StringFilter<"blogs"> | string
    image?: StringFilter<"blogs"> | string
    createdAt?: DateTimeFilter<"blogs"> | Date | string
    updatedAt?: DateTimeFilter<"blogs"> | Date | string
    user?: UserListRelationFilter
  }, "blogsID">

  export type blogsOrderByWithAggregationInput = {
    blogsID?: SortOrder
    title?: SortOrder
    content?: SortOrder
    expertise?: SortOrder
    image?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: blogsCountOrderByAggregateInput
    _max?: blogsMaxOrderByAggregateInput
    _min?: blogsMinOrderByAggregateInput
  }

  export type blogsScalarWhereWithAggregatesInput = {
    AND?: blogsScalarWhereWithAggregatesInput | blogsScalarWhereWithAggregatesInput[]
    OR?: blogsScalarWhereWithAggregatesInput[]
    NOT?: blogsScalarWhereWithAggregatesInput | blogsScalarWhereWithAggregatesInput[]
    blogsID?: StringWithAggregatesFilter<"blogs"> | string
    title?: StringWithAggregatesFilter<"blogs"> | string
    content?: StringWithAggregatesFilter<"blogs"> | string
    expertise?: StringWithAggregatesFilter<"blogs"> | string
    image?: StringWithAggregatesFilter<"blogs"> | string
    createdAt?: DateTimeWithAggregatesFilter<"blogs"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"blogs"> | Date | string
  }

  export type faqsWhereInput = {
    AND?: faqsWhereInput | faqsWhereInput[]
    OR?: faqsWhereInput[]
    NOT?: faqsWhereInput | faqsWhereInput[]
    faqsID?: StringFilter<"faqs"> | string
    faqs?: StringFilter<"faqs"> | string
    answer?: StringFilter<"faqs"> | string
    creatdAt?: DateTimeFilter<"faqs"> | Date | string
    updateAt?: DateTimeFilter<"faqs"> | Date | string
    user?: UserListRelationFilter
  }

  export type faqsOrderByWithRelationInput = {
    faqsID?: SortOrder
    faqs?: SortOrder
    answer?: SortOrder
    creatdAt?: SortOrder
    updateAt?: SortOrder
    user?: userOrderByRelationAggregateInput
  }

  export type faqsWhereUniqueInput = Prisma.AtLeast<{
    faqsID?: string
    AND?: faqsWhereInput | faqsWhereInput[]
    OR?: faqsWhereInput[]
    NOT?: faqsWhereInput | faqsWhereInput[]
    faqs?: StringFilter<"faqs"> | string
    answer?: StringFilter<"faqs"> | string
    creatdAt?: DateTimeFilter<"faqs"> | Date | string
    updateAt?: DateTimeFilter<"faqs"> | Date | string
    user?: UserListRelationFilter
  }, "faqsID">

  export type faqsOrderByWithAggregationInput = {
    faqsID?: SortOrder
    faqs?: SortOrder
    answer?: SortOrder
    creatdAt?: SortOrder
    updateAt?: SortOrder
    _count?: faqsCountOrderByAggregateInput
    _max?: faqsMaxOrderByAggregateInput
    _min?: faqsMinOrderByAggregateInput
  }

  export type faqsScalarWhereWithAggregatesInput = {
    AND?: faqsScalarWhereWithAggregatesInput | faqsScalarWhereWithAggregatesInput[]
    OR?: faqsScalarWhereWithAggregatesInput[]
    NOT?: faqsScalarWhereWithAggregatesInput | faqsScalarWhereWithAggregatesInput[]
    faqsID?: StringWithAggregatesFilter<"faqs"> | string
    faqs?: StringWithAggregatesFilter<"faqs"> | string
    answer?: StringWithAggregatesFilter<"faqs"> | string
    creatdAt?: DateTimeWithAggregatesFilter<"faqs"> | Date | string
    updateAt?: DateTimeWithAggregatesFilter<"faqs"> | Date | string
  }

  export type avatarWhereInput = {
    AND?: avatarWhereInput | avatarWhereInput[]
    OR?: avatarWhereInput[]
    NOT?: avatarWhereInput | avatarWhereInput[]
    avatarID?: StringFilter<"avatar"> | string
    avatar?: StringFilter<"avatar"> | string
    creatdAt?: DateTimeFilter<"avatar"> | Date | string
    updateAt?: DateTimeFilter<"avatar"> | Date | string
    profileID?: StringNullableFilter<"avatar"> | string | null
    profile?: XOR<ProfileNullableRelationFilter, profileWhereInput> | null
  }

  export type avatarOrderByWithRelationInput = {
    avatarID?: SortOrder
    avatar?: SortOrder
    creatdAt?: SortOrder
    updateAt?: SortOrder
    profileID?: SortOrderInput | SortOrder
    profile?: profileOrderByWithRelationInput
  }

  export type avatarWhereUniqueInput = Prisma.AtLeast<{
    avatarID?: string
    profileID?: string
    AND?: avatarWhereInput | avatarWhereInput[]
    OR?: avatarWhereInput[]
    NOT?: avatarWhereInput | avatarWhereInput[]
    avatar?: StringFilter<"avatar"> | string
    creatdAt?: DateTimeFilter<"avatar"> | Date | string
    updateAt?: DateTimeFilter<"avatar"> | Date | string
    profile?: XOR<ProfileNullableRelationFilter, profileWhereInput> | null
  }, "avatarID" | "profileID">

  export type avatarOrderByWithAggregationInput = {
    avatarID?: SortOrder
    avatar?: SortOrder
    creatdAt?: SortOrder
    updateAt?: SortOrder
    profileID?: SortOrderInput | SortOrder
    _count?: avatarCountOrderByAggregateInput
    _max?: avatarMaxOrderByAggregateInput
    _min?: avatarMinOrderByAggregateInput
  }

  export type avatarScalarWhereWithAggregatesInput = {
    AND?: avatarScalarWhereWithAggregatesInput | avatarScalarWhereWithAggregatesInput[]
    OR?: avatarScalarWhereWithAggregatesInput[]
    NOT?: avatarScalarWhereWithAggregatesInput | avatarScalarWhereWithAggregatesInput[]
    avatarID?: StringWithAggregatesFilter<"avatar"> | string
    avatar?: StringWithAggregatesFilter<"avatar"> | string
    creatdAt?: DateTimeWithAggregatesFilter<"avatar"> | Date | string
    updateAt?: DateTimeWithAggregatesFilter<"avatar"> | Date | string
    profileID?: StringNullableWithAggregatesFilter<"avatar"> | string | null
  }

  export type profileWhereInput = {
    AND?: profileWhereInput | profileWhereInput[]
    OR?: profileWhereInput[]
    NOT?: profileWhereInput | profileWhereInput[]
    profileID?: StringFilter<"profile"> | string
    firstname?: StringFilter<"profile"> | string
    lastname?: StringFilter<"profile"> | string
    phone?: StringFilter<"profile"> | string
    designation?: StringNullableFilter<"profile"> | string | null
    expertise?: StringNullableFilter<"profile"> | string | null
    emergencyPhone?: StringNullableFilter<"profile"> | string | null
    userID?: StringNullableFilter<"profile"> | string | null
    avatar?: XOR<AvatarNullableRelationFilter, avatarWhereInput> | null
    user?: XOR<UserNullableRelationFilter, userWhereInput> | null
  }

  export type profileOrderByWithRelationInput = {
    profileID?: SortOrder
    firstname?: SortOrder
    lastname?: SortOrder
    phone?: SortOrder
    designation?: SortOrderInput | SortOrder
    expertise?: SortOrderInput | SortOrder
    emergencyPhone?: SortOrderInput | SortOrder
    userID?: SortOrderInput | SortOrder
    avatar?: avatarOrderByWithRelationInput
    user?: userOrderByWithRelationInput
  }

  export type profileWhereUniqueInput = Prisma.AtLeast<{
    profileID?: string
    userID?: string
    AND?: profileWhereInput | profileWhereInput[]
    OR?: profileWhereInput[]
    NOT?: profileWhereInput | profileWhereInput[]
    firstname?: StringFilter<"profile"> | string
    lastname?: StringFilter<"profile"> | string
    phone?: StringFilter<"profile"> | string
    designation?: StringNullableFilter<"profile"> | string | null
    expertise?: StringNullableFilter<"profile"> | string | null
    emergencyPhone?: StringNullableFilter<"profile"> | string | null
    avatar?: XOR<AvatarNullableRelationFilter, avatarWhereInput> | null
    user?: XOR<UserNullableRelationFilter, userWhereInput> | null
  }, "profileID" | "userID">

  export type profileOrderByWithAggregationInput = {
    profileID?: SortOrder
    firstname?: SortOrder
    lastname?: SortOrder
    phone?: SortOrder
    designation?: SortOrderInput | SortOrder
    expertise?: SortOrderInput | SortOrder
    emergencyPhone?: SortOrderInput | SortOrder
    userID?: SortOrderInput | SortOrder
    _count?: profileCountOrderByAggregateInput
    _max?: profileMaxOrderByAggregateInput
    _min?: profileMinOrderByAggregateInput
  }

  export type profileScalarWhereWithAggregatesInput = {
    AND?: profileScalarWhereWithAggregatesInput | profileScalarWhereWithAggregatesInput[]
    OR?: profileScalarWhereWithAggregatesInput[]
    NOT?: profileScalarWhereWithAggregatesInput | profileScalarWhereWithAggregatesInput[]
    profileID?: StringWithAggregatesFilter<"profile"> | string
    firstname?: StringWithAggregatesFilter<"profile"> | string
    lastname?: StringWithAggregatesFilter<"profile"> | string
    phone?: StringWithAggregatesFilter<"profile"> | string
    designation?: StringNullableWithAggregatesFilter<"profile"> | string | null
    expertise?: StringNullableWithAggregatesFilter<"profile"> | string | null
    emergencyPhone?: StringNullableWithAggregatesFilter<"profile"> | string | null
    userID?: StringNullableWithAggregatesFilter<"profile"> | string | null
  }

  export type diagnosisWhereInput = {
    AND?: diagnosisWhereInput | diagnosisWhereInput[]
    OR?: diagnosisWhereInput[]
    NOT?: diagnosisWhereInput | diagnosisWhereInput[]
    diagnosisID?: StringFilter<"diagnosis"> | string
    diagnosis?: StringFilter<"diagnosis"> | string
    createdAt?: DateTimeFilter<"diagnosis"> | Date | string
    updatedAt?: DateTimeFilter<"diagnosis"> | Date | string
    userID?: StringNullableFilter<"diagnosis"> | string | null
    user?: XOR<UserNullableRelationFilter, userWhereInput> | null
  }

  export type diagnosisOrderByWithRelationInput = {
    diagnosisID?: SortOrder
    diagnosis?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    userID?: SortOrderInput | SortOrder
    user?: userOrderByWithRelationInput
  }

  export type diagnosisWhereUniqueInput = Prisma.AtLeast<{
    diagnosisID?: string
    AND?: diagnosisWhereInput | diagnosisWhereInput[]
    OR?: diagnosisWhereInput[]
    NOT?: diagnosisWhereInput | diagnosisWhereInput[]
    diagnosis?: StringFilter<"diagnosis"> | string
    createdAt?: DateTimeFilter<"diagnosis"> | Date | string
    updatedAt?: DateTimeFilter<"diagnosis"> | Date | string
    userID?: StringNullableFilter<"diagnosis"> | string | null
    user?: XOR<UserNullableRelationFilter, userWhereInput> | null
  }, "diagnosisID">

  export type diagnosisOrderByWithAggregationInput = {
    diagnosisID?: SortOrder
    diagnosis?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    userID?: SortOrderInput | SortOrder
    _count?: diagnosisCountOrderByAggregateInput
    _max?: diagnosisMaxOrderByAggregateInput
    _min?: diagnosisMinOrderByAggregateInput
  }

  export type diagnosisScalarWhereWithAggregatesInput = {
    AND?: diagnosisScalarWhereWithAggregatesInput | diagnosisScalarWhereWithAggregatesInput[]
    OR?: diagnosisScalarWhereWithAggregatesInput[]
    NOT?: diagnosisScalarWhereWithAggregatesInput | diagnosisScalarWhereWithAggregatesInput[]
    diagnosisID?: StringWithAggregatesFilter<"diagnosis"> | string
    diagnosis?: StringWithAggregatesFilter<"diagnosis"> | string
    createdAt?: DateTimeWithAggregatesFilter<"diagnosis"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"diagnosis"> | Date | string
    userID?: StringNullableWithAggregatesFilter<"diagnosis"> | string | null
  }

  export type presciptionWhereInput = {
    AND?: presciptionWhereInput | presciptionWhereInput[]
    OR?: presciptionWhereInput[]
    NOT?: presciptionWhereInput | presciptionWhereInput[]
    prescriptionID?: StringFilter<"presciption"> | string
    prescription?: StringFilter<"presciption"> | string
    createdAt?: DateTimeFilter<"presciption"> | Date | string
    updatedAt?: DateTimeFilter<"presciption"> | Date | string
    userID?: StringNullableFilter<"presciption"> | string | null
    patinet?: XOR<UserNullableRelationFilter, userWhereInput> | null
  }

  export type presciptionOrderByWithRelationInput = {
    prescriptionID?: SortOrder
    prescription?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    userID?: SortOrderInput | SortOrder
    patinet?: userOrderByWithRelationInput
  }

  export type presciptionWhereUniqueInput = Prisma.AtLeast<{
    prescriptionID?: string
    AND?: presciptionWhereInput | presciptionWhereInput[]
    OR?: presciptionWhereInput[]
    NOT?: presciptionWhereInput | presciptionWhereInput[]
    prescription?: StringFilter<"presciption"> | string
    createdAt?: DateTimeFilter<"presciption"> | Date | string
    updatedAt?: DateTimeFilter<"presciption"> | Date | string
    userID?: StringNullableFilter<"presciption"> | string | null
    patinet?: XOR<UserNullableRelationFilter, userWhereInput> | null
  }, "prescriptionID">

  export type presciptionOrderByWithAggregationInput = {
    prescriptionID?: SortOrder
    prescription?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    userID?: SortOrderInput | SortOrder
    _count?: presciptionCountOrderByAggregateInput
    _max?: presciptionMaxOrderByAggregateInput
    _min?: presciptionMinOrderByAggregateInput
  }

  export type presciptionScalarWhereWithAggregatesInput = {
    AND?: presciptionScalarWhereWithAggregatesInput | presciptionScalarWhereWithAggregatesInput[]
    OR?: presciptionScalarWhereWithAggregatesInput[]
    NOT?: presciptionScalarWhereWithAggregatesInput | presciptionScalarWhereWithAggregatesInput[]
    prescriptionID?: StringWithAggregatesFilter<"presciption"> | string
    prescription?: StringWithAggregatesFilter<"presciption"> | string
    createdAt?: DateTimeWithAggregatesFilter<"presciption"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"presciption"> | Date | string
    userID?: StringNullableWithAggregatesFilter<"presciption"> | string | null
  }

  export type feedbackWhereInput = {
    AND?: feedbackWhereInput | feedbackWhereInput[]
    OR?: feedbackWhereInput[]
    NOT?: feedbackWhereInput | feedbackWhereInput[]
    feedbackID?: StringFilter<"feedback"> | string
    therapistName?: StringFilter<"feedback"> | string
    date?: StringFilter<"feedback"> | string
    time?: StringFilter<"feedback"> | string
    question1?: StringFilter<"feedback"> | string
    question2?: StringFilter<"feedback"> | string
    question3?: StringFilter<"feedback"> | string
    question4?: StringFilter<"feedback"> | string
    question5?: StringFilter<"feedback"> | string
    question6?: StringFilter<"feedback"> | string
    question7?: StringFilter<"feedback"> | string
    question8?: StringFilter<"feedback"> | string
    feedback?: StringFilter<"feedback"> | string
    rating?: IntFilter<"feedback"> | number
    creatdAt?: DateTimeFilter<"feedback"> | Date | string
    updatedAt?: DateTimeFilter<"feedback"> | Date | string
    appointment?: AppointmentListRelationFilter
    user?: UserListRelationFilter
  }

  export type feedbackOrderByWithRelationInput = {
    feedbackID?: SortOrder
    therapistName?: SortOrder
    date?: SortOrder
    time?: SortOrder
    question1?: SortOrder
    question2?: SortOrder
    question3?: SortOrder
    question4?: SortOrder
    question5?: SortOrder
    question6?: SortOrder
    question7?: SortOrder
    question8?: SortOrder
    feedback?: SortOrder
    rating?: SortOrder
    creatdAt?: SortOrder
    updatedAt?: SortOrder
    appointment?: appointmentOrderByRelationAggregateInput
    user?: userOrderByRelationAggregateInput
  }

  export type feedbackWhereUniqueInput = Prisma.AtLeast<{
    feedbackID?: string
    AND?: feedbackWhereInput | feedbackWhereInput[]
    OR?: feedbackWhereInput[]
    NOT?: feedbackWhereInput | feedbackWhereInput[]
    therapistName?: StringFilter<"feedback"> | string
    date?: StringFilter<"feedback"> | string
    time?: StringFilter<"feedback"> | string
    question1?: StringFilter<"feedback"> | string
    question2?: StringFilter<"feedback"> | string
    question3?: StringFilter<"feedback"> | string
    question4?: StringFilter<"feedback"> | string
    question5?: StringFilter<"feedback"> | string
    question6?: StringFilter<"feedback"> | string
    question7?: StringFilter<"feedback"> | string
    question8?: StringFilter<"feedback"> | string
    feedback?: StringFilter<"feedback"> | string
    rating?: IntFilter<"feedback"> | number
    creatdAt?: DateTimeFilter<"feedback"> | Date | string
    updatedAt?: DateTimeFilter<"feedback"> | Date | string
    appointment?: AppointmentListRelationFilter
    user?: UserListRelationFilter
  }, "feedbackID">

  export type feedbackOrderByWithAggregationInput = {
    feedbackID?: SortOrder
    therapistName?: SortOrder
    date?: SortOrder
    time?: SortOrder
    question1?: SortOrder
    question2?: SortOrder
    question3?: SortOrder
    question4?: SortOrder
    question5?: SortOrder
    question6?: SortOrder
    question7?: SortOrder
    question8?: SortOrder
    feedback?: SortOrder
    rating?: SortOrder
    creatdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: feedbackCountOrderByAggregateInput
    _avg?: feedbackAvgOrderByAggregateInput
    _max?: feedbackMaxOrderByAggregateInput
    _min?: feedbackMinOrderByAggregateInput
    _sum?: feedbackSumOrderByAggregateInput
  }

  export type feedbackScalarWhereWithAggregatesInput = {
    AND?: feedbackScalarWhereWithAggregatesInput | feedbackScalarWhereWithAggregatesInput[]
    OR?: feedbackScalarWhereWithAggregatesInput[]
    NOT?: feedbackScalarWhereWithAggregatesInput | feedbackScalarWhereWithAggregatesInput[]
    feedbackID?: StringWithAggregatesFilter<"feedback"> | string
    therapistName?: StringWithAggregatesFilter<"feedback"> | string
    date?: StringWithAggregatesFilter<"feedback"> | string
    time?: StringWithAggregatesFilter<"feedback"> | string
    question1?: StringWithAggregatesFilter<"feedback"> | string
    question2?: StringWithAggregatesFilter<"feedback"> | string
    question3?: StringWithAggregatesFilter<"feedback"> | string
    question4?: StringWithAggregatesFilter<"feedback"> | string
    question5?: StringWithAggregatesFilter<"feedback"> | string
    question6?: StringWithAggregatesFilter<"feedback"> | string
    question7?: StringWithAggregatesFilter<"feedback"> | string
    question8?: StringWithAggregatesFilter<"feedback"> | string
    feedback?: StringWithAggregatesFilter<"feedback"> | string
    rating?: IntWithAggregatesFilter<"feedback"> | number
    creatdAt?: DateTimeWithAggregatesFilter<"feedback"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"feedback"> | Date | string
  }

  export type prediagWhereInput = {
    AND?: prediagWhereInput | prediagWhereInput[]
    OR?: prediagWhereInput[]
    NOT?: prediagWhereInput | prediagWhereInput[]
    prediagnosticID?: StringFilter<"prediag"> | string
    age?: StringFilter<"prediag"> | string
    sex?: StringFilter<"prediag"> | string
    date?: StringFilter<"prediag"> | string
    time?: StringFilter<"prediag"> | string
    question1?: StringFilter<"prediag"> | string
    question2?: StringFilter<"prediag"> | string
    question3?: StringFilter<"prediag"> | string
    question4?: StringFilter<"prediag"> | string
    question5?: StringFilter<"prediag"> | string
    question6?: StringFilter<"prediag"> | string
    question7?: StringFilter<"prediag"> | string
    question8?: StringFilter<"prediag"> | string
    question9?: StringFilter<"prediag"> | string
    question10?: StringFilter<"prediag"> | string
    question11?: StringFilter<"prediag"> | string
    question12?: StringFilter<"prediag"> | string
    question13?: StringFilter<"prediag"> | string
    question14?: StringFilter<"prediag"> | string
    question15?: StringFilter<"prediag"> | string
    question16?: StringFilter<"prediag"> | string
    createdAt?: DateTimeFilter<"prediag"> | Date | string
    updatedAt?: DateTimeFilter<"prediag"> | Date | string
    userID?: StringNullableFilter<"prediag"> | string | null
    user?: XOR<UserNullableRelationFilter, userWhereInput> | null
  }

  export type prediagOrderByWithRelationInput = {
    prediagnosticID?: SortOrder
    age?: SortOrder
    sex?: SortOrder
    date?: SortOrder
    time?: SortOrder
    question1?: SortOrder
    question2?: SortOrder
    question3?: SortOrder
    question4?: SortOrder
    question5?: SortOrder
    question6?: SortOrder
    question7?: SortOrder
    question8?: SortOrder
    question9?: SortOrder
    question10?: SortOrder
    question11?: SortOrder
    question12?: SortOrder
    question13?: SortOrder
    question14?: SortOrder
    question15?: SortOrder
    question16?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    userID?: SortOrderInput | SortOrder
    user?: userOrderByWithRelationInput
  }

  export type prediagWhereUniqueInput = Prisma.AtLeast<{
    prediagnosticID?: string
    AND?: prediagWhereInput | prediagWhereInput[]
    OR?: prediagWhereInput[]
    NOT?: prediagWhereInput | prediagWhereInput[]
    age?: StringFilter<"prediag"> | string
    sex?: StringFilter<"prediag"> | string
    date?: StringFilter<"prediag"> | string
    time?: StringFilter<"prediag"> | string
    question1?: StringFilter<"prediag"> | string
    question2?: StringFilter<"prediag"> | string
    question3?: StringFilter<"prediag"> | string
    question4?: StringFilter<"prediag"> | string
    question5?: StringFilter<"prediag"> | string
    question6?: StringFilter<"prediag"> | string
    question7?: StringFilter<"prediag"> | string
    question8?: StringFilter<"prediag"> | string
    question9?: StringFilter<"prediag"> | string
    question10?: StringFilter<"prediag"> | string
    question11?: StringFilter<"prediag"> | string
    question12?: StringFilter<"prediag"> | string
    question13?: StringFilter<"prediag"> | string
    question14?: StringFilter<"prediag"> | string
    question15?: StringFilter<"prediag"> | string
    question16?: StringFilter<"prediag"> | string
    createdAt?: DateTimeFilter<"prediag"> | Date | string
    updatedAt?: DateTimeFilter<"prediag"> | Date | string
    userID?: StringNullableFilter<"prediag"> | string | null
    user?: XOR<UserNullableRelationFilter, userWhereInput> | null
  }, "prediagnosticID">

  export type prediagOrderByWithAggregationInput = {
    prediagnosticID?: SortOrder
    age?: SortOrder
    sex?: SortOrder
    date?: SortOrder
    time?: SortOrder
    question1?: SortOrder
    question2?: SortOrder
    question3?: SortOrder
    question4?: SortOrder
    question5?: SortOrder
    question6?: SortOrder
    question7?: SortOrder
    question8?: SortOrder
    question9?: SortOrder
    question10?: SortOrder
    question11?: SortOrder
    question12?: SortOrder
    question13?: SortOrder
    question14?: SortOrder
    question15?: SortOrder
    question16?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    userID?: SortOrderInput | SortOrder
    _count?: prediagCountOrderByAggregateInput
    _max?: prediagMaxOrderByAggregateInput
    _min?: prediagMinOrderByAggregateInput
  }

  export type prediagScalarWhereWithAggregatesInput = {
    AND?: prediagScalarWhereWithAggregatesInput | prediagScalarWhereWithAggregatesInput[]
    OR?: prediagScalarWhereWithAggregatesInput[]
    NOT?: prediagScalarWhereWithAggregatesInput | prediagScalarWhereWithAggregatesInput[]
    prediagnosticID?: StringWithAggregatesFilter<"prediag"> | string
    age?: StringWithAggregatesFilter<"prediag"> | string
    sex?: StringWithAggregatesFilter<"prediag"> | string
    date?: StringWithAggregatesFilter<"prediag"> | string
    time?: StringWithAggregatesFilter<"prediag"> | string
    question1?: StringWithAggregatesFilter<"prediag"> | string
    question2?: StringWithAggregatesFilter<"prediag"> | string
    question3?: StringWithAggregatesFilter<"prediag"> | string
    question4?: StringWithAggregatesFilter<"prediag"> | string
    question5?: StringWithAggregatesFilter<"prediag"> | string
    question6?: StringWithAggregatesFilter<"prediag"> | string
    question7?: StringWithAggregatesFilter<"prediag"> | string
    question8?: StringWithAggregatesFilter<"prediag"> | string
    question9?: StringWithAggregatesFilter<"prediag"> | string
    question10?: StringWithAggregatesFilter<"prediag"> | string
    question11?: StringWithAggregatesFilter<"prediag"> | string
    question12?: StringWithAggregatesFilter<"prediag"> | string
    question13?: StringWithAggregatesFilter<"prediag"> | string
    question14?: StringWithAggregatesFilter<"prediag"> | string
    question15?: StringWithAggregatesFilter<"prediag"> | string
    question16?: StringWithAggregatesFilter<"prediag"> | string
    createdAt?: DateTimeWithAggregatesFilter<"prediag"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"prediag"> | Date | string
    userID?: StringNullableWithAggregatesFilter<"prediag"> | string | null
  }

  export type userCreateInput = {
    userID?: string
    email: string
    password: string
    role: $Enums.roles
    verified?: boolean
    creatdAt?: Date | string
    updateAt?: Date | string
    profile?: profileCreateNestedOneWithoutUserInput
    blog?: blogsCreateNestedManyWithoutUserInput
    faqs?: faqsCreateNestedManyWithoutUserInput
    equipment?: equipmentCreateNestedManyWithoutUserInput
    prescription?: presciptionCreateNestedManyWithoutPatinetInput
    feedback?: feedbackCreateNestedManyWithoutUserInput
    appointment?: appointmentCreateNestedManyWithoutUserInput
    diagnosis?: diagnosisCreateNestedManyWithoutUserInput
    otp?: otpCreateNestedManyWithoutUserInput
    services?: servicesCreateNestedManyWithoutUserInput
    preDiagnostic?: prediagCreateNestedManyWithoutUserInput
  }

  export type userUncheckedCreateInput = {
    userID?: string
    email: string
    password: string
    role: $Enums.roles
    verified?: boolean
    creatdAt?: Date | string
    updateAt?: Date | string
    profile?: profileUncheckedCreateNestedOneWithoutUserInput
    blog?: blogsUncheckedCreateNestedManyWithoutUserInput
    faqs?: faqsUncheckedCreateNestedManyWithoutUserInput
    equipment?: equipmentUncheckedCreateNestedManyWithoutUserInput
    prescription?: presciptionUncheckedCreateNestedManyWithoutPatinetInput
    feedback?: feedbackUncheckedCreateNestedManyWithoutUserInput
    appointment?: appointmentUncheckedCreateNestedManyWithoutUserInput
    diagnosis?: diagnosisUncheckedCreateNestedManyWithoutUserInput
    otp?: otpUncheckedCreateNestedManyWithoutUserInput
    services?: servicesUncheckedCreateNestedManyWithoutUserInput
    preDiagnostic?: prediagUncheckedCreateNestedManyWithoutUserInput
  }

  export type userUpdateInput = {
    userID?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    role?: EnumrolesFieldUpdateOperationsInput | $Enums.roles
    verified?: BoolFieldUpdateOperationsInput | boolean
    creatdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updateAt?: DateTimeFieldUpdateOperationsInput | Date | string
    profile?: profileUpdateOneWithoutUserNestedInput
    blog?: blogsUpdateManyWithoutUserNestedInput
    faqs?: faqsUpdateManyWithoutUserNestedInput
    equipment?: equipmentUpdateManyWithoutUserNestedInput
    prescription?: presciptionUpdateManyWithoutPatinetNestedInput
    feedback?: feedbackUpdateManyWithoutUserNestedInput
    appointment?: appointmentUpdateManyWithoutUserNestedInput
    diagnosis?: diagnosisUpdateManyWithoutUserNestedInput
    otp?: otpUpdateManyWithoutUserNestedInput
    services?: servicesUpdateManyWithoutUserNestedInput
    preDiagnostic?: prediagUpdateManyWithoutUserNestedInput
  }

  export type userUncheckedUpdateInput = {
    userID?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    role?: EnumrolesFieldUpdateOperationsInput | $Enums.roles
    verified?: BoolFieldUpdateOperationsInput | boolean
    creatdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updateAt?: DateTimeFieldUpdateOperationsInput | Date | string
    profile?: profileUncheckedUpdateOneWithoutUserNestedInput
    blog?: blogsUncheckedUpdateManyWithoutUserNestedInput
    faqs?: faqsUncheckedUpdateManyWithoutUserNestedInput
    equipment?: equipmentUncheckedUpdateManyWithoutUserNestedInput
    prescription?: presciptionUncheckedUpdateManyWithoutPatinetNestedInput
    feedback?: feedbackUncheckedUpdateManyWithoutUserNestedInput
    appointment?: appointmentUncheckedUpdateManyWithoutUserNestedInput
    diagnosis?: diagnosisUncheckedUpdateManyWithoutUserNestedInput
    otp?: otpUncheckedUpdateManyWithoutUserNestedInput
    services?: servicesUncheckedUpdateManyWithoutUserNestedInput
    preDiagnostic?: prediagUncheckedUpdateManyWithoutUserNestedInput
  }

  export type userCreateManyInput = {
    userID?: string
    email: string
    password: string
    role: $Enums.roles
    verified?: boolean
    creatdAt?: Date | string
    updateAt?: Date | string
  }

  export type userUpdateManyMutationInput = {
    userID?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    role?: EnumrolesFieldUpdateOperationsInput | $Enums.roles
    verified?: BoolFieldUpdateOperationsInput | boolean
    creatdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updateAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type userUncheckedUpdateManyInput = {
    userID?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    role?: EnumrolesFieldUpdateOperationsInput | $Enums.roles
    verified?: BoolFieldUpdateOperationsInput | boolean
    creatdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updateAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type servicesCreateInput = {
    servicesID?: string
    services: string
    descriptions: string
    image: string
    price: number
    user?: userCreateNestedOneWithoutServicesInput
    appointment?: appointmentCreateNestedManyWithoutServiceInput
  }

  export type servicesUncheckedCreateInput = {
    servicesID?: string
    services: string
    descriptions: string
    image: string
    price: number
    userID?: string | null
    appointment?: appointmentUncheckedCreateNestedManyWithoutServiceInput
  }

  export type servicesUpdateInput = {
    servicesID?: StringFieldUpdateOperationsInput | string
    services?: StringFieldUpdateOperationsInput | string
    descriptions?: StringFieldUpdateOperationsInput | string
    image?: StringFieldUpdateOperationsInput | string
    price?: FloatFieldUpdateOperationsInput | number
    user?: userUpdateOneWithoutServicesNestedInput
    appointment?: appointmentUpdateManyWithoutServiceNestedInput
  }

  export type servicesUncheckedUpdateInput = {
    servicesID?: StringFieldUpdateOperationsInput | string
    services?: StringFieldUpdateOperationsInput | string
    descriptions?: StringFieldUpdateOperationsInput | string
    image?: StringFieldUpdateOperationsInput | string
    price?: FloatFieldUpdateOperationsInput | number
    userID?: NullableStringFieldUpdateOperationsInput | string | null
    appointment?: appointmentUncheckedUpdateManyWithoutServiceNestedInput
  }

  export type servicesCreateManyInput = {
    servicesID?: string
    services: string
    descriptions: string
    image: string
    price: number
    userID?: string | null
  }

  export type servicesUpdateManyMutationInput = {
    servicesID?: StringFieldUpdateOperationsInput | string
    services?: StringFieldUpdateOperationsInput | string
    descriptions?: StringFieldUpdateOperationsInput | string
    image?: StringFieldUpdateOperationsInput | string
    price?: FloatFieldUpdateOperationsInput | number
  }

  export type servicesUncheckedUpdateManyInput = {
    servicesID?: StringFieldUpdateOperationsInput | string
    services?: StringFieldUpdateOperationsInput | string
    descriptions?: StringFieldUpdateOperationsInput | string
    image?: StringFieldUpdateOperationsInput | string
    price?: FloatFieldUpdateOperationsInput | number
    userID?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type otpCreateInput = {
    otpID?: string
    otp: string
    expiredAt: Date | string
    createdAt: Date | string
    user?: userCreateNestedManyWithoutOtpInput
  }

  export type otpUncheckedCreateInput = {
    otpID?: string
    otp: string
    expiredAt: Date | string
    createdAt: Date | string
    user?: userUncheckedCreateNestedManyWithoutOtpInput
  }

  export type otpUpdateInput = {
    otpID?: StringFieldUpdateOperationsInput | string
    otp?: StringFieldUpdateOperationsInput | string
    expiredAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: userUpdateManyWithoutOtpNestedInput
  }

  export type otpUncheckedUpdateInput = {
    otpID?: StringFieldUpdateOperationsInput | string
    otp?: StringFieldUpdateOperationsInput | string
    expiredAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: userUncheckedUpdateManyWithoutOtpNestedInput
  }

  export type otpCreateManyInput = {
    otpID?: string
    otp: string
    expiredAt: Date | string
    createdAt: Date | string
  }

  export type otpUpdateManyMutationInput = {
    otpID?: StringFieldUpdateOperationsInput | string
    otp?: StringFieldUpdateOperationsInput | string
    expiredAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type otpUncheckedUpdateManyInput = {
    otpID?: StringFieldUpdateOperationsInput | string
    otp?: StringFieldUpdateOperationsInput | string
    expiredAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type appointmentCreateInput = {
    appointmentID?: string
    date: Date | string
    time: string
    services?: string | null
    platform: $Enums.platform
    link?: string | null
    amount: number
    status?: $Enums.status
    createdAt?: Date | string
    updatedAt?: Date | string
    user?: userCreateNestedManyWithoutAppointmentInput
    feedback?: feedbackCreateNestedOneWithoutAppointmentInput
    service?: servicesCreateNestedManyWithoutAppointmentInput
  }

  export type appointmentUncheckedCreateInput = {
    appointmentID?: string
    date: Date | string
    time: string
    services?: string | null
    platform: $Enums.platform
    link?: string | null
    amount: number
    status?: $Enums.status
    createdAt?: Date | string
    updatedAt?: Date | string
    feedbackID?: string | null
    user?: userUncheckedCreateNestedManyWithoutAppointmentInput
    service?: servicesUncheckedCreateNestedManyWithoutAppointmentInput
  }

  export type appointmentUpdateInput = {
    appointmentID?: StringFieldUpdateOperationsInput | string
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    time?: StringFieldUpdateOperationsInput | string
    services?: NullableStringFieldUpdateOperationsInput | string | null
    platform?: EnumplatformFieldUpdateOperationsInput | $Enums.platform
    link?: NullableStringFieldUpdateOperationsInput | string | null
    amount?: IntFieldUpdateOperationsInput | number
    status?: EnumstatusFieldUpdateOperationsInput | $Enums.status
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: userUpdateManyWithoutAppointmentNestedInput
    feedback?: feedbackUpdateOneWithoutAppointmentNestedInput
    service?: servicesUpdateManyWithoutAppointmentNestedInput
  }

  export type appointmentUncheckedUpdateInput = {
    appointmentID?: StringFieldUpdateOperationsInput | string
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    time?: StringFieldUpdateOperationsInput | string
    services?: NullableStringFieldUpdateOperationsInput | string | null
    platform?: EnumplatformFieldUpdateOperationsInput | $Enums.platform
    link?: NullableStringFieldUpdateOperationsInput | string | null
    amount?: IntFieldUpdateOperationsInput | number
    status?: EnumstatusFieldUpdateOperationsInput | $Enums.status
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    feedbackID?: NullableStringFieldUpdateOperationsInput | string | null
    user?: userUncheckedUpdateManyWithoutAppointmentNestedInput
    service?: servicesUncheckedUpdateManyWithoutAppointmentNestedInput
  }

  export type appointmentCreateManyInput = {
    appointmentID?: string
    date: Date | string
    time: string
    services?: string | null
    platform: $Enums.platform
    link?: string | null
    amount: number
    status?: $Enums.status
    createdAt?: Date | string
    updatedAt?: Date | string
    feedbackID?: string | null
  }

  export type appointmentUpdateManyMutationInput = {
    appointmentID?: StringFieldUpdateOperationsInput | string
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    time?: StringFieldUpdateOperationsInput | string
    services?: NullableStringFieldUpdateOperationsInput | string | null
    platform?: EnumplatformFieldUpdateOperationsInput | $Enums.platform
    link?: NullableStringFieldUpdateOperationsInput | string | null
    amount?: IntFieldUpdateOperationsInput | number
    status?: EnumstatusFieldUpdateOperationsInput | $Enums.status
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type appointmentUncheckedUpdateManyInput = {
    appointmentID?: StringFieldUpdateOperationsInput | string
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    time?: StringFieldUpdateOperationsInput | string
    services?: NullableStringFieldUpdateOperationsInput | string | null
    platform?: EnumplatformFieldUpdateOperationsInput | $Enums.platform
    link?: NullableStringFieldUpdateOperationsInput | string | null
    amount?: IntFieldUpdateOperationsInput | number
    status?: EnumstatusFieldUpdateOperationsInput | $Enums.status
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    feedbackID?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type equipmentCreateInput = {
    equipmentID?: string
    name: string
    inventory: $Enums.inventory
    description: string
    quantity: number
    expireDate: Date | string
    creatdAt?: Date | string
    updateAt?: Date | string
    user?: userCreateNestedManyWithoutEquipmentInput
  }

  export type equipmentUncheckedCreateInput = {
    equipmentID?: string
    name: string
    inventory: $Enums.inventory
    description: string
    quantity: number
    expireDate: Date | string
    creatdAt?: Date | string
    updateAt?: Date | string
    user?: userUncheckedCreateNestedManyWithoutEquipmentInput
  }

  export type equipmentUpdateInput = {
    equipmentID?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    inventory?: EnuminventoryFieldUpdateOperationsInput | $Enums.inventory
    description?: StringFieldUpdateOperationsInput | string
    quantity?: IntFieldUpdateOperationsInput | number
    expireDate?: DateTimeFieldUpdateOperationsInput | Date | string
    creatdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updateAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: userUpdateManyWithoutEquipmentNestedInput
  }

  export type equipmentUncheckedUpdateInput = {
    equipmentID?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    inventory?: EnuminventoryFieldUpdateOperationsInput | $Enums.inventory
    description?: StringFieldUpdateOperationsInput | string
    quantity?: IntFieldUpdateOperationsInput | number
    expireDate?: DateTimeFieldUpdateOperationsInput | Date | string
    creatdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updateAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: userUncheckedUpdateManyWithoutEquipmentNestedInput
  }

  export type equipmentCreateManyInput = {
    equipmentID?: string
    name: string
    inventory: $Enums.inventory
    description: string
    quantity: number
    expireDate: Date | string
    creatdAt?: Date | string
    updateAt?: Date | string
  }

  export type equipmentUpdateManyMutationInput = {
    equipmentID?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    inventory?: EnuminventoryFieldUpdateOperationsInput | $Enums.inventory
    description?: StringFieldUpdateOperationsInput | string
    quantity?: IntFieldUpdateOperationsInput | number
    expireDate?: DateTimeFieldUpdateOperationsInput | Date | string
    creatdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updateAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type equipmentUncheckedUpdateManyInput = {
    equipmentID?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    inventory?: EnuminventoryFieldUpdateOperationsInput | $Enums.inventory
    description?: StringFieldUpdateOperationsInput | string
    quantity?: IntFieldUpdateOperationsInput | number
    expireDate?: DateTimeFieldUpdateOperationsInput | Date | string
    creatdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updateAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type blogsCreateInput = {
    blogsID?: string
    title: string
    content: string
    expertise: string
    image: string
    createdAt?: Date | string
    updatedAt?: Date | string
    user?: userCreateNestedManyWithoutBlogInput
  }

  export type blogsUncheckedCreateInput = {
    blogsID?: string
    title: string
    content: string
    expertise: string
    image: string
    createdAt?: Date | string
    updatedAt?: Date | string
    user?: userUncheckedCreateNestedManyWithoutBlogInput
  }

  export type blogsUpdateInput = {
    blogsID?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    expertise?: StringFieldUpdateOperationsInput | string
    image?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: userUpdateManyWithoutBlogNestedInput
  }

  export type blogsUncheckedUpdateInput = {
    blogsID?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    expertise?: StringFieldUpdateOperationsInput | string
    image?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: userUncheckedUpdateManyWithoutBlogNestedInput
  }

  export type blogsCreateManyInput = {
    blogsID?: string
    title: string
    content: string
    expertise: string
    image: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type blogsUpdateManyMutationInput = {
    blogsID?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    expertise?: StringFieldUpdateOperationsInput | string
    image?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type blogsUncheckedUpdateManyInput = {
    blogsID?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    expertise?: StringFieldUpdateOperationsInput | string
    image?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type faqsCreateInput = {
    faqsID?: string
    faqs: string
    answer: string
    creatdAt?: Date | string
    updateAt?: Date | string
    user?: userCreateNestedManyWithoutFaqsInput
  }

  export type faqsUncheckedCreateInput = {
    faqsID?: string
    faqs: string
    answer: string
    creatdAt?: Date | string
    updateAt?: Date | string
    user?: userUncheckedCreateNestedManyWithoutFaqsInput
  }

  export type faqsUpdateInput = {
    faqsID?: StringFieldUpdateOperationsInput | string
    faqs?: StringFieldUpdateOperationsInput | string
    answer?: StringFieldUpdateOperationsInput | string
    creatdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updateAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: userUpdateManyWithoutFaqsNestedInput
  }

  export type faqsUncheckedUpdateInput = {
    faqsID?: StringFieldUpdateOperationsInput | string
    faqs?: StringFieldUpdateOperationsInput | string
    answer?: StringFieldUpdateOperationsInput | string
    creatdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updateAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: userUncheckedUpdateManyWithoutFaqsNestedInput
  }

  export type faqsCreateManyInput = {
    faqsID?: string
    faqs: string
    answer: string
    creatdAt?: Date | string
    updateAt?: Date | string
  }

  export type faqsUpdateManyMutationInput = {
    faqsID?: StringFieldUpdateOperationsInput | string
    faqs?: StringFieldUpdateOperationsInput | string
    answer?: StringFieldUpdateOperationsInput | string
    creatdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updateAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type faqsUncheckedUpdateManyInput = {
    faqsID?: StringFieldUpdateOperationsInput | string
    faqs?: StringFieldUpdateOperationsInput | string
    answer?: StringFieldUpdateOperationsInput | string
    creatdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updateAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type avatarCreateInput = {
    avatarID?: string
    avatar: string
    creatdAt?: Date | string
    updateAt?: Date | string
    profile?: profileCreateNestedOneWithoutAvatarInput
  }

  export type avatarUncheckedCreateInput = {
    avatarID?: string
    avatar: string
    creatdAt?: Date | string
    updateAt?: Date | string
    profileID?: string | null
  }

  export type avatarUpdateInput = {
    avatarID?: StringFieldUpdateOperationsInput | string
    avatar?: StringFieldUpdateOperationsInput | string
    creatdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updateAt?: DateTimeFieldUpdateOperationsInput | Date | string
    profile?: profileUpdateOneWithoutAvatarNestedInput
  }

  export type avatarUncheckedUpdateInput = {
    avatarID?: StringFieldUpdateOperationsInput | string
    avatar?: StringFieldUpdateOperationsInput | string
    creatdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updateAt?: DateTimeFieldUpdateOperationsInput | Date | string
    profileID?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type avatarCreateManyInput = {
    avatarID?: string
    avatar: string
    creatdAt?: Date | string
    updateAt?: Date | string
    profileID?: string | null
  }

  export type avatarUpdateManyMutationInput = {
    avatarID?: StringFieldUpdateOperationsInput | string
    avatar?: StringFieldUpdateOperationsInput | string
    creatdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updateAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type avatarUncheckedUpdateManyInput = {
    avatarID?: StringFieldUpdateOperationsInput | string
    avatar?: StringFieldUpdateOperationsInput | string
    creatdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updateAt?: DateTimeFieldUpdateOperationsInput | Date | string
    profileID?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type profileCreateInput = {
    profileID?: string
    firstname: string
    lastname: string
    phone: string
    designation?: string | null
    expertise?: string | null
    emergencyPhone?: string | null
    avatar?: avatarCreateNestedOneWithoutProfileInput
    user?: userCreateNestedOneWithoutProfileInput
  }

  export type profileUncheckedCreateInput = {
    profileID?: string
    firstname: string
    lastname: string
    phone: string
    designation?: string | null
    expertise?: string | null
    emergencyPhone?: string | null
    userID?: string | null
    avatar?: avatarUncheckedCreateNestedOneWithoutProfileInput
  }

  export type profileUpdateInput = {
    profileID?: StringFieldUpdateOperationsInput | string
    firstname?: StringFieldUpdateOperationsInput | string
    lastname?: StringFieldUpdateOperationsInput | string
    phone?: StringFieldUpdateOperationsInput | string
    designation?: NullableStringFieldUpdateOperationsInput | string | null
    expertise?: NullableStringFieldUpdateOperationsInput | string | null
    emergencyPhone?: NullableStringFieldUpdateOperationsInput | string | null
    avatar?: avatarUpdateOneWithoutProfileNestedInput
    user?: userUpdateOneWithoutProfileNestedInput
  }

  export type profileUncheckedUpdateInput = {
    profileID?: StringFieldUpdateOperationsInput | string
    firstname?: StringFieldUpdateOperationsInput | string
    lastname?: StringFieldUpdateOperationsInput | string
    phone?: StringFieldUpdateOperationsInput | string
    designation?: NullableStringFieldUpdateOperationsInput | string | null
    expertise?: NullableStringFieldUpdateOperationsInput | string | null
    emergencyPhone?: NullableStringFieldUpdateOperationsInput | string | null
    userID?: NullableStringFieldUpdateOperationsInput | string | null
    avatar?: avatarUncheckedUpdateOneWithoutProfileNestedInput
  }

  export type profileCreateManyInput = {
    profileID?: string
    firstname: string
    lastname: string
    phone: string
    designation?: string | null
    expertise?: string | null
    emergencyPhone?: string | null
    userID?: string | null
  }

  export type profileUpdateManyMutationInput = {
    profileID?: StringFieldUpdateOperationsInput | string
    firstname?: StringFieldUpdateOperationsInput | string
    lastname?: StringFieldUpdateOperationsInput | string
    phone?: StringFieldUpdateOperationsInput | string
    designation?: NullableStringFieldUpdateOperationsInput | string | null
    expertise?: NullableStringFieldUpdateOperationsInput | string | null
    emergencyPhone?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type profileUncheckedUpdateManyInput = {
    profileID?: StringFieldUpdateOperationsInput | string
    firstname?: StringFieldUpdateOperationsInput | string
    lastname?: StringFieldUpdateOperationsInput | string
    phone?: StringFieldUpdateOperationsInput | string
    designation?: NullableStringFieldUpdateOperationsInput | string | null
    expertise?: NullableStringFieldUpdateOperationsInput | string | null
    emergencyPhone?: NullableStringFieldUpdateOperationsInput | string | null
    userID?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type diagnosisCreateInput = {
    diagnosisID?: string
    diagnosis?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    user?: userCreateNestedOneWithoutDiagnosisInput
  }

  export type diagnosisUncheckedCreateInput = {
    diagnosisID?: string
    diagnosis?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    userID?: string | null
  }

  export type diagnosisUpdateInput = {
    diagnosisID?: StringFieldUpdateOperationsInput | string
    diagnosis?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: userUpdateOneWithoutDiagnosisNestedInput
  }

  export type diagnosisUncheckedUpdateInput = {
    diagnosisID?: StringFieldUpdateOperationsInput | string
    diagnosis?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    userID?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type diagnosisCreateManyInput = {
    diagnosisID?: string
    diagnosis?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    userID?: string | null
  }

  export type diagnosisUpdateManyMutationInput = {
    diagnosisID?: StringFieldUpdateOperationsInput | string
    diagnosis?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type diagnosisUncheckedUpdateManyInput = {
    diagnosisID?: StringFieldUpdateOperationsInput | string
    diagnosis?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    userID?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type presciptionCreateInput = {
    prescriptionID?: string
    prescription: string
    createdAt?: Date | string
    updatedAt?: Date | string
    patinet?: userCreateNestedOneWithoutPrescriptionInput
  }

  export type presciptionUncheckedCreateInput = {
    prescriptionID?: string
    prescription: string
    createdAt?: Date | string
    updatedAt?: Date | string
    userID?: string | null
  }

  export type presciptionUpdateInput = {
    prescriptionID?: StringFieldUpdateOperationsInput | string
    prescription?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    patinet?: userUpdateOneWithoutPrescriptionNestedInput
  }

  export type presciptionUncheckedUpdateInput = {
    prescriptionID?: StringFieldUpdateOperationsInput | string
    prescription?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    userID?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type presciptionCreateManyInput = {
    prescriptionID?: string
    prescription: string
    createdAt?: Date | string
    updatedAt?: Date | string
    userID?: string | null
  }

  export type presciptionUpdateManyMutationInput = {
    prescriptionID?: StringFieldUpdateOperationsInput | string
    prescription?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type presciptionUncheckedUpdateManyInput = {
    prescriptionID?: StringFieldUpdateOperationsInput | string
    prescription?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    userID?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type feedbackCreateInput = {
    feedbackID?: string
    therapistName: string
    date: string
    time: string
    question1: string
    question2: string
    question3: string
    question4: string
    question5: string
    question6: string
    question7: string
    question8: string
    feedback: string
    rating: number
    creatdAt?: Date | string
    updatedAt?: Date | string
    appointment?: appointmentCreateNestedManyWithoutFeedbackInput
    user?: userCreateNestedManyWithoutFeedbackInput
  }

  export type feedbackUncheckedCreateInput = {
    feedbackID?: string
    therapistName: string
    date: string
    time: string
    question1: string
    question2: string
    question3: string
    question4: string
    question5: string
    question6: string
    question7: string
    question8: string
    feedback: string
    rating: number
    creatdAt?: Date | string
    updatedAt?: Date | string
    appointment?: appointmentUncheckedCreateNestedManyWithoutFeedbackInput
    user?: userUncheckedCreateNestedManyWithoutFeedbackInput
  }

  export type feedbackUpdateInput = {
    feedbackID?: StringFieldUpdateOperationsInput | string
    therapistName?: StringFieldUpdateOperationsInput | string
    date?: StringFieldUpdateOperationsInput | string
    time?: StringFieldUpdateOperationsInput | string
    question1?: StringFieldUpdateOperationsInput | string
    question2?: StringFieldUpdateOperationsInput | string
    question3?: StringFieldUpdateOperationsInput | string
    question4?: StringFieldUpdateOperationsInput | string
    question5?: StringFieldUpdateOperationsInput | string
    question6?: StringFieldUpdateOperationsInput | string
    question7?: StringFieldUpdateOperationsInput | string
    question8?: StringFieldUpdateOperationsInput | string
    feedback?: StringFieldUpdateOperationsInput | string
    rating?: IntFieldUpdateOperationsInput | number
    creatdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    appointment?: appointmentUpdateManyWithoutFeedbackNestedInput
    user?: userUpdateManyWithoutFeedbackNestedInput
  }

  export type feedbackUncheckedUpdateInput = {
    feedbackID?: StringFieldUpdateOperationsInput | string
    therapistName?: StringFieldUpdateOperationsInput | string
    date?: StringFieldUpdateOperationsInput | string
    time?: StringFieldUpdateOperationsInput | string
    question1?: StringFieldUpdateOperationsInput | string
    question2?: StringFieldUpdateOperationsInput | string
    question3?: StringFieldUpdateOperationsInput | string
    question4?: StringFieldUpdateOperationsInput | string
    question5?: StringFieldUpdateOperationsInput | string
    question6?: StringFieldUpdateOperationsInput | string
    question7?: StringFieldUpdateOperationsInput | string
    question8?: StringFieldUpdateOperationsInput | string
    feedback?: StringFieldUpdateOperationsInput | string
    rating?: IntFieldUpdateOperationsInput | number
    creatdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    appointment?: appointmentUncheckedUpdateManyWithoutFeedbackNestedInput
    user?: userUncheckedUpdateManyWithoutFeedbackNestedInput
  }

  export type feedbackCreateManyInput = {
    feedbackID?: string
    therapistName: string
    date: string
    time: string
    question1: string
    question2: string
    question3: string
    question4: string
    question5: string
    question6: string
    question7: string
    question8: string
    feedback: string
    rating: number
    creatdAt?: Date | string
    updatedAt?: Date | string
  }

  export type feedbackUpdateManyMutationInput = {
    feedbackID?: StringFieldUpdateOperationsInput | string
    therapistName?: StringFieldUpdateOperationsInput | string
    date?: StringFieldUpdateOperationsInput | string
    time?: StringFieldUpdateOperationsInput | string
    question1?: StringFieldUpdateOperationsInput | string
    question2?: StringFieldUpdateOperationsInput | string
    question3?: StringFieldUpdateOperationsInput | string
    question4?: StringFieldUpdateOperationsInput | string
    question5?: StringFieldUpdateOperationsInput | string
    question6?: StringFieldUpdateOperationsInput | string
    question7?: StringFieldUpdateOperationsInput | string
    question8?: StringFieldUpdateOperationsInput | string
    feedback?: StringFieldUpdateOperationsInput | string
    rating?: IntFieldUpdateOperationsInput | number
    creatdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type feedbackUncheckedUpdateManyInput = {
    feedbackID?: StringFieldUpdateOperationsInput | string
    therapistName?: StringFieldUpdateOperationsInput | string
    date?: StringFieldUpdateOperationsInput | string
    time?: StringFieldUpdateOperationsInput | string
    question1?: StringFieldUpdateOperationsInput | string
    question2?: StringFieldUpdateOperationsInput | string
    question3?: StringFieldUpdateOperationsInput | string
    question4?: StringFieldUpdateOperationsInput | string
    question5?: StringFieldUpdateOperationsInput | string
    question6?: StringFieldUpdateOperationsInput | string
    question7?: StringFieldUpdateOperationsInput | string
    question8?: StringFieldUpdateOperationsInput | string
    feedback?: StringFieldUpdateOperationsInput | string
    rating?: IntFieldUpdateOperationsInput | number
    creatdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type prediagCreateInput = {
    prediagnosticID?: string
    age: string
    sex: string
    date: string
    time: string
    question1: string
    question2: string
    question3: string
    question4: string
    question5: string
    question6: string
    question7: string
    question8: string
    question9: string
    question10: string
    question11: string
    question12: string
    question13: string
    question14: string
    question15: string
    question16: string
    createdAt?: Date | string
    updatedAt?: Date | string
    user?: userCreateNestedOneWithoutPreDiagnosticInput
  }

  export type prediagUncheckedCreateInput = {
    prediagnosticID?: string
    age: string
    sex: string
    date: string
    time: string
    question1: string
    question2: string
    question3: string
    question4: string
    question5: string
    question6: string
    question7: string
    question8: string
    question9: string
    question10: string
    question11: string
    question12: string
    question13: string
    question14: string
    question15: string
    question16: string
    createdAt?: Date | string
    updatedAt?: Date | string
    userID?: string | null
  }

  export type prediagUpdateInput = {
    prediagnosticID?: StringFieldUpdateOperationsInput | string
    age?: StringFieldUpdateOperationsInput | string
    sex?: StringFieldUpdateOperationsInput | string
    date?: StringFieldUpdateOperationsInput | string
    time?: StringFieldUpdateOperationsInput | string
    question1?: StringFieldUpdateOperationsInput | string
    question2?: StringFieldUpdateOperationsInput | string
    question3?: StringFieldUpdateOperationsInput | string
    question4?: StringFieldUpdateOperationsInput | string
    question5?: StringFieldUpdateOperationsInput | string
    question6?: StringFieldUpdateOperationsInput | string
    question7?: StringFieldUpdateOperationsInput | string
    question8?: StringFieldUpdateOperationsInput | string
    question9?: StringFieldUpdateOperationsInput | string
    question10?: StringFieldUpdateOperationsInput | string
    question11?: StringFieldUpdateOperationsInput | string
    question12?: StringFieldUpdateOperationsInput | string
    question13?: StringFieldUpdateOperationsInput | string
    question14?: StringFieldUpdateOperationsInput | string
    question15?: StringFieldUpdateOperationsInput | string
    question16?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: userUpdateOneWithoutPreDiagnosticNestedInput
  }

  export type prediagUncheckedUpdateInput = {
    prediagnosticID?: StringFieldUpdateOperationsInput | string
    age?: StringFieldUpdateOperationsInput | string
    sex?: StringFieldUpdateOperationsInput | string
    date?: StringFieldUpdateOperationsInput | string
    time?: StringFieldUpdateOperationsInput | string
    question1?: StringFieldUpdateOperationsInput | string
    question2?: StringFieldUpdateOperationsInput | string
    question3?: StringFieldUpdateOperationsInput | string
    question4?: StringFieldUpdateOperationsInput | string
    question5?: StringFieldUpdateOperationsInput | string
    question6?: StringFieldUpdateOperationsInput | string
    question7?: StringFieldUpdateOperationsInput | string
    question8?: StringFieldUpdateOperationsInput | string
    question9?: StringFieldUpdateOperationsInput | string
    question10?: StringFieldUpdateOperationsInput | string
    question11?: StringFieldUpdateOperationsInput | string
    question12?: StringFieldUpdateOperationsInput | string
    question13?: StringFieldUpdateOperationsInput | string
    question14?: StringFieldUpdateOperationsInput | string
    question15?: StringFieldUpdateOperationsInput | string
    question16?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    userID?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type prediagCreateManyInput = {
    prediagnosticID?: string
    age: string
    sex: string
    date: string
    time: string
    question1: string
    question2: string
    question3: string
    question4: string
    question5: string
    question6: string
    question7: string
    question8: string
    question9: string
    question10: string
    question11: string
    question12: string
    question13: string
    question14: string
    question15: string
    question16: string
    createdAt?: Date | string
    updatedAt?: Date | string
    userID?: string | null
  }

  export type prediagUpdateManyMutationInput = {
    prediagnosticID?: StringFieldUpdateOperationsInput | string
    age?: StringFieldUpdateOperationsInput | string
    sex?: StringFieldUpdateOperationsInput | string
    date?: StringFieldUpdateOperationsInput | string
    time?: StringFieldUpdateOperationsInput | string
    question1?: StringFieldUpdateOperationsInput | string
    question2?: StringFieldUpdateOperationsInput | string
    question3?: StringFieldUpdateOperationsInput | string
    question4?: StringFieldUpdateOperationsInput | string
    question5?: StringFieldUpdateOperationsInput | string
    question6?: StringFieldUpdateOperationsInput | string
    question7?: StringFieldUpdateOperationsInput | string
    question8?: StringFieldUpdateOperationsInput | string
    question9?: StringFieldUpdateOperationsInput | string
    question10?: StringFieldUpdateOperationsInput | string
    question11?: StringFieldUpdateOperationsInput | string
    question12?: StringFieldUpdateOperationsInput | string
    question13?: StringFieldUpdateOperationsInput | string
    question14?: StringFieldUpdateOperationsInput | string
    question15?: StringFieldUpdateOperationsInput | string
    question16?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type prediagUncheckedUpdateManyInput = {
    prediagnosticID?: StringFieldUpdateOperationsInput | string
    age?: StringFieldUpdateOperationsInput | string
    sex?: StringFieldUpdateOperationsInput | string
    date?: StringFieldUpdateOperationsInput | string
    time?: StringFieldUpdateOperationsInput | string
    question1?: StringFieldUpdateOperationsInput | string
    question2?: StringFieldUpdateOperationsInput | string
    question3?: StringFieldUpdateOperationsInput | string
    question4?: StringFieldUpdateOperationsInput | string
    question5?: StringFieldUpdateOperationsInput | string
    question6?: StringFieldUpdateOperationsInput | string
    question7?: StringFieldUpdateOperationsInput | string
    question8?: StringFieldUpdateOperationsInput | string
    question9?: StringFieldUpdateOperationsInput | string
    question10?: StringFieldUpdateOperationsInput | string
    question11?: StringFieldUpdateOperationsInput | string
    question12?: StringFieldUpdateOperationsInput | string
    question13?: StringFieldUpdateOperationsInput | string
    question14?: StringFieldUpdateOperationsInput | string
    question15?: StringFieldUpdateOperationsInput | string
    question16?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    userID?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type StringFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedStringFilter<$PrismaModel> | string
  }

  export type EnumrolesFilter<$PrismaModel = never> = {
    equals?: $Enums.roles | EnumrolesFieldRefInput<$PrismaModel>
    in?: $Enums.roles[] | ListEnumrolesFieldRefInput<$PrismaModel>
    notIn?: $Enums.roles[] | ListEnumrolesFieldRefInput<$PrismaModel>
    not?: NestedEnumrolesFilter<$PrismaModel> | $Enums.roles
  }

  export type BoolFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolFilter<$PrismaModel> | boolean
  }

  export type DateTimeFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeFilter<$PrismaModel> | Date | string
  }

  export type ProfileNullableRelationFilter = {
    is?: profileWhereInput | null
    isNot?: profileWhereInput | null
  }

  export type BlogsListRelationFilter = {
    every?: blogsWhereInput
    some?: blogsWhereInput
    none?: blogsWhereInput
  }

  export type FaqsListRelationFilter = {
    every?: faqsWhereInput
    some?: faqsWhereInput
    none?: faqsWhereInput
  }

  export type EquipmentListRelationFilter = {
    every?: equipmentWhereInput
    some?: equipmentWhereInput
    none?: equipmentWhereInput
  }

  export type PresciptionListRelationFilter = {
    every?: presciptionWhereInput
    some?: presciptionWhereInput
    none?: presciptionWhereInput
  }

  export type FeedbackListRelationFilter = {
    every?: feedbackWhereInput
    some?: feedbackWhereInput
    none?: feedbackWhereInput
  }

  export type AppointmentListRelationFilter = {
    every?: appointmentWhereInput
    some?: appointmentWhereInput
    none?: appointmentWhereInput
  }

  export type DiagnosisListRelationFilter = {
    every?: diagnosisWhereInput
    some?: diagnosisWhereInput
    none?: diagnosisWhereInput
  }

  export type OtpListRelationFilter = {
    every?: otpWhereInput
    some?: otpWhereInput
    none?: otpWhereInput
  }

  export type ServicesListRelationFilter = {
    every?: servicesWhereInput
    some?: servicesWhereInput
    none?: servicesWhereInput
  }

  export type PrediagListRelationFilter = {
    every?: prediagWhereInput
    some?: prediagWhereInput
    none?: prediagWhereInput
  }

  export type blogsOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type faqsOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type equipmentOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type presciptionOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type feedbackOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type appointmentOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type diagnosisOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type otpOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type servicesOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type prediagOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type userCountOrderByAggregateInput = {
    userID?: SortOrder
    email?: SortOrder
    password?: SortOrder
    role?: SortOrder
    verified?: SortOrder
    creatdAt?: SortOrder
    updateAt?: SortOrder
  }

  export type userMaxOrderByAggregateInput = {
    userID?: SortOrder
    email?: SortOrder
    password?: SortOrder
    role?: SortOrder
    verified?: SortOrder
    creatdAt?: SortOrder
    updateAt?: SortOrder
  }

  export type userMinOrderByAggregateInput = {
    userID?: SortOrder
    email?: SortOrder
    password?: SortOrder
    role?: SortOrder
    verified?: SortOrder
    creatdAt?: SortOrder
    updateAt?: SortOrder
  }

  export type StringWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedStringWithAggregatesFilter<$PrismaModel> | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedStringFilter<$PrismaModel>
    _max?: NestedStringFilter<$PrismaModel>
  }

  export type EnumrolesWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.roles | EnumrolesFieldRefInput<$PrismaModel>
    in?: $Enums.roles[] | ListEnumrolesFieldRefInput<$PrismaModel>
    notIn?: $Enums.roles[] | ListEnumrolesFieldRefInput<$PrismaModel>
    not?: NestedEnumrolesWithAggregatesFilter<$PrismaModel> | $Enums.roles
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumrolesFilter<$PrismaModel>
    _max?: NestedEnumrolesFilter<$PrismaModel>
  }

  export type BoolWithAggregatesFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolWithAggregatesFilter<$PrismaModel> | boolean
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedBoolFilter<$PrismaModel>
    _max?: NestedBoolFilter<$PrismaModel>
  }

  export type DateTimeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeWithAggregatesFilter<$PrismaModel> | Date | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedDateTimeFilter<$PrismaModel>
    _max?: NestedDateTimeFilter<$PrismaModel>
  }

  export type FloatFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel>
    in?: number[] | ListFloatFieldRefInput<$PrismaModel>
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel>
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatFilter<$PrismaModel> | number
  }

  export type StringNullableFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedStringNullableFilter<$PrismaModel> | string | null
  }

  export type UserNullableRelationFilter = {
    is?: userWhereInput | null
    isNot?: userWhereInput | null
  }

  export type SortOrderInput = {
    sort: SortOrder
    nulls?: NullsOrder
  }

  export type servicesCountOrderByAggregateInput = {
    servicesID?: SortOrder
    services?: SortOrder
    descriptions?: SortOrder
    image?: SortOrder
    price?: SortOrder
    userID?: SortOrder
  }

  export type servicesAvgOrderByAggregateInput = {
    price?: SortOrder
  }

  export type servicesMaxOrderByAggregateInput = {
    servicesID?: SortOrder
    services?: SortOrder
    descriptions?: SortOrder
    image?: SortOrder
    price?: SortOrder
    userID?: SortOrder
  }

  export type servicesMinOrderByAggregateInput = {
    servicesID?: SortOrder
    services?: SortOrder
    descriptions?: SortOrder
    image?: SortOrder
    price?: SortOrder
    userID?: SortOrder
  }

  export type servicesSumOrderByAggregateInput = {
    price?: SortOrder
  }

  export type FloatWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel>
    in?: number[] | ListFloatFieldRefInput<$PrismaModel>
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel>
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatWithAggregatesFilter<$PrismaModel> | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedFloatFilter<$PrismaModel>
    _min?: NestedFloatFilter<$PrismaModel>
    _max?: NestedFloatFilter<$PrismaModel>
  }

  export type StringNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedStringNullableWithAggregatesFilter<$PrismaModel> | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedStringNullableFilter<$PrismaModel>
    _max?: NestedStringNullableFilter<$PrismaModel>
  }

  export type UserListRelationFilter = {
    every?: userWhereInput
    some?: userWhereInput
    none?: userWhereInput
  }

  export type userOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type otpCountOrderByAggregateInput = {
    otpID?: SortOrder
    otp?: SortOrder
    expiredAt?: SortOrder
    createdAt?: SortOrder
  }

  export type otpMaxOrderByAggregateInput = {
    otpID?: SortOrder
    otp?: SortOrder
    expiredAt?: SortOrder
    createdAt?: SortOrder
  }

  export type otpMinOrderByAggregateInput = {
    otpID?: SortOrder
    otp?: SortOrder
    expiredAt?: SortOrder
    createdAt?: SortOrder
  }

  export type EnumplatformFilter<$PrismaModel = never> = {
    equals?: $Enums.platform | EnumplatformFieldRefInput<$PrismaModel>
    in?: $Enums.platform[] | ListEnumplatformFieldRefInput<$PrismaModel>
    notIn?: $Enums.platform[] | ListEnumplatformFieldRefInput<$PrismaModel>
    not?: NestedEnumplatformFilter<$PrismaModel> | $Enums.platform
  }

  export type IntFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[] | ListIntFieldRefInput<$PrismaModel>
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel>
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntFilter<$PrismaModel> | number
  }

  export type EnumstatusFilter<$PrismaModel = never> = {
    equals?: $Enums.status | EnumstatusFieldRefInput<$PrismaModel>
    in?: $Enums.status[] | ListEnumstatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.status[] | ListEnumstatusFieldRefInput<$PrismaModel>
    not?: NestedEnumstatusFilter<$PrismaModel> | $Enums.status
  }

  export type FeedbackNullableRelationFilter = {
    is?: feedbackWhereInput | null
    isNot?: feedbackWhereInput | null
  }

  export type appointmentCountOrderByAggregateInput = {
    appointmentID?: SortOrder
    date?: SortOrder
    time?: SortOrder
    services?: SortOrder
    platform?: SortOrder
    link?: SortOrder
    amount?: SortOrder
    status?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    feedbackID?: SortOrder
  }

  export type appointmentAvgOrderByAggregateInput = {
    amount?: SortOrder
  }

  export type appointmentMaxOrderByAggregateInput = {
    appointmentID?: SortOrder
    date?: SortOrder
    time?: SortOrder
    services?: SortOrder
    platform?: SortOrder
    link?: SortOrder
    amount?: SortOrder
    status?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    feedbackID?: SortOrder
  }

  export type appointmentMinOrderByAggregateInput = {
    appointmentID?: SortOrder
    date?: SortOrder
    time?: SortOrder
    services?: SortOrder
    platform?: SortOrder
    link?: SortOrder
    amount?: SortOrder
    status?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    feedbackID?: SortOrder
  }

  export type appointmentSumOrderByAggregateInput = {
    amount?: SortOrder
  }

  export type EnumplatformWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.platform | EnumplatformFieldRefInput<$PrismaModel>
    in?: $Enums.platform[] | ListEnumplatformFieldRefInput<$PrismaModel>
    notIn?: $Enums.platform[] | ListEnumplatformFieldRefInput<$PrismaModel>
    not?: NestedEnumplatformWithAggregatesFilter<$PrismaModel> | $Enums.platform
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumplatformFilter<$PrismaModel>
    _max?: NestedEnumplatformFilter<$PrismaModel>
  }

  export type IntWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[] | ListIntFieldRefInput<$PrismaModel>
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel>
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntWithAggregatesFilter<$PrismaModel> | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedIntFilter<$PrismaModel>
    _min?: NestedIntFilter<$PrismaModel>
    _max?: NestedIntFilter<$PrismaModel>
  }

  export type EnumstatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.status | EnumstatusFieldRefInput<$PrismaModel>
    in?: $Enums.status[] | ListEnumstatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.status[] | ListEnumstatusFieldRefInput<$PrismaModel>
    not?: NestedEnumstatusWithAggregatesFilter<$PrismaModel> | $Enums.status
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumstatusFilter<$PrismaModel>
    _max?: NestedEnumstatusFilter<$PrismaModel>
  }

  export type EnuminventoryFilter<$PrismaModel = never> = {
    equals?: $Enums.inventory | EnuminventoryFieldRefInput<$PrismaModel>
    in?: $Enums.inventory[] | ListEnuminventoryFieldRefInput<$PrismaModel>
    notIn?: $Enums.inventory[] | ListEnuminventoryFieldRefInput<$PrismaModel>
    not?: NestedEnuminventoryFilter<$PrismaModel> | $Enums.inventory
  }

  export type equipmentCountOrderByAggregateInput = {
    equipmentID?: SortOrder
    name?: SortOrder
    inventory?: SortOrder
    description?: SortOrder
    quantity?: SortOrder
    expireDate?: SortOrder
    creatdAt?: SortOrder
    updateAt?: SortOrder
  }

  export type equipmentAvgOrderByAggregateInput = {
    quantity?: SortOrder
  }

  export type equipmentMaxOrderByAggregateInput = {
    equipmentID?: SortOrder
    name?: SortOrder
    inventory?: SortOrder
    description?: SortOrder
    quantity?: SortOrder
    expireDate?: SortOrder
    creatdAt?: SortOrder
    updateAt?: SortOrder
  }

  export type equipmentMinOrderByAggregateInput = {
    equipmentID?: SortOrder
    name?: SortOrder
    inventory?: SortOrder
    description?: SortOrder
    quantity?: SortOrder
    expireDate?: SortOrder
    creatdAt?: SortOrder
    updateAt?: SortOrder
  }

  export type equipmentSumOrderByAggregateInput = {
    quantity?: SortOrder
  }

  export type EnuminventoryWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.inventory | EnuminventoryFieldRefInput<$PrismaModel>
    in?: $Enums.inventory[] | ListEnuminventoryFieldRefInput<$PrismaModel>
    notIn?: $Enums.inventory[] | ListEnuminventoryFieldRefInput<$PrismaModel>
    not?: NestedEnuminventoryWithAggregatesFilter<$PrismaModel> | $Enums.inventory
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnuminventoryFilter<$PrismaModel>
    _max?: NestedEnuminventoryFilter<$PrismaModel>
  }

  export type blogsCountOrderByAggregateInput = {
    blogsID?: SortOrder
    title?: SortOrder
    content?: SortOrder
    expertise?: SortOrder
    image?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type blogsMaxOrderByAggregateInput = {
    blogsID?: SortOrder
    title?: SortOrder
    content?: SortOrder
    expertise?: SortOrder
    image?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type blogsMinOrderByAggregateInput = {
    blogsID?: SortOrder
    title?: SortOrder
    content?: SortOrder
    expertise?: SortOrder
    image?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type faqsCountOrderByAggregateInput = {
    faqsID?: SortOrder
    faqs?: SortOrder
    answer?: SortOrder
    creatdAt?: SortOrder
    updateAt?: SortOrder
  }

  export type faqsMaxOrderByAggregateInput = {
    faqsID?: SortOrder
    faqs?: SortOrder
    answer?: SortOrder
    creatdAt?: SortOrder
    updateAt?: SortOrder
  }

  export type faqsMinOrderByAggregateInput = {
    faqsID?: SortOrder
    faqs?: SortOrder
    answer?: SortOrder
    creatdAt?: SortOrder
    updateAt?: SortOrder
  }

  export type avatarCountOrderByAggregateInput = {
    avatarID?: SortOrder
    avatar?: SortOrder
    creatdAt?: SortOrder
    updateAt?: SortOrder
    profileID?: SortOrder
  }

  export type avatarMaxOrderByAggregateInput = {
    avatarID?: SortOrder
    avatar?: SortOrder
    creatdAt?: SortOrder
    updateAt?: SortOrder
    profileID?: SortOrder
  }

  export type avatarMinOrderByAggregateInput = {
    avatarID?: SortOrder
    avatar?: SortOrder
    creatdAt?: SortOrder
    updateAt?: SortOrder
    profileID?: SortOrder
  }

  export type AvatarNullableRelationFilter = {
    is?: avatarWhereInput | null
    isNot?: avatarWhereInput | null
  }

  export type profileCountOrderByAggregateInput = {
    profileID?: SortOrder
    firstname?: SortOrder
    lastname?: SortOrder
    phone?: SortOrder
    designation?: SortOrder
    expertise?: SortOrder
    emergencyPhone?: SortOrder
    userID?: SortOrder
  }

  export type profileMaxOrderByAggregateInput = {
    profileID?: SortOrder
    firstname?: SortOrder
    lastname?: SortOrder
    phone?: SortOrder
    designation?: SortOrder
    expertise?: SortOrder
    emergencyPhone?: SortOrder
    userID?: SortOrder
  }

  export type profileMinOrderByAggregateInput = {
    profileID?: SortOrder
    firstname?: SortOrder
    lastname?: SortOrder
    phone?: SortOrder
    designation?: SortOrder
    expertise?: SortOrder
    emergencyPhone?: SortOrder
    userID?: SortOrder
  }

  export type diagnosisCountOrderByAggregateInput = {
    diagnosisID?: SortOrder
    diagnosis?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    userID?: SortOrder
  }

  export type diagnosisMaxOrderByAggregateInput = {
    diagnosisID?: SortOrder
    diagnosis?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    userID?: SortOrder
  }

  export type diagnosisMinOrderByAggregateInput = {
    diagnosisID?: SortOrder
    diagnosis?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    userID?: SortOrder
  }

  export type presciptionCountOrderByAggregateInput = {
    prescriptionID?: SortOrder
    prescription?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    userID?: SortOrder
  }

  export type presciptionMaxOrderByAggregateInput = {
    prescriptionID?: SortOrder
    prescription?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    userID?: SortOrder
  }

  export type presciptionMinOrderByAggregateInput = {
    prescriptionID?: SortOrder
    prescription?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    userID?: SortOrder
  }

  export type feedbackCountOrderByAggregateInput = {
    feedbackID?: SortOrder
    therapistName?: SortOrder
    date?: SortOrder
    time?: SortOrder
    question1?: SortOrder
    question2?: SortOrder
    question3?: SortOrder
    question4?: SortOrder
    question5?: SortOrder
    question6?: SortOrder
    question7?: SortOrder
    question8?: SortOrder
    feedback?: SortOrder
    rating?: SortOrder
    creatdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type feedbackAvgOrderByAggregateInput = {
    rating?: SortOrder
  }

  export type feedbackMaxOrderByAggregateInput = {
    feedbackID?: SortOrder
    therapistName?: SortOrder
    date?: SortOrder
    time?: SortOrder
    question1?: SortOrder
    question2?: SortOrder
    question3?: SortOrder
    question4?: SortOrder
    question5?: SortOrder
    question6?: SortOrder
    question7?: SortOrder
    question8?: SortOrder
    feedback?: SortOrder
    rating?: SortOrder
    creatdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type feedbackMinOrderByAggregateInput = {
    feedbackID?: SortOrder
    therapistName?: SortOrder
    date?: SortOrder
    time?: SortOrder
    question1?: SortOrder
    question2?: SortOrder
    question3?: SortOrder
    question4?: SortOrder
    question5?: SortOrder
    question6?: SortOrder
    question7?: SortOrder
    question8?: SortOrder
    feedback?: SortOrder
    rating?: SortOrder
    creatdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type feedbackSumOrderByAggregateInput = {
    rating?: SortOrder
  }

  export type prediagCountOrderByAggregateInput = {
    prediagnosticID?: SortOrder
    age?: SortOrder
    sex?: SortOrder
    date?: SortOrder
    time?: SortOrder
    question1?: SortOrder
    question2?: SortOrder
    question3?: SortOrder
    question4?: SortOrder
    question5?: SortOrder
    question6?: SortOrder
    question7?: SortOrder
    question8?: SortOrder
    question9?: SortOrder
    question10?: SortOrder
    question11?: SortOrder
    question12?: SortOrder
    question13?: SortOrder
    question14?: SortOrder
    question15?: SortOrder
    question16?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    userID?: SortOrder
  }

  export type prediagMaxOrderByAggregateInput = {
    prediagnosticID?: SortOrder
    age?: SortOrder
    sex?: SortOrder
    date?: SortOrder
    time?: SortOrder
    question1?: SortOrder
    question2?: SortOrder
    question3?: SortOrder
    question4?: SortOrder
    question5?: SortOrder
    question6?: SortOrder
    question7?: SortOrder
    question8?: SortOrder
    question9?: SortOrder
    question10?: SortOrder
    question11?: SortOrder
    question12?: SortOrder
    question13?: SortOrder
    question14?: SortOrder
    question15?: SortOrder
    question16?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    userID?: SortOrder
  }

  export type prediagMinOrderByAggregateInput = {
    prediagnosticID?: SortOrder
    age?: SortOrder
    sex?: SortOrder
    date?: SortOrder
    time?: SortOrder
    question1?: SortOrder
    question2?: SortOrder
    question3?: SortOrder
    question4?: SortOrder
    question5?: SortOrder
    question6?: SortOrder
    question7?: SortOrder
    question8?: SortOrder
    question9?: SortOrder
    question10?: SortOrder
    question11?: SortOrder
    question12?: SortOrder
    question13?: SortOrder
    question14?: SortOrder
    question15?: SortOrder
    question16?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    userID?: SortOrder
  }

  export type profileCreateNestedOneWithoutUserInput = {
    create?: XOR<profileCreateWithoutUserInput, profileUncheckedCreateWithoutUserInput>
    connectOrCreate?: profileCreateOrConnectWithoutUserInput
    connect?: profileWhereUniqueInput
  }

  export type blogsCreateNestedManyWithoutUserInput = {
    create?: XOR<blogsCreateWithoutUserInput, blogsUncheckedCreateWithoutUserInput> | blogsCreateWithoutUserInput[] | blogsUncheckedCreateWithoutUserInput[]
    connectOrCreate?: blogsCreateOrConnectWithoutUserInput | blogsCreateOrConnectWithoutUserInput[]
    connect?: blogsWhereUniqueInput | blogsWhereUniqueInput[]
  }

  export type faqsCreateNestedManyWithoutUserInput = {
    create?: XOR<faqsCreateWithoutUserInput, faqsUncheckedCreateWithoutUserInput> | faqsCreateWithoutUserInput[] | faqsUncheckedCreateWithoutUserInput[]
    connectOrCreate?: faqsCreateOrConnectWithoutUserInput | faqsCreateOrConnectWithoutUserInput[]
    connect?: faqsWhereUniqueInput | faqsWhereUniqueInput[]
  }

  export type equipmentCreateNestedManyWithoutUserInput = {
    create?: XOR<equipmentCreateWithoutUserInput, equipmentUncheckedCreateWithoutUserInput> | equipmentCreateWithoutUserInput[] | equipmentUncheckedCreateWithoutUserInput[]
    connectOrCreate?: equipmentCreateOrConnectWithoutUserInput | equipmentCreateOrConnectWithoutUserInput[]
    connect?: equipmentWhereUniqueInput | equipmentWhereUniqueInput[]
  }

  export type presciptionCreateNestedManyWithoutPatinetInput = {
    create?: XOR<presciptionCreateWithoutPatinetInput, presciptionUncheckedCreateWithoutPatinetInput> | presciptionCreateWithoutPatinetInput[] | presciptionUncheckedCreateWithoutPatinetInput[]
    connectOrCreate?: presciptionCreateOrConnectWithoutPatinetInput | presciptionCreateOrConnectWithoutPatinetInput[]
    createMany?: presciptionCreateManyPatinetInputEnvelope
    connect?: presciptionWhereUniqueInput | presciptionWhereUniqueInput[]
  }

  export type feedbackCreateNestedManyWithoutUserInput = {
    create?: XOR<feedbackCreateWithoutUserInput, feedbackUncheckedCreateWithoutUserInput> | feedbackCreateWithoutUserInput[] | feedbackUncheckedCreateWithoutUserInput[]
    connectOrCreate?: feedbackCreateOrConnectWithoutUserInput | feedbackCreateOrConnectWithoutUserInput[]
    connect?: feedbackWhereUniqueInput | feedbackWhereUniqueInput[]
  }

  export type appointmentCreateNestedManyWithoutUserInput = {
    create?: XOR<appointmentCreateWithoutUserInput, appointmentUncheckedCreateWithoutUserInput> | appointmentCreateWithoutUserInput[] | appointmentUncheckedCreateWithoutUserInput[]
    connectOrCreate?: appointmentCreateOrConnectWithoutUserInput | appointmentCreateOrConnectWithoutUserInput[]
    connect?: appointmentWhereUniqueInput | appointmentWhereUniqueInput[]
  }

  export type diagnosisCreateNestedManyWithoutUserInput = {
    create?: XOR<diagnosisCreateWithoutUserInput, diagnosisUncheckedCreateWithoutUserInput> | diagnosisCreateWithoutUserInput[] | diagnosisUncheckedCreateWithoutUserInput[]
    connectOrCreate?: diagnosisCreateOrConnectWithoutUserInput | diagnosisCreateOrConnectWithoutUserInput[]
    createMany?: diagnosisCreateManyUserInputEnvelope
    connect?: diagnosisWhereUniqueInput | diagnosisWhereUniqueInput[]
  }

  export type otpCreateNestedManyWithoutUserInput = {
    create?: XOR<otpCreateWithoutUserInput, otpUncheckedCreateWithoutUserInput> | otpCreateWithoutUserInput[] | otpUncheckedCreateWithoutUserInput[]
    connectOrCreate?: otpCreateOrConnectWithoutUserInput | otpCreateOrConnectWithoutUserInput[]
    connect?: otpWhereUniqueInput | otpWhereUniqueInput[]
  }

  export type servicesCreateNestedManyWithoutUserInput = {
    create?: XOR<servicesCreateWithoutUserInput, servicesUncheckedCreateWithoutUserInput> | servicesCreateWithoutUserInput[] | servicesUncheckedCreateWithoutUserInput[]
    connectOrCreate?: servicesCreateOrConnectWithoutUserInput | servicesCreateOrConnectWithoutUserInput[]
    createMany?: servicesCreateManyUserInputEnvelope
    connect?: servicesWhereUniqueInput | servicesWhereUniqueInput[]
  }

  export type prediagCreateNestedManyWithoutUserInput = {
    create?: XOR<prediagCreateWithoutUserInput, prediagUncheckedCreateWithoutUserInput> | prediagCreateWithoutUserInput[] | prediagUncheckedCreateWithoutUserInput[]
    connectOrCreate?: prediagCreateOrConnectWithoutUserInput | prediagCreateOrConnectWithoutUserInput[]
    createMany?: prediagCreateManyUserInputEnvelope
    connect?: prediagWhereUniqueInput | prediagWhereUniqueInput[]
  }

  export type profileUncheckedCreateNestedOneWithoutUserInput = {
    create?: XOR<profileCreateWithoutUserInput, profileUncheckedCreateWithoutUserInput>
    connectOrCreate?: profileCreateOrConnectWithoutUserInput
    connect?: profileWhereUniqueInput
  }

  export type blogsUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<blogsCreateWithoutUserInput, blogsUncheckedCreateWithoutUserInput> | blogsCreateWithoutUserInput[] | blogsUncheckedCreateWithoutUserInput[]
    connectOrCreate?: blogsCreateOrConnectWithoutUserInput | blogsCreateOrConnectWithoutUserInput[]
    connect?: blogsWhereUniqueInput | blogsWhereUniqueInput[]
  }

  export type faqsUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<faqsCreateWithoutUserInput, faqsUncheckedCreateWithoutUserInput> | faqsCreateWithoutUserInput[] | faqsUncheckedCreateWithoutUserInput[]
    connectOrCreate?: faqsCreateOrConnectWithoutUserInput | faqsCreateOrConnectWithoutUserInput[]
    connect?: faqsWhereUniqueInput | faqsWhereUniqueInput[]
  }

  export type equipmentUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<equipmentCreateWithoutUserInput, equipmentUncheckedCreateWithoutUserInput> | equipmentCreateWithoutUserInput[] | equipmentUncheckedCreateWithoutUserInput[]
    connectOrCreate?: equipmentCreateOrConnectWithoutUserInput | equipmentCreateOrConnectWithoutUserInput[]
    connect?: equipmentWhereUniqueInput | equipmentWhereUniqueInput[]
  }

  export type presciptionUncheckedCreateNestedManyWithoutPatinetInput = {
    create?: XOR<presciptionCreateWithoutPatinetInput, presciptionUncheckedCreateWithoutPatinetInput> | presciptionCreateWithoutPatinetInput[] | presciptionUncheckedCreateWithoutPatinetInput[]
    connectOrCreate?: presciptionCreateOrConnectWithoutPatinetInput | presciptionCreateOrConnectWithoutPatinetInput[]
    createMany?: presciptionCreateManyPatinetInputEnvelope
    connect?: presciptionWhereUniqueInput | presciptionWhereUniqueInput[]
  }

  export type feedbackUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<feedbackCreateWithoutUserInput, feedbackUncheckedCreateWithoutUserInput> | feedbackCreateWithoutUserInput[] | feedbackUncheckedCreateWithoutUserInput[]
    connectOrCreate?: feedbackCreateOrConnectWithoutUserInput | feedbackCreateOrConnectWithoutUserInput[]
    connect?: feedbackWhereUniqueInput | feedbackWhereUniqueInput[]
  }

  export type appointmentUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<appointmentCreateWithoutUserInput, appointmentUncheckedCreateWithoutUserInput> | appointmentCreateWithoutUserInput[] | appointmentUncheckedCreateWithoutUserInput[]
    connectOrCreate?: appointmentCreateOrConnectWithoutUserInput | appointmentCreateOrConnectWithoutUserInput[]
    connect?: appointmentWhereUniqueInput | appointmentWhereUniqueInput[]
  }

  export type diagnosisUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<diagnosisCreateWithoutUserInput, diagnosisUncheckedCreateWithoutUserInput> | diagnosisCreateWithoutUserInput[] | diagnosisUncheckedCreateWithoutUserInput[]
    connectOrCreate?: diagnosisCreateOrConnectWithoutUserInput | diagnosisCreateOrConnectWithoutUserInput[]
    createMany?: diagnosisCreateManyUserInputEnvelope
    connect?: diagnosisWhereUniqueInput | diagnosisWhereUniqueInput[]
  }

  export type otpUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<otpCreateWithoutUserInput, otpUncheckedCreateWithoutUserInput> | otpCreateWithoutUserInput[] | otpUncheckedCreateWithoutUserInput[]
    connectOrCreate?: otpCreateOrConnectWithoutUserInput | otpCreateOrConnectWithoutUserInput[]
    connect?: otpWhereUniqueInput | otpWhereUniqueInput[]
  }

  export type servicesUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<servicesCreateWithoutUserInput, servicesUncheckedCreateWithoutUserInput> | servicesCreateWithoutUserInput[] | servicesUncheckedCreateWithoutUserInput[]
    connectOrCreate?: servicesCreateOrConnectWithoutUserInput | servicesCreateOrConnectWithoutUserInput[]
    createMany?: servicesCreateManyUserInputEnvelope
    connect?: servicesWhereUniqueInput | servicesWhereUniqueInput[]
  }

  export type prediagUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<prediagCreateWithoutUserInput, prediagUncheckedCreateWithoutUserInput> | prediagCreateWithoutUserInput[] | prediagUncheckedCreateWithoutUserInput[]
    connectOrCreate?: prediagCreateOrConnectWithoutUserInput | prediagCreateOrConnectWithoutUserInput[]
    createMany?: prediagCreateManyUserInputEnvelope
    connect?: prediagWhereUniqueInput | prediagWhereUniqueInput[]
  }

  export type StringFieldUpdateOperationsInput = {
    set?: string
  }

  export type EnumrolesFieldUpdateOperationsInput = {
    set?: $Enums.roles
  }

  export type BoolFieldUpdateOperationsInput = {
    set?: boolean
  }

  export type DateTimeFieldUpdateOperationsInput = {
    set?: Date | string
  }

  export type profileUpdateOneWithoutUserNestedInput = {
    create?: XOR<profileCreateWithoutUserInput, profileUncheckedCreateWithoutUserInput>
    connectOrCreate?: profileCreateOrConnectWithoutUserInput
    upsert?: profileUpsertWithoutUserInput
    disconnect?: profileWhereInput | boolean
    delete?: profileWhereInput | boolean
    connect?: profileWhereUniqueInput
    update?: XOR<XOR<profileUpdateToOneWithWhereWithoutUserInput, profileUpdateWithoutUserInput>, profileUncheckedUpdateWithoutUserInput>
  }

  export type blogsUpdateManyWithoutUserNestedInput = {
    create?: XOR<blogsCreateWithoutUserInput, blogsUncheckedCreateWithoutUserInput> | blogsCreateWithoutUserInput[] | blogsUncheckedCreateWithoutUserInput[]
    connectOrCreate?: blogsCreateOrConnectWithoutUserInput | blogsCreateOrConnectWithoutUserInput[]
    upsert?: blogsUpsertWithWhereUniqueWithoutUserInput | blogsUpsertWithWhereUniqueWithoutUserInput[]
    set?: blogsWhereUniqueInput | blogsWhereUniqueInput[]
    disconnect?: blogsWhereUniqueInput | blogsWhereUniqueInput[]
    delete?: blogsWhereUniqueInput | blogsWhereUniqueInput[]
    connect?: blogsWhereUniqueInput | blogsWhereUniqueInput[]
    update?: blogsUpdateWithWhereUniqueWithoutUserInput | blogsUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: blogsUpdateManyWithWhereWithoutUserInput | blogsUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: blogsScalarWhereInput | blogsScalarWhereInput[]
  }

  export type faqsUpdateManyWithoutUserNestedInput = {
    create?: XOR<faqsCreateWithoutUserInput, faqsUncheckedCreateWithoutUserInput> | faqsCreateWithoutUserInput[] | faqsUncheckedCreateWithoutUserInput[]
    connectOrCreate?: faqsCreateOrConnectWithoutUserInput | faqsCreateOrConnectWithoutUserInput[]
    upsert?: faqsUpsertWithWhereUniqueWithoutUserInput | faqsUpsertWithWhereUniqueWithoutUserInput[]
    set?: faqsWhereUniqueInput | faqsWhereUniqueInput[]
    disconnect?: faqsWhereUniqueInput | faqsWhereUniqueInput[]
    delete?: faqsWhereUniqueInput | faqsWhereUniqueInput[]
    connect?: faqsWhereUniqueInput | faqsWhereUniqueInput[]
    update?: faqsUpdateWithWhereUniqueWithoutUserInput | faqsUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: faqsUpdateManyWithWhereWithoutUserInput | faqsUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: faqsScalarWhereInput | faqsScalarWhereInput[]
  }

  export type equipmentUpdateManyWithoutUserNestedInput = {
    create?: XOR<equipmentCreateWithoutUserInput, equipmentUncheckedCreateWithoutUserInput> | equipmentCreateWithoutUserInput[] | equipmentUncheckedCreateWithoutUserInput[]
    connectOrCreate?: equipmentCreateOrConnectWithoutUserInput | equipmentCreateOrConnectWithoutUserInput[]
    upsert?: equipmentUpsertWithWhereUniqueWithoutUserInput | equipmentUpsertWithWhereUniqueWithoutUserInput[]
    set?: equipmentWhereUniqueInput | equipmentWhereUniqueInput[]
    disconnect?: equipmentWhereUniqueInput | equipmentWhereUniqueInput[]
    delete?: equipmentWhereUniqueInput | equipmentWhereUniqueInput[]
    connect?: equipmentWhereUniqueInput | equipmentWhereUniqueInput[]
    update?: equipmentUpdateWithWhereUniqueWithoutUserInput | equipmentUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: equipmentUpdateManyWithWhereWithoutUserInput | equipmentUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: equipmentScalarWhereInput | equipmentScalarWhereInput[]
  }

  export type presciptionUpdateManyWithoutPatinetNestedInput = {
    create?: XOR<presciptionCreateWithoutPatinetInput, presciptionUncheckedCreateWithoutPatinetInput> | presciptionCreateWithoutPatinetInput[] | presciptionUncheckedCreateWithoutPatinetInput[]
    connectOrCreate?: presciptionCreateOrConnectWithoutPatinetInput | presciptionCreateOrConnectWithoutPatinetInput[]
    upsert?: presciptionUpsertWithWhereUniqueWithoutPatinetInput | presciptionUpsertWithWhereUniqueWithoutPatinetInput[]
    createMany?: presciptionCreateManyPatinetInputEnvelope
    set?: presciptionWhereUniqueInput | presciptionWhereUniqueInput[]
    disconnect?: presciptionWhereUniqueInput | presciptionWhereUniqueInput[]
    delete?: presciptionWhereUniqueInput | presciptionWhereUniqueInput[]
    connect?: presciptionWhereUniqueInput | presciptionWhereUniqueInput[]
    update?: presciptionUpdateWithWhereUniqueWithoutPatinetInput | presciptionUpdateWithWhereUniqueWithoutPatinetInput[]
    updateMany?: presciptionUpdateManyWithWhereWithoutPatinetInput | presciptionUpdateManyWithWhereWithoutPatinetInput[]
    deleteMany?: presciptionScalarWhereInput | presciptionScalarWhereInput[]
  }

  export type feedbackUpdateManyWithoutUserNestedInput = {
    create?: XOR<feedbackCreateWithoutUserInput, feedbackUncheckedCreateWithoutUserInput> | feedbackCreateWithoutUserInput[] | feedbackUncheckedCreateWithoutUserInput[]
    connectOrCreate?: feedbackCreateOrConnectWithoutUserInput | feedbackCreateOrConnectWithoutUserInput[]
    upsert?: feedbackUpsertWithWhereUniqueWithoutUserInput | feedbackUpsertWithWhereUniqueWithoutUserInput[]
    set?: feedbackWhereUniqueInput | feedbackWhereUniqueInput[]
    disconnect?: feedbackWhereUniqueInput | feedbackWhereUniqueInput[]
    delete?: feedbackWhereUniqueInput | feedbackWhereUniqueInput[]
    connect?: feedbackWhereUniqueInput | feedbackWhereUniqueInput[]
    update?: feedbackUpdateWithWhereUniqueWithoutUserInput | feedbackUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: feedbackUpdateManyWithWhereWithoutUserInput | feedbackUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: feedbackScalarWhereInput | feedbackScalarWhereInput[]
  }

  export type appointmentUpdateManyWithoutUserNestedInput = {
    create?: XOR<appointmentCreateWithoutUserInput, appointmentUncheckedCreateWithoutUserInput> | appointmentCreateWithoutUserInput[] | appointmentUncheckedCreateWithoutUserInput[]
    connectOrCreate?: appointmentCreateOrConnectWithoutUserInput | appointmentCreateOrConnectWithoutUserInput[]
    upsert?: appointmentUpsertWithWhereUniqueWithoutUserInput | appointmentUpsertWithWhereUniqueWithoutUserInput[]
    set?: appointmentWhereUniqueInput | appointmentWhereUniqueInput[]
    disconnect?: appointmentWhereUniqueInput | appointmentWhereUniqueInput[]
    delete?: appointmentWhereUniqueInput | appointmentWhereUniqueInput[]
    connect?: appointmentWhereUniqueInput | appointmentWhereUniqueInput[]
    update?: appointmentUpdateWithWhereUniqueWithoutUserInput | appointmentUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: appointmentUpdateManyWithWhereWithoutUserInput | appointmentUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: appointmentScalarWhereInput | appointmentScalarWhereInput[]
  }

  export type diagnosisUpdateManyWithoutUserNestedInput = {
    create?: XOR<diagnosisCreateWithoutUserInput, diagnosisUncheckedCreateWithoutUserInput> | diagnosisCreateWithoutUserInput[] | diagnosisUncheckedCreateWithoutUserInput[]
    connectOrCreate?: diagnosisCreateOrConnectWithoutUserInput | diagnosisCreateOrConnectWithoutUserInput[]
    upsert?: diagnosisUpsertWithWhereUniqueWithoutUserInput | diagnosisUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: diagnosisCreateManyUserInputEnvelope
    set?: diagnosisWhereUniqueInput | diagnosisWhereUniqueInput[]
    disconnect?: diagnosisWhereUniqueInput | diagnosisWhereUniqueInput[]
    delete?: diagnosisWhereUniqueInput | diagnosisWhereUniqueInput[]
    connect?: diagnosisWhereUniqueInput | diagnosisWhereUniqueInput[]
    update?: diagnosisUpdateWithWhereUniqueWithoutUserInput | diagnosisUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: diagnosisUpdateManyWithWhereWithoutUserInput | diagnosisUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: diagnosisScalarWhereInput | diagnosisScalarWhereInput[]
  }

  export type otpUpdateManyWithoutUserNestedInput = {
    create?: XOR<otpCreateWithoutUserInput, otpUncheckedCreateWithoutUserInput> | otpCreateWithoutUserInput[] | otpUncheckedCreateWithoutUserInput[]
    connectOrCreate?: otpCreateOrConnectWithoutUserInput | otpCreateOrConnectWithoutUserInput[]
    upsert?: otpUpsertWithWhereUniqueWithoutUserInput | otpUpsertWithWhereUniqueWithoutUserInput[]
    set?: otpWhereUniqueInput | otpWhereUniqueInput[]
    disconnect?: otpWhereUniqueInput | otpWhereUniqueInput[]
    delete?: otpWhereUniqueInput | otpWhereUniqueInput[]
    connect?: otpWhereUniqueInput | otpWhereUniqueInput[]
    update?: otpUpdateWithWhereUniqueWithoutUserInput | otpUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: otpUpdateManyWithWhereWithoutUserInput | otpUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: otpScalarWhereInput | otpScalarWhereInput[]
  }

  export type servicesUpdateManyWithoutUserNestedInput = {
    create?: XOR<servicesCreateWithoutUserInput, servicesUncheckedCreateWithoutUserInput> | servicesCreateWithoutUserInput[] | servicesUncheckedCreateWithoutUserInput[]
    connectOrCreate?: servicesCreateOrConnectWithoutUserInput | servicesCreateOrConnectWithoutUserInput[]
    upsert?: servicesUpsertWithWhereUniqueWithoutUserInput | servicesUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: servicesCreateManyUserInputEnvelope
    set?: servicesWhereUniqueInput | servicesWhereUniqueInput[]
    disconnect?: servicesWhereUniqueInput | servicesWhereUniqueInput[]
    delete?: servicesWhereUniqueInput | servicesWhereUniqueInput[]
    connect?: servicesWhereUniqueInput | servicesWhereUniqueInput[]
    update?: servicesUpdateWithWhereUniqueWithoutUserInput | servicesUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: servicesUpdateManyWithWhereWithoutUserInput | servicesUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: servicesScalarWhereInput | servicesScalarWhereInput[]
  }

  export type prediagUpdateManyWithoutUserNestedInput = {
    create?: XOR<prediagCreateWithoutUserInput, prediagUncheckedCreateWithoutUserInput> | prediagCreateWithoutUserInput[] | prediagUncheckedCreateWithoutUserInput[]
    connectOrCreate?: prediagCreateOrConnectWithoutUserInput | prediagCreateOrConnectWithoutUserInput[]
    upsert?: prediagUpsertWithWhereUniqueWithoutUserInput | prediagUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: prediagCreateManyUserInputEnvelope
    set?: prediagWhereUniqueInput | prediagWhereUniqueInput[]
    disconnect?: prediagWhereUniqueInput | prediagWhereUniqueInput[]
    delete?: prediagWhereUniqueInput | prediagWhereUniqueInput[]
    connect?: prediagWhereUniqueInput | prediagWhereUniqueInput[]
    update?: prediagUpdateWithWhereUniqueWithoutUserInput | prediagUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: prediagUpdateManyWithWhereWithoutUserInput | prediagUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: prediagScalarWhereInput | prediagScalarWhereInput[]
  }

  export type profileUncheckedUpdateOneWithoutUserNestedInput = {
    create?: XOR<profileCreateWithoutUserInput, profileUncheckedCreateWithoutUserInput>
    connectOrCreate?: profileCreateOrConnectWithoutUserInput
    upsert?: profileUpsertWithoutUserInput
    disconnect?: profileWhereInput | boolean
    delete?: profileWhereInput | boolean
    connect?: profileWhereUniqueInput
    update?: XOR<XOR<profileUpdateToOneWithWhereWithoutUserInput, profileUpdateWithoutUserInput>, profileUncheckedUpdateWithoutUserInput>
  }

  export type blogsUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<blogsCreateWithoutUserInput, blogsUncheckedCreateWithoutUserInput> | blogsCreateWithoutUserInput[] | blogsUncheckedCreateWithoutUserInput[]
    connectOrCreate?: blogsCreateOrConnectWithoutUserInput | blogsCreateOrConnectWithoutUserInput[]
    upsert?: blogsUpsertWithWhereUniqueWithoutUserInput | blogsUpsertWithWhereUniqueWithoutUserInput[]
    set?: blogsWhereUniqueInput | blogsWhereUniqueInput[]
    disconnect?: blogsWhereUniqueInput | blogsWhereUniqueInput[]
    delete?: blogsWhereUniqueInput | blogsWhereUniqueInput[]
    connect?: blogsWhereUniqueInput | blogsWhereUniqueInput[]
    update?: blogsUpdateWithWhereUniqueWithoutUserInput | blogsUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: blogsUpdateManyWithWhereWithoutUserInput | blogsUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: blogsScalarWhereInput | blogsScalarWhereInput[]
  }

  export type faqsUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<faqsCreateWithoutUserInput, faqsUncheckedCreateWithoutUserInput> | faqsCreateWithoutUserInput[] | faqsUncheckedCreateWithoutUserInput[]
    connectOrCreate?: faqsCreateOrConnectWithoutUserInput | faqsCreateOrConnectWithoutUserInput[]
    upsert?: faqsUpsertWithWhereUniqueWithoutUserInput | faqsUpsertWithWhereUniqueWithoutUserInput[]
    set?: faqsWhereUniqueInput | faqsWhereUniqueInput[]
    disconnect?: faqsWhereUniqueInput | faqsWhereUniqueInput[]
    delete?: faqsWhereUniqueInput | faqsWhereUniqueInput[]
    connect?: faqsWhereUniqueInput | faqsWhereUniqueInput[]
    update?: faqsUpdateWithWhereUniqueWithoutUserInput | faqsUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: faqsUpdateManyWithWhereWithoutUserInput | faqsUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: faqsScalarWhereInput | faqsScalarWhereInput[]
  }

  export type equipmentUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<equipmentCreateWithoutUserInput, equipmentUncheckedCreateWithoutUserInput> | equipmentCreateWithoutUserInput[] | equipmentUncheckedCreateWithoutUserInput[]
    connectOrCreate?: equipmentCreateOrConnectWithoutUserInput | equipmentCreateOrConnectWithoutUserInput[]
    upsert?: equipmentUpsertWithWhereUniqueWithoutUserInput | equipmentUpsertWithWhereUniqueWithoutUserInput[]
    set?: equipmentWhereUniqueInput | equipmentWhereUniqueInput[]
    disconnect?: equipmentWhereUniqueInput | equipmentWhereUniqueInput[]
    delete?: equipmentWhereUniqueInput | equipmentWhereUniqueInput[]
    connect?: equipmentWhereUniqueInput | equipmentWhereUniqueInput[]
    update?: equipmentUpdateWithWhereUniqueWithoutUserInput | equipmentUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: equipmentUpdateManyWithWhereWithoutUserInput | equipmentUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: equipmentScalarWhereInput | equipmentScalarWhereInput[]
  }

  export type presciptionUncheckedUpdateManyWithoutPatinetNestedInput = {
    create?: XOR<presciptionCreateWithoutPatinetInput, presciptionUncheckedCreateWithoutPatinetInput> | presciptionCreateWithoutPatinetInput[] | presciptionUncheckedCreateWithoutPatinetInput[]
    connectOrCreate?: presciptionCreateOrConnectWithoutPatinetInput | presciptionCreateOrConnectWithoutPatinetInput[]
    upsert?: presciptionUpsertWithWhereUniqueWithoutPatinetInput | presciptionUpsertWithWhereUniqueWithoutPatinetInput[]
    createMany?: presciptionCreateManyPatinetInputEnvelope
    set?: presciptionWhereUniqueInput | presciptionWhereUniqueInput[]
    disconnect?: presciptionWhereUniqueInput | presciptionWhereUniqueInput[]
    delete?: presciptionWhereUniqueInput | presciptionWhereUniqueInput[]
    connect?: presciptionWhereUniqueInput | presciptionWhereUniqueInput[]
    update?: presciptionUpdateWithWhereUniqueWithoutPatinetInput | presciptionUpdateWithWhereUniqueWithoutPatinetInput[]
    updateMany?: presciptionUpdateManyWithWhereWithoutPatinetInput | presciptionUpdateManyWithWhereWithoutPatinetInput[]
    deleteMany?: presciptionScalarWhereInput | presciptionScalarWhereInput[]
  }

  export type feedbackUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<feedbackCreateWithoutUserInput, feedbackUncheckedCreateWithoutUserInput> | feedbackCreateWithoutUserInput[] | feedbackUncheckedCreateWithoutUserInput[]
    connectOrCreate?: feedbackCreateOrConnectWithoutUserInput | feedbackCreateOrConnectWithoutUserInput[]
    upsert?: feedbackUpsertWithWhereUniqueWithoutUserInput | feedbackUpsertWithWhereUniqueWithoutUserInput[]
    set?: feedbackWhereUniqueInput | feedbackWhereUniqueInput[]
    disconnect?: feedbackWhereUniqueInput | feedbackWhereUniqueInput[]
    delete?: feedbackWhereUniqueInput | feedbackWhereUniqueInput[]
    connect?: feedbackWhereUniqueInput | feedbackWhereUniqueInput[]
    update?: feedbackUpdateWithWhereUniqueWithoutUserInput | feedbackUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: feedbackUpdateManyWithWhereWithoutUserInput | feedbackUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: feedbackScalarWhereInput | feedbackScalarWhereInput[]
  }

  export type appointmentUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<appointmentCreateWithoutUserInput, appointmentUncheckedCreateWithoutUserInput> | appointmentCreateWithoutUserInput[] | appointmentUncheckedCreateWithoutUserInput[]
    connectOrCreate?: appointmentCreateOrConnectWithoutUserInput | appointmentCreateOrConnectWithoutUserInput[]
    upsert?: appointmentUpsertWithWhereUniqueWithoutUserInput | appointmentUpsertWithWhereUniqueWithoutUserInput[]
    set?: appointmentWhereUniqueInput | appointmentWhereUniqueInput[]
    disconnect?: appointmentWhereUniqueInput | appointmentWhereUniqueInput[]
    delete?: appointmentWhereUniqueInput | appointmentWhereUniqueInput[]
    connect?: appointmentWhereUniqueInput | appointmentWhereUniqueInput[]
    update?: appointmentUpdateWithWhereUniqueWithoutUserInput | appointmentUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: appointmentUpdateManyWithWhereWithoutUserInput | appointmentUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: appointmentScalarWhereInput | appointmentScalarWhereInput[]
  }

  export type diagnosisUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<diagnosisCreateWithoutUserInput, diagnosisUncheckedCreateWithoutUserInput> | diagnosisCreateWithoutUserInput[] | diagnosisUncheckedCreateWithoutUserInput[]
    connectOrCreate?: diagnosisCreateOrConnectWithoutUserInput | diagnosisCreateOrConnectWithoutUserInput[]
    upsert?: diagnosisUpsertWithWhereUniqueWithoutUserInput | diagnosisUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: diagnosisCreateManyUserInputEnvelope
    set?: diagnosisWhereUniqueInput | diagnosisWhereUniqueInput[]
    disconnect?: diagnosisWhereUniqueInput | diagnosisWhereUniqueInput[]
    delete?: diagnosisWhereUniqueInput | diagnosisWhereUniqueInput[]
    connect?: diagnosisWhereUniqueInput | diagnosisWhereUniqueInput[]
    update?: diagnosisUpdateWithWhereUniqueWithoutUserInput | diagnosisUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: diagnosisUpdateManyWithWhereWithoutUserInput | diagnosisUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: diagnosisScalarWhereInput | diagnosisScalarWhereInput[]
  }

  export type otpUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<otpCreateWithoutUserInput, otpUncheckedCreateWithoutUserInput> | otpCreateWithoutUserInput[] | otpUncheckedCreateWithoutUserInput[]
    connectOrCreate?: otpCreateOrConnectWithoutUserInput | otpCreateOrConnectWithoutUserInput[]
    upsert?: otpUpsertWithWhereUniqueWithoutUserInput | otpUpsertWithWhereUniqueWithoutUserInput[]
    set?: otpWhereUniqueInput | otpWhereUniqueInput[]
    disconnect?: otpWhereUniqueInput | otpWhereUniqueInput[]
    delete?: otpWhereUniqueInput | otpWhereUniqueInput[]
    connect?: otpWhereUniqueInput | otpWhereUniqueInput[]
    update?: otpUpdateWithWhereUniqueWithoutUserInput | otpUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: otpUpdateManyWithWhereWithoutUserInput | otpUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: otpScalarWhereInput | otpScalarWhereInput[]
  }

  export type servicesUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<servicesCreateWithoutUserInput, servicesUncheckedCreateWithoutUserInput> | servicesCreateWithoutUserInput[] | servicesUncheckedCreateWithoutUserInput[]
    connectOrCreate?: servicesCreateOrConnectWithoutUserInput | servicesCreateOrConnectWithoutUserInput[]
    upsert?: servicesUpsertWithWhereUniqueWithoutUserInput | servicesUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: servicesCreateManyUserInputEnvelope
    set?: servicesWhereUniqueInput | servicesWhereUniqueInput[]
    disconnect?: servicesWhereUniqueInput | servicesWhereUniqueInput[]
    delete?: servicesWhereUniqueInput | servicesWhereUniqueInput[]
    connect?: servicesWhereUniqueInput | servicesWhereUniqueInput[]
    update?: servicesUpdateWithWhereUniqueWithoutUserInput | servicesUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: servicesUpdateManyWithWhereWithoutUserInput | servicesUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: servicesScalarWhereInput | servicesScalarWhereInput[]
  }

  export type prediagUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<prediagCreateWithoutUserInput, prediagUncheckedCreateWithoutUserInput> | prediagCreateWithoutUserInput[] | prediagUncheckedCreateWithoutUserInput[]
    connectOrCreate?: prediagCreateOrConnectWithoutUserInput | prediagCreateOrConnectWithoutUserInput[]
    upsert?: prediagUpsertWithWhereUniqueWithoutUserInput | prediagUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: prediagCreateManyUserInputEnvelope
    set?: prediagWhereUniqueInput | prediagWhereUniqueInput[]
    disconnect?: prediagWhereUniqueInput | prediagWhereUniqueInput[]
    delete?: prediagWhereUniqueInput | prediagWhereUniqueInput[]
    connect?: prediagWhereUniqueInput | prediagWhereUniqueInput[]
    update?: prediagUpdateWithWhereUniqueWithoutUserInput | prediagUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: prediagUpdateManyWithWhereWithoutUserInput | prediagUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: prediagScalarWhereInput | prediagScalarWhereInput[]
  }

  export type userCreateNestedOneWithoutServicesInput = {
    create?: XOR<userCreateWithoutServicesInput, userUncheckedCreateWithoutServicesInput>
    connectOrCreate?: userCreateOrConnectWithoutServicesInput
    connect?: userWhereUniqueInput
  }

  export type appointmentCreateNestedManyWithoutServiceInput = {
    create?: XOR<appointmentCreateWithoutServiceInput, appointmentUncheckedCreateWithoutServiceInput> | appointmentCreateWithoutServiceInput[] | appointmentUncheckedCreateWithoutServiceInput[]
    connectOrCreate?: appointmentCreateOrConnectWithoutServiceInput | appointmentCreateOrConnectWithoutServiceInput[]
    connect?: appointmentWhereUniqueInput | appointmentWhereUniqueInput[]
  }

  export type appointmentUncheckedCreateNestedManyWithoutServiceInput = {
    create?: XOR<appointmentCreateWithoutServiceInput, appointmentUncheckedCreateWithoutServiceInput> | appointmentCreateWithoutServiceInput[] | appointmentUncheckedCreateWithoutServiceInput[]
    connectOrCreate?: appointmentCreateOrConnectWithoutServiceInput | appointmentCreateOrConnectWithoutServiceInput[]
    connect?: appointmentWhereUniqueInput | appointmentWhereUniqueInput[]
  }

  export type FloatFieldUpdateOperationsInput = {
    set?: number
    increment?: number
    decrement?: number
    multiply?: number
    divide?: number
  }

  export type userUpdateOneWithoutServicesNestedInput = {
    create?: XOR<userCreateWithoutServicesInput, userUncheckedCreateWithoutServicesInput>
    connectOrCreate?: userCreateOrConnectWithoutServicesInput
    upsert?: userUpsertWithoutServicesInput
    disconnect?: userWhereInput | boolean
    delete?: userWhereInput | boolean
    connect?: userWhereUniqueInput
    update?: XOR<XOR<userUpdateToOneWithWhereWithoutServicesInput, userUpdateWithoutServicesInput>, userUncheckedUpdateWithoutServicesInput>
  }

  export type appointmentUpdateManyWithoutServiceNestedInput = {
    create?: XOR<appointmentCreateWithoutServiceInput, appointmentUncheckedCreateWithoutServiceInput> | appointmentCreateWithoutServiceInput[] | appointmentUncheckedCreateWithoutServiceInput[]
    connectOrCreate?: appointmentCreateOrConnectWithoutServiceInput | appointmentCreateOrConnectWithoutServiceInput[]
    upsert?: appointmentUpsertWithWhereUniqueWithoutServiceInput | appointmentUpsertWithWhereUniqueWithoutServiceInput[]
    set?: appointmentWhereUniqueInput | appointmentWhereUniqueInput[]
    disconnect?: appointmentWhereUniqueInput | appointmentWhereUniqueInput[]
    delete?: appointmentWhereUniqueInput | appointmentWhereUniqueInput[]
    connect?: appointmentWhereUniqueInput | appointmentWhereUniqueInput[]
    update?: appointmentUpdateWithWhereUniqueWithoutServiceInput | appointmentUpdateWithWhereUniqueWithoutServiceInput[]
    updateMany?: appointmentUpdateManyWithWhereWithoutServiceInput | appointmentUpdateManyWithWhereWithoutServiceInput[]
    deleteMany?: appointmentScalarWhereInput | appointmentScalarWhereInput[]
  }

  export type NullableStringFieldUpdateOperationsInput = {
    set?: string | null
  }

  export type appointmentUncheckedUpdateManyWithoutServiceNestedInput = {
    create?: XOR<appointmentCreateWithoutServiceInput, appointmentUncheckedCreateWithoutServiceInput> | appointmentCreateWithoutServiceInput[] | appointmentUncheckedCreateWithoutServiceInput[]
    connectOrCreate?: appointmentCreateOrConnectWithoutServiceInput | appointmentCreateOrConnectWithoutServiceInput[]
    upsert?: appointmentUpsertWithWhereUniqueWithoutServiceInput | appointmentUpsertWithWhereUniqueWithoutServiceInput[]
    set?: appointmentWhereUniqueInput | appointmentWhereUniqueInput[]
    disconnect?: appointmentWhereUniqueInput | appointmentWhereUniqueInput[]
    delete?: appointmentWhereUniqueInput | appointmentWhereUniqueInput[]
    connect?: appointmentWhereUniqueInput | appointmentWhereUniqueInput[]
    update?: appointmentUpdateWithWhereUniqueWithoutServiceInput | appointmentUpdateWithWhereUniqueWithoutServiceInput[]
    updateMany?: appointmentUpdateManyWithWhereWithoutServiceInput | appointmentUpdateManyWithWhereWithoutServiceInput[]
    deleteMany?: appointmentScalarWhereInput | appointmentScalarWhereInput[]
  }

  export type userCreateNestedManyWithoutOtpInput = {
    create?: XOR<userCreateWithoutOtpInput, userUncheckedCreateWithoutOtpInput> | userCreateWithoutOtpInput[] | userUncheckedCreateWithoutOtpInput[]
    connectOrCreate?: userCreateOrConnectWithoutOtpInput | userCreateOrConnectWithoutOtpInput[]
    connect?: userWhereUniqueInput | userWhereUniqueInput[]
  }

  export type userUncheckedCreateNestedManyWithoutOtpInput = {
    create?: XOR<userCreateWithoutOtpInput, userUncheckedCreateWithoutOtpInput> | userCreateWithoutOtpInput[] | userUncheckedCreateWithoutOtpInput[]
    connectOrCreate?: userCreateOrConnectWithoutOtpInput | userCreateOrConnectWithoutOtpInput[]
    connect?: userWhereUniqueInput | userWhereUniqueInput[]
  }

  export type userUpdateManyWithoutOtpNestedInput = {
    create?: XOR<userCreateWithoutOtpInput, userUncheckedCreateWithoutOtpInput> | userCreateWithoutOtpInput[] | userUncheckedCreateWithoutOtpInput[]
    connectOrCreate?: userCreateOrConnectWithoutOtpInput | userCreateOrConnectWithoutOtpInput[]
    upsert?: userUpsertWithWhereUniqueWithoutOtpInput | userUpsertWithWhereUniqueWithoutOtpInput[]
    set?: userWhereUniqueInput | userWhereUniqueInput[]
    disconnect?: userWhereUniqueInput | userWhereUniqueInput[]
    delete?: userWhereUniqueInput | userWhereUniqueInput[]
    connect?: userWhereUniqueInput | userWhereUniqueInput[]
    update?: userUpdateWithWhereUniqueWithoutOtpInput | userUpdateWithWhereUniqueWithoutOtpInput[]
    updateMany?: userUpdateManyWithWhereWithoutOtpInput | userUpdateManyWithWhereWithoutOtpInput[]
    deleteMany?: userScalarWhereInput | userScalarWhereInput[]
  }

  export type userUncheckedUpdateManyWithoutOtpNestedInput = {
    create?: XOR<userCreateWithoutOtpInput, userUncheckedCreateWithoutOtpInput> | userCreateWithoutOtpInput[] | userUncheckedCreateWithoutOtpInput[]
    connectOrCreate?: userCreateOrConnectWithoutOtpInput | userCreateOrConnectWithoutOtpInput[]
    upsert?: userUpsertWithWhereUniqueWithoutOtpInput | userUpsertWithWhereUniqueWithoutOtpInput[]
    set?: userWhereUniqueInput | userWhereUniqueInput[]
    disconnect?: userWhereUniqueInput | userWhereUniqueInput[]
    delete?: userWhereUniqueInput | userWhereUniqueInput[]
    connect?: userWhereUniqueInput | userWhereUniqueInput[]
    update?: userUpdateWithWhereUniqueWithoutOtpInput | userUpdateWithWhereUniqueWithoutOtpInput[]
    updateMany?: userUpdateManyWithWhereWithoutOtpInput | userUpdateManyWithWhereWithoutOtpInput[]
    deleteMany?: userScalarWhereInput | userScalarWhereInput[]
  }

  export type userCreateNestedManyWithoutAppointmentInput = {
    create?: XOR<userCreateWithoutAppointmentInput, userUncheckedCreateWithoutAppointmentInput> | userCreateWithoutAppointmentInput[] | userUncheckedCreateWithoutAppointmentInput[]
    connectOrCreate?: userCreateOrConnectWithoutAppointmentInput | userCreateOrConnectWithoutAppointmentInput[]
    connect?: userWhereUniqueInput | userWhereUniqueInput[]
  }

  export type feedbackCreateNestedOneWithoutAppointmentInput = {
    create?: XOR<feedbackCreateWithoutAppointmentInput, feedbackUncheckedCreateWithoutAppointmentInput>
    connectOrCreate?: feedbackCreateOrConnectWithoutAppointmentInput
    connect?: feedbackWhereUniqueInput
  }

  export type servicesCreateNestedManyWithoutAppointmentInput = {
    create?: XOR<servicesCreateWithoutAppointmentInput, servicesUncheckedCreateWithoutAppointmentInput> | servicesCreateWithoutAppointmentInput[] | servicesUncheckedCreateWithoutAppointmentInput[]
    connectOrCreate?: servicesCreateOrConnectWithoutAppointmentInput | servicesCreateOrConnectWithoutAppointmentInput[]
    connect?: servicesWhereUniqueInput | servicesWhereUniqueInput[]
  }

  export type userUncheckedCreateNestedManyWithoutAppointmentInput = {
    create?: XOR<userCreateWithoutAppointmentInput, userUncheckedCreateWithoutAppointmentInput> | userCreateWithoutAppointmentInput[] | userUncheckedCreateWithoutAppointmentInput[]
    connectOrCreate?: userCreateOrConnectWithoutAppointmentInput | userCreateOrConnectWithoutAppointmentInput[]
    connect?: userWhereUniqueInput | userWhereUniqueInput[]
  }

  export type servicesUncheckedCreateNestedManyWithoutAppointmentInput = {
    create?: XOR<servicesCreateWithoutAppointmentInput, servicesUncheckedCreateWithoutAppointmentInput> | servicesCreateWithoutAppointmentInput[] | servicesUncheckedCreateWithoutAppointmentInput[]
    connectOrCreate?: servicesCreateOrConnectWithoutAppointmentInput | servicesCreateOrConnectWithoutAppointmentInput[]
    connect?: servicesWhereUniqueInput | servicesWhereUniqueInput[]
  }

  export type EnumplatformFieldUpdateOperationsInput = {
    set?: $Enums.platform
  }

  export type IntFieldUpdateOperationsInput = {
    set?: number
    increment?: number
    decrement?: number
    multiply?: number
    divide?: number
  }

  export type EnumstatusFieldUpdateOperationsInput = {
    set?: $Enums.status
  }

  export type userUpdateManyWithoutAppointmentNestedInput = {
    create?: XOR<userCreateWithoutAppointmentInput, userUncheckedCreateWithoutAppointmentInput> | userCreateWithoutAppointmentInput[] | userUncheckedCreateWithoutAppointmentInput[]
    connectOrCreate?: userCreateOrConnectWithoutAppointmentInput | userCreateOrConnectWithoutAppointmentInput[]
    upsert?: userUpsertWithWhereUniqueWithoutAppointmentInput | userUpsertWithWhereUniqueWithoutAppointmentInput[]
    set?: userWhereUniqueInput | userWhereUniqueInput[]
    disconnect?: userWhereUniqueInput | userWhereUniqueInput[]
    delete?: userWhereUniqueInput | userWhereUniqueInput[]
    connect?: userWhereUniqueInput | userWhereUniqueInput[]
    update?: userUpdateWithWhereUniqueWithoutAppointmentInput | userUpdateWithWhereUniqueWithoutAppointmentInput[]
    updateMany?: userUpdateManyWithWhereWithoutAppointmentInput | userUpdateManyWithWhereWithoutAppointmentInput[]
    deleteMany?: userScalarWhereInput | userScalarWhereInput[]
  }

  export type feedbackUpdateOneWithoutAppointmentNestedInput = {
    create?: XOR<feedbackCreateWithoutAppointmentInput, feedbackUncheckedCreateWithoutAppointmentInput>
    connectOrCreate?: feedbackCreateOrConnectWithoutAppointmentInput
    upsert?: feedbackUpsertWithoutAppointmentInput
    disconnect?: feedbackWhereInput | boolean
    delete?: feedbackWhereInput | boolean
    connect?: feedbackWhereUniqueInput
    update?: XOR<XOR<feedbackUpdateToOneWithWhereWithoutAppointmentInput, feedbackUpdateWithoutAppointmentInput>, feedbackUncheckedUpdateWithoutAppointmentInput>
  }

  export type servicesUpdateManyWithoutAppointmentNestedInput = {
    create?: XOR<servicesCreateWithoutAppointmentInput, servicesUncheckedCreateWithoutAppointmentInput> | servicesCreateWithoutAppointmentInput[] | servicesUncheckedCreateWithoutAppointmentInput[]
    connectOrCreate?: servicesCreateOrConnectWithoutAppointmentInput | servicesCreateOrConnectWithoutAppointmentInput[]
    upsert?: servicesUpsertWithWhereUniqueWithoutAppointmentInput | servicesUpsertWithWhereUniqueWithoutAppointmentInput[]
    set?: servicesWhereUniqueInput | servicesWhereUniqueInput[]
    disconnect?: servicesWhereUniqueInput | servicesWhereUniqueInput[]
    delete?: servicesWhereUniqueInput | servicesWhereUniqueInput[]
    connect?: servicesWhereUniqueInput | servicesWhereUniqueInput[]
    update?: servicesUpdateWithWhereUniqueWithoutAppointmentInput | servicesUpdateWithWhereUniqueWithoutAppointmentInput[]
    updateMany?: servicesUpdateManyWithWhereWithoutAppointmentInput | servicesUpdateManyWithWhereWithoutAppointmentInput[]
    deleteMany?: servicesScalarWhereInput | servicesScalarWhereInput[]
  }

  export type userUncheckedUpdateManyWithoutAppointmentNestedInput = {
    create?: XOR<userCreateWithoutAppointmentInput, userUncheckedCreateWithoutAppointmentInput> | userCreateWithoutAppointmentInput[] | userUncheckedCreateWithoutAppointmentInput[]
    connectOrCreate?: userCreateOrConnectWithoutAppointmentInput | userCreateOrConnectWithoutAppointmentInput[]
    upsert?: userUpsertWithWhereUniqueWithoutAppointmentInput | userUpsertWithWhereUniqueWithoutAppointmentInput[]
    set?: userWhereUniqueInput | userWhereUniqueInput[]
    disconnect?: userWhereUniqueInput | userWhereUniqueInput[]
    delete?: userWhereUniqueInput | userWhereUniqueInput[]
    connect?: userWhereUniqueInput | userWhereUniqueInput[]
    update?: userUpdateWithWhereUniqueWithoutAppointmentInput | userUpdateWithWhereUniqueWithoutAppointmentInput[]
    updateMany?: userUpdateManyWithWhereWithoutAppointmentInput | userUpdateManyWithWhereWithoutAppointmentInput[]
    deleteMany?: userScalarWhereInput | userScalarWhereInput[]
  }

  export type servicesUncheckedUpdateManyWithoutAppointmentNestedInput = {
    create?: XOR<servicesCreateWithoutAppointmentInput, servicesUncheckedCreateWithoutAppointmentInput> | servicesCreateWithoutAppointmentInput[] | servicesUncheckedCreateWithoutAppointmentInput[]
    connectOrCreate?: servicesCreateOrConnectWithoutAppointmentInput | servicesCreateOrConnectWithoutAppointmentInput[]
    upsert?: servicesUpsertWithWhereUniqueWithoutAppointmentInput | servicesUpsertWithWhereUniqueWithoutAppointmentInput[]
    set?: servicesWhereUniqueInput | servicesWhereUniqueInput[]
    disconnect?: servicesWhereUniqueInput | servicesWhereUniqueInput[]
    delete?: servicesWhereUniqueInput | servicesWhereUniqueInput[]
    connect?: servicesWhereUniqueInput | servicesWhereUniqueInput[]
    update?: servicesUpdateWithWhereUniqueWithoutAppointmentInput | servicesUpdateWithWhereUniqueWithoutAppointmentInput[]
    updateMany?: servicesUpdateManyWithWhereWithoutAppointmentInput | servicesUpdateManyWithWhereWithoutAppointmentInput[]
    deleteMany?: servicesScalarWhereInput | servicesScalarWhereInput[]
  }

  export type userCreateNestedManyWithoutEquipmentInput = {
    create?: XOR<userCreateWithoutEquipmentInput, userUncheckedCreateWithoutEquipmentInput> | userCreateWithoutEquipmentInput[] | userUncheckedCreateWithoutEquipmentInput[]
    connectOrCreate?: userCreateOrConnectWithoutEquipmentInput | userCreateOrConnectWithoutEquipmentInput[]
    connect?: userWhereUniqueInput | userWhereUniqueInput[]
  }

  export type userUncheckedCreateNestedManyWithoutEquipmentInput = {
    create?: XOR<userCreateWithoutEquipmentInput, userUncheckedCreateWithoutEquipmentInput> | userCreateWithoutEquipmentInput[] | userUncheckedCreateWithoutEquipmentInput[]
    connectOrCreate?: userCreateOrConnectWithoutEquipmentInput | userCreateOrConnectWithoutEquipmentInput[]
    connect?: userWhereUniqueInput | userWhereUniqueInput[]
  }

  export type EnuminventoryFieldUpdateOperationsInput = {
    set?: $Enums.inventory
  }

  export type userUpdateManyWithoutEquipmentNestedInput = {
    create?: XOR<userCreateWithoutEquipmentInput, userUncheckedCreateWithoutEquipmentInput> | userCreateWithoutEquipmentInput[] | userUncheckedCreateWithoutEquipmentInput[]
    connectOrCreate?: userCreateOrConnectWithoutEquipmentInput | userCreateOrConnectWithoutEquipmentInput[]
    upsert?: userUpsertWithWhereUniqueWithoutEquipmentInput | userUpsertWithWhereUniqueWithoutEquipmentInput[]
    set?: userWhereUniqueInput | userWhereUniqueInput[]
    disconnect?: userWhereUniqueInput | userWhereUniqueInput[]
    delete?: userWhereUniqueInput | userWhereUniqueInput[]
    connect?: userWhereUniqueInput | userWhereUniqueInput[]
    update?: userUpdateWithWhereUniqueWithoutEquipmentInput | userUpdateWithWhereUniqueWithoutEquipmentInput[]
    updateMany?: userUpdateManyWithWhereWithoutEquipmentInput | userUpdateManyWithWhereWithoutEquipmentInput[]
    deleteMany?: userScalarWhereInput | userScalarWhereInput[]
  }

  export type userUncheckedUpdateManyWithoutEquipmentNestedInput = {
    create?: XOR<userCreateWithoutEquipmentInput, userUncheckedCreateWithoutEquipmentInput> | userCreateWithoutEquipmentInput[] | userUncheckedCreateWithoutEquipmentInput[]
    connectOrCreate?: userCreateOrConnectWithoutEquipmentInput | userCreateOrConnectWithoutEquipmentInput[]
    upsert?: userUpsertWithWhereUniqueWithoutEquipmentInput | userUpsertWithWhereUniqueWithoutEquipmentInput[]
    set?: userWhereUniqueInput | userWhereUniqueInput[]
    disconnect?: userWhereUniqueInput | userWhereUniqueInput[]
    delete?: userWhereUniqueInput | userWhereUniqueInput[]
    connect?: userWhereUniqueInput | userWhereUniqueInput[]
    update?: userUpdateWithWhereUniqueWithoutEquipmentInput | userUpdateWithWhereUniqueWithoutEquipmentInput[]
    updateMany?: userUpdateManyWithWhereWithoutEquipmentInput | userUpdateManyWithWhereWithoutEquipmentInput[]
    deleteMany?: userScalarWhereInput | userScalarWhereInput[]
  }

  export type userCreateNestedManyWithoutBlogInput = {
    create?: XOR<userCreateWithoutBlogInput, userUncheckedCreateWithoutBlogInput> | userCreateWithoutBlogInput[] | userUncheckedCreateWithoutBlogInput[]
    connectOrCreate?: userCreateOrConnectWithoutBlogInput | userCreateOrConnectWithoutBlogInput[]
    connect?: userWhereUniqueInput | userWhereUniqueInput[]
  }

  export type userUncheckedCreateNestedManyWithoutBlogInput = {
    create?: XOR<userCreateWithoutBlogInput, userUncheckedCreateWithoutBlogInput> | userCreateWithoutBlogInput[] | userUncheckedCreateWithoutBlogInput[]
    connectOrCreate?: userCreateOrConnectWithoutBlogInput | userCreateOrConnectWithoutBlogInput[]
    connect?: userWhereUniqueInput | userWhereUniqueInput[]
  }

  export type userUpdateManyWithoutBlogNestedInput = {
    create?: XOR<userCreateWithoutBlogInput, userUncheckedCreateWithoutBlogInput> | userCreateWithoutBlogInput[] | userUncheckedCreateWithoutBlogInput[]
    connectOrCreate?: userCreateOrConnectWithoutBlogInput | userCreateOrConnectWithoutBlogInput[]
    upsert?: userUpsertWithWhereUniqueWithoutBlogInput | userUpsertWithWhereUniqueWithoutBlogInput[]
    set?: userWhereUniqueInput | userWhereUniqueInput[]
    disconnect?: userWhereUniqueInput | userWhereUniqueInput[]
    delete?: userWhereUniqueInput | userWhereUniqueInput[]
    connect?: userWhereUniqueInput | userWhereUniqueInput[]
    update?: userUpdateWithWhereUniqueWithoutBlogInput | userUpdateWithWhereUniqueWithoutBlogInput[]
    updateMany?: userUpdateManyWithWhereWithoutBlogInput | userUpdateManyWithWhereWithoutBlogInput[]
    deleteMany?: userScalarWhereInput | userScalarWhereInput[]
  }

  export type userUncheckedUpdateManyWithoutBlogNestedInput = {
    create?: XOR<userCreateWithoutBlogInput, userUncheckedCreateWithoutBlogInput> | userCreateWithoutBlogInput[] | userUncheckedCreateWithoutBlogInput[]
    connectOrCreate?: userCreateOrConnectWithoutBlogInput | userCreateOrConnectWithoutBlogInput[]
    upsert?: userUpsertWithWhereUniqueWithoutBlogInput | userUpsertWithWhereUniqueWithoutBlogInput[]
    set?: userWhereUniqueInput | userWhereUniqueInput[]
    disconnect?: userWhereUniqueInput | userWhereUniqueInput[]
    delete?: userWhereUniqueInput | userWhereUniqueInput[]
    connect?: userWhereUniqueInput | userWhereUniqueInput[]
    update?: userUpdateWithWhereUniqueWithoutBlogInput | userUpdateWithWhereUniqueWithoutBlogInput[]
    updateMany?: userUpdateManyWithWhereWithoutBlogInput | userUpdateManyWithWhereWithoutBlogInput[]
    deleteMany?: userScalarWhereInput | userScalarWhereInput[]
  }

  export type userCreateNestedManyWithoutFaqsInput = {
    create?: XOR<userCreateWithoutFaqsInput, userUncheckedCreateWithoutFaqsInput> | userCreateWithoutFaqsInput[] | userUncheckedCreateWithoutFaqsInput[]
    connectOrCreate?: userCreateOrConnectWithoutFaqsInput | userCreateOrConnectWithoutFaqsInput[]
    connect?: userWhereUniqueInput | userWhereUniqueInput[]
  }

  export type userUncheckedCreateNestedManyWithoutFaqsInput = {
    create?: XOR<userCreateWithoutFaqsInput, userUncheckedCreateWithoutFaqsInput> | userCreateWithoutFaqsInput[] | userUncheckedCreateWithoutFaqsInput[]
    connectOrCreate?: userCreateOrConnectWithoutFaqsInput | userCreateOrConnectWithoutFaqsInput[]
    connect?: userWhereUniqueInput | userWhereUniqueInput[]
  }

  export type userUpdateManyWithoutFaqsNestedInput = {
    create?: XOR<userCreateWithoutFaqsInput, userUncheckedCreateWithoutFaqsInput> | userCreateWithoutFaqsInput[] | userUncheckedCreateWithoutFaqsInput[]
    connectOrCreate?: userCreateOrConnectWithoutFaqsInput | userCreateOrConnectWithoutFaqsInput[]
    upsert?: userUpsertWithWhereUniqueWithoutFaqsInput | userUpsertWithWhereUniqueWithoutFaqsInput[]
    set?: userWhereUniqueInput | userWhereUniqueInput[]
    disconnect?: userWhereUniqueInput | userWhereUniqueInput[]
    delete?: userWhereUniqueInput | userWhereUniqueInput[]
    connect?: userWhereUniqueInput | userWhereUniqueInput[]
    update?: userUpdateWithWhereUniqueWithoutFaqsInput | userUpdateWithWhereUniqueWithoutFaqsInput[]
    updateMany?: userUpdateManyWithWhereWithoutFaqsInput | userUpdateManyWithWhereWithoutFaqsInput[]
    deleteMany?: userScalarWhereInput | userScalarWhereInput[]
  }

  export type userUncheckedUpdateManyWithoutFaqsNestedInput = {
    create?: XOR<userCreateWithoutFaqsInput, userUncheckedCreateWithoutFaqsInput> | userCreateWithoutFaqsInput[] | userUncheckedCreateWithoutFaqsInput[]
    connectOrCreate?: userCreateOrConnectWithoutFaqsInput | userCreateOrConnectWithoutFaqsInput[]
    upsert?: userUpsertWithWhereUniqueWithoutFaqsInput | userUpsertWithWhereUniqueWithoutFaqsInput[]
    set?: userWhereUniqueInput | userWhereUniqueInput[]
    disconnect?: userWhereUniqueInput | userWhereUniqueInput[]
    delete?: userWhereUniqueInput | userWhereUniqueInput[]
    connect?: userWhereUniqueInput | userWhereUniqueInput[]
    update?: userUpdateWithWhereUniqueWithoutFaqsInput | userUpdateWithWhereUniqueWithoutFaqsInput[]
    updateMany?: userUpdateManyWithWhereWithoutFaqsInput | userUpdateManyWithWhereWithoutFaqsInput[]
    deleteMany?: userScalarWhereInput | userScalarWhereInput[]
  }

  export type profileCreateNestedOneWithoutAvatarInput = {
    create?: XOR<profileCreateWithoutAvatarInput, profileUncheckedCreateWithoutAvatarInput>
    connectOrCreate?: profileCreateOrConnectWithoutAvatarInput
    connect?: profileWhereUniqueInput
  }

  export type profileUpdateOneWithoutAvatarNestedInput = {
    create?: XOR<profileCreateWithoutAvatarInput, profileUncheckedCreateWithoutAvatarInput>
    connectOrCreate?: profileCreateOrConnectWithoutAvatarInput
    upsert?: profileUpsertWithoutAvatarInput
    disconnect?: profileWhereInput | boolean
    delete?: profileWhereInput | boolean
    connect?: profileWhereUniqueInput
    update?: XOR<XOR<profileUpdateToOneWithWhereWithoutAvatarInput, profileUpdateWithoutAvatarInput>, profileUncheckedUpdateWithoutAvatarInput>
  }

  export type avatarCreateNestedOneWithoutProfileInput = {
    create?: XOR<avatarCreateWithoutProfileInput, avatarUncheckedCreateWithoutProfileInput>
    connectOrCreate?: avatarCreateOrConnectWithoutProfileInput
    connect?: avatarWhereUniqueInput
  }

  export type userCreateNestedOneWithoutProfileInput = {
    create?: XOR<userCreateWithoutProfileInput, userUncheckedCreateWithoutProfileInput>
    connectOrCreate?: userCreateOrConnectWithoutProfileInput
    connect?: userWhereUniqueInput
  }

  export type avatarUncheckedCreateNestedOneWithoutProfileInput = {
    create?: XOR<avatarCreateWithoutProfileInput, avatarUncheckedCreateWithoutProfileInput>
    connectOrCreate?: avatarCreateOrConnectWithoutProfileInput
    connect?: avatarWhereUniqueInput
  }

  export type avatarUpdateOneWithoutProfileNestedInput = {
    create?: XOR<avatarCreateWithoutProfileInput, avatarUncheckedCreateWithoutProfileInput>
    connectOrCreate?: avatarCreateOrConnectWithoutProfileInput
    upsert?: avatarUpsertWithoutProfileInput
    disconnect?: avatarWhereInput | boolean
    delete?: avatarWhereInput | boolean
    connect?: avatarWhereUniqueInput
    update?: XOR<XOR<avatarUpdateToOneWithWhereWithoutProfileInput, avatarUpdateWithoutProfileInput>, avatarUncheckedUpdateWithoutProfileInput>
  }

  export type userUpdateOneWithoutProfileNestedInput = {
    create?: XOR<userCreateWithoutProfileInput, userUncheckedCreateWithoutProfileInput>
    connectOrCreate?: userCreateOrConnectWithoutProfileInput
    upsert?: userUpsertWithoutProfileInput
    disconnect?: userWhereInput | boolean
    delete?: userWhereInput | boolean
    connect?: userWhereUniqueInput
    update?: XOR<XOR<userUpdateToOneWithWhereWithoutProfileInput, userUpdateWithoutProfileInput>, userUncheckedUpdateWithoutProfileInput>
  }

  export type avatarUncheckedUpdateOneWithoutProfileNestedInput = {
    create?: XOR<avatarCreateWithoutProfileInput, avatarUncheckedCreateWithoutProfileInput>
    connectOrCreate?: avatarCreateOrConnectWithoutProfileInput
    upsert?: avatarUpsertWithoutProfileInput
    disconnect?: avatarWhereInput | boolean
    delete?: avatarWhereInput | boolean
    connect?: avatarWhereUniqueInput
    update?: XOR<XOR<avatarUpdateToOneWithWhereWithoutProfileInput, avatarUpdateWithoutProfileInput>, avatarUncheckedUpdateWithoutProfileInput>
  }

  export type userCreateNestedOneWithoutDiagnosisInput = {
    create?: XOR<userCreateWithoutDiagnosisInput, userUncheckedCreateWithoutDiagnosisInput>
    connectOrCreate?: userCreateOrConnectWithoutDiagnosisInput
    connect?: userWhereUniqueInput
  }

  export type userUpdateOneWithoutDiagnosisNestedInput = {
    create?: XOR<userCreateWithoutDiagnosisInput, userUncheckedCreateWithoutDiagnosisInput>
    connectOrCreate?: userCreateOrConnectWithoutDiagnosisInput
    upsert?: userUpsertWithoutDiagnosisInput
    disconnect?: userWhereInput | boolean
    delete?: userWhereInput | boolean
    connect?: userWhereUniqueInput
    update?: XOR<XOR<userUpdateToOneWithWhereWithoutDiagnosisInput, userUpdateWithoutDiagnosisInput>, userUncheckedUpdateWithoutDiagnosisInput>
  }

  export type userCreateNestedOneWithoutPrescriptionInput = {
    create?: XOR<userCreateWithoutPrescriptionInput, userUncheckedCreateWithoutPrescriptionInput>
    connectOrCreate?: userCreateOrConnectWithoutPrescriptionInput
    connect?: userWhereUniqueInput
  }

  export type userUpdateOneWithoutPrescriptionNestedInput = {
    create?: XOR<userCreateWithoutPrescriptionInput, userUncheckedCreateWithoutPrescriptionInput>
    connectOrCreate?: userCreateOrConnectWithoutPrescriptionInput
    upsert?: userUpsertWithoutPrescriptionInput
    disconnect?: userWhereInput | boolean
    delete?: userWhereInput | boolean
    connect?: userWhereUniqueInput
    update?: XOR<XOR<userUpdateToOneWithWhereWithoutPrescriptionInput, userUpdateWithoutPrescriptionInput>, userUncheckedUpdateWithoutPrescriptionInput>
  }

  export type appointmentCreateNestedManyWithoutFeedbackInput = {
    create?: XOR<appointmentCreateWithoutFeedbackInput, appointmentUncheckedCreateWithoutFeedbackInput> | appointmentCreateWithoutFeedbackInput[] | appointmentUncheckedCreateWithoutFeedbackInput[]
    connectOrCreate?: appointmentCreateOrConnectWithoutFeedbackInput | appointmentCreateOrConnectWithoutFeedbackInput[]
    createMany?: appointmentCreateManyFeedbackInputEnvelope
    connect?: appointmentWhereUniqueInput | appointmentWhereUniqueInput[]
  }

  export type userCreateNestedManyWithoutFeedbackInput = {
    create?: XOR<userCreateWithoutFeedbackInput, userUncheckedCreateWithoutFeedbackInput> | userCreateWithoutFeedbackInput[] | userUncheckedCreateWithoutFeedbackInput[]
    connectOrCreate?: userCreateOrConnectWithoutFeedbackInput | userCreateOrConnectWithoutFeedbackInput[]
    connect?: userWhereUniqueInput | userWhereUniqueInput[]
  }

  export type appointmentUncheckedCreateNestedManyWithoutFeedbackInput = {
    create?: XOR<appointmentCreateWithoutFeedbackInput, appointmentUncheckedCreateWithoutFeedbackInput> | appointmentCreateWithoutFeedbackInput[] | appointmentUncheckedCreateWithoutFeedbackInput[]
    connectOrCreate?: appointmentCreateOrConnectWithoutFeedbackInput | appointmentCreateOrConnectWithoutFeedbackInput[]
    createMany?: appointmentCreateManyFeedbackInputEnvelope
    connect?: appointmentWhereUniqueInput | appointmentWhereUniqueInput[]
  }

  export type userUncheckedCreateNestedManyWithoutFeedbackInput = {
    create?: XOR<userCreateWithoutFeedbackInput, userUncheckedCreateWithoutFeedbackInput> | userCreateWithoutFeedbackInput[] | userUncheckedCreateWithoutFeedbackInput[]
    connectOrCreate?: userCreateOrConnectWithoutFeedbackInput | userCreateOrConnectWithoutFeedbackInput[]
    connect?: userWhereUniqueInput | userWhereUniqueInput[]
  }

  export type appointmentUpdateManyWithoutFeedbackNestedInput = {
    create?: XOR<appointmentCreateWithoutFeedbackInput, appointmentUncheckedCreateWithoutFeedbackInput> | appointmentCreateWithoutFeedbackInput[] | appointmentUncheckedCreateWithoutFeedbackInput[]
    connectOrCreate?: appointmentCreateOrConnectWithoutFeedbackInput | appointmentCreateOrConnectWithoutFeedbackInput[]
    upsert?: appointmentUpsertWithWhereUniqueWithoutFeedbackInput | appointmentUpsertWithWhereUniqueWithoutFeedbackInput[]
    createMany?: appointmentCreateManyFeedbackInputEnvelope
    set?: appointmentWhereUniqueInput | appointmentWhereUniqueInput[]
    disconnect?: appointmentWhereUniqueInput | appointmentWhereUniqueInput[]
    delete?: appointmentWhereUniqueInput | appointmentWhereUniqueInput[]
    connect?: appointmentWhereUniqueInput | appointmentWhereUniqueInput[]
    update?: appointmentUpdateWithWhereUniqueWithoutFeedbackInput | appointmentUpdateWithWhereUniqueWithoutFeedbackInput[]
    updateMany?: appointmentUpdateManyWithWhereWithoutFeedbackInput | appointmentUpdateManyWithWhereWithoutFeedbackInput[]
    deleteMany?: appointmentScalarWhereInput | appointmentScalarWhereInput[]
  }

  export type userUpdateManyWithoutFeedbackNestedInput = {
    create?: XOR<userCreateWithoutFeedbackInput, userUncheckedCreateWithoutFeedbackInput> | userCreateWithoutFeedbackInput[] | userUncheckedCreateWithoutFeedbackInput[]
    connectOrCreate?: userCreateOrConnectWithoutFeedbackInput | userCreateOrConnectWithoutFeedbackInput[]
    upsert?: userUpsertWithWhereUniqueWithoutFeedbackInput | userUpsertWithWhereUniqueWithoutFeedbackInput[]
    set?: userWhereUniqueInput | userWhereUniqueInput[]
    disconnect?: userWhereUniqueInput | userWhereUniqueInput[]
    delete?: userWhereUniqueInput | userWhereUniqueInput[]
    connect?: userWhereUniqueInput | userWhereUniqueInput[]
    update?: userUpdateWithWhereUniqueWithoutFeedbackInput | userUpdateWithWhereUniqueWithoutFeedbackInput[]
    updateMany?: userUpdateManyWithWhereWithoutFeedbackInput | userUpdateManyWithWhereWithoutFeedbackInput[]
    deleteMany?: userScalarWhereInput | userScalarWhereInput[]
  }

  export type appointmentUncheckedUpdateManyWithoutFeedbackNestedInput = {
    create?: XOR<appointmentCreateWithoutFeedbackInput, appointmentUncheckedCreateWithoutFeedbackInput> | appointmentCreateWithoutFeedbackInput[] | appointmentUncheckedCreateWithoutFeedbackInput[]
    connectOrCreate?: appointmentCreateOrConnectWithoutFeedbackInput | appointmentCreateOrConnectWithoutFeedbackInput[]
    upsert?: appointmentUpsertWithWhereUniqueWithoutFeedbackInput | appointmentUpsertWithWhereUniqueWithoutFeedbackInput[]
    createMany?: appointmentCreateManyFeedbackInputEnvelope
    set?: appointmentWhereUniqueInput | appointmentWhereUniqueInput[]
    disconnect?: appointmentWhereUniqueInput | appointmentWhereUniqueInput[]
    delete?: appointmentWhereUniqueInput | appointmentWhereUniqueInput[]
    connect?: appointmentWhereUniqueInput | appointmentWhereUniqueInput[]
    update?: appointmentUpdateWithWhereUniqueWithoutFeedbackInput | appointmentUpdateWithWhereUniqueWithoutFeedbackInput[]
    updateMany?: appointmentUpdateManyWithWhereWithoutFeedbackInput | appointmentUpdateManyWithWhereWithoutFeedbackInput[]
    deleteMany?: appointmentScalarWhereInput | appointmentScalarWhereInput[]
  }

  export type userUncheckedUpdateManyWithoutFeedbackNestedInput = {
    create?: XOR<userCreateWithoutFeedbackInput, userUncheckedCreateWithoutFeedbackInput> | userCreateWithoutFeedbackInput[] | userUncheckedCreateWithoutFeedbackInput[]
    connectOrCreate?: userCreateOrConnectWithoutFeedbackInput | userCreateOrConnectWithoutFeedbackInput[]
    upsert?: userUpsertWithWhereUniqueWithoutFeedbackInput | userUpsertWithWhereUniqueWithoutFeedbackInput[]
    set?: userWhereUniqueInput | userWhereUniqueInput[]
    disconnect?: userWhereUniqueInput | userWhereUniqueInput[]
    delete?: userWhereUniqueInput | userWhereUniqueInput[]
    connect?: userWhereUniqueInput | userWhereUniqueInput[]
    update?: userUpdateWithWhereUniqueWithoutFeedbackInput | userUpdateWithWhereUniqueWithoutFeedbackInput[]
    updateMany?: userUpdateManyWithWhereWithoutFeedbackInput | userUpdateManyWithWhereWithoutFeedbackInput[]
    deleteMany?: userScalarWhereInput | userScalarWhereInput[]
  }

  export type userCreateNestedOneWithoutPreDiagnosticInput = {
    create?: XOR<userCreateWithoutPreDiagnosticInput, userUncheckedCreateWithoutPreDiagnosticInput>
    connectOrCreate?: userCreateOrConnectWithoutPreDiagnosticInput
    connect?: userWhereUniqueInput
  }

  export type userUpdateOneWithoutPreDiagnosticNestedInput = {
    create?: XOR<userCreateWithoutPreDiagnosticInput, userUncheckedCreateWithoutPreDiagnosticInput>
    connectOrCreate?: userCreateOrConnectWithoutPreDiagnosticInput
    upsert?: userUpsertWithoutPreDiagnosticInput
    disconnect?: userWhereInput | boolean
    delete?: userWhereInput | boolean
    connect?: userWhereUniqueInput
    update?: XOR<XOR<userUpdateToOneWithWhereWithoutPreDiagnosticInput, userUpdateWithoutPreDiagnosticInput>, userUncheckedUpdateWithoutPreDiagnosticInput>
  }

  export type NestedStringFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringFilter<$PrismaModel> | string
  }

  export type NestedEnumrolesFilter<$PrismaModel = never> = {
    equals?: $Enums.roles | EnumrolesFieldRefInput<$PrismaModel>
    in?: $Enums.roles[] | ListEnumrolesFieldRefInput<$PrismaModel>
    notIn?: $Enums.roles[] | ListEnumrolesFieldRefInput<$PrismaModel>
    not?: NestedEnumrolesFilter<$PrismaModel> | $Enums.roles
  }

  export type NestedBoolFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolFilter<$PrismaModel> | boolean
  }

  export type NestedDateTimeFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeFilter<$PrismaModel> | Date | string
  }

  export type NestedStringWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringWithAggregatesFilter<$PrismaModel> | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedStringFilter<$PrismaModel>
    _max?: NestedStringFilter<$PrismaModel>
  }

  export type NestedIntFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[] | ListIntFieldRefInput<$PrismaModel>
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel>
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntFilter<$PrismaModel> | number
  }

  export type NestedEnumrolesWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.roles | EnumrolesFieldRefInput<$PrismaModel>
    in?: $Enums.roles[] | ListEnumrolesFieldRefInput<$PrismaModel>
    notIn?: $Enums.roles[] | ListEnumrolesFieldRefInput<$PrismaModel>
    not?: NestedEnumrolesWithAggregatesFilter<$PrismaModel> | $Enums.roles
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumrolesFilter<$PrismaModel>
    _max?: NestedEnumrolesFilter<$PrismaModel>
  }

  export type NestedBoolWithAggregatesFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolWithAggregatesFilter<$PrismaModel> | boolean
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedBoolFilter<$PrismaModel>
    _max?: NestedBoolFilter<$PrismaModel>
  }

  export type NestedDateTimeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeWithAggregatesFilter<$PrismaModel> | Date | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedDateTimeFilter<$PrismaModel>
    _max?: NestedDateTimeFilter<$PrismaModel>
  }

  export type NestedFloatFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel>
    in?: number[] | ListFloatFieldRefInput<$PrismaModel>
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel>
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatFilter<$PrismaModel> | number
  }

  export type NestedStringNullableFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringNullableFilter<$PrismaModel> | string | null
  }

  export type NestedFloatWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel>
    in?: number[] | ListFloatFieldRefInput<$PrismaModel>
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel>
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatWithAggregatesFilter<$PrismaModel> | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedFloatFilter<$PrismaModel>
    _min?: NestedFloatFilter<$PrismaModel>
    _max?: NestedFloatFilter<$PrismaModel>
  }

  export type NestedStringNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringNullableWithAggregatesFilter<$PrismaModel> | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedStringNullableFilter<$PrismaModel>
    _max?: NestedStringNullableFilter<$PrismaModel>
  }

  export type NestedIntNullableFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableFilter<$PrismaModel> | number | null
  }

  export type NestedEnumplatformFilter<$PrismaModel = never> = {
    equals?: $Enums.platform | EnumplatformFieldRefInput<$PrismaModel>
    in?: $Enums.platform[] | ListEnumplatformFieldRefInput<$PrismaModel>
    notIn?: $Enums.platform[] | ListEnumplatformFieldRefInput<$PrismaModel>
    not?: NestedEnumplatformFilter<$PrismaModel> | $Enums.platform
  }

  export type NestedEnumstatusFilter<$PrismaModel = never> = {
    equals?: $Enums.status | EnumstatusFieldRefInput<$PrismaModel>
    in?: $Enums.status[] | ListEnumstatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.status[] | ListEnumstatusFieldRefInput<$PrismaModel>
    not?: NestedEnumstatusFilter<$PrismaModel> | $Enums.status
  }

  export type NestedEnumplatformWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.platform | EnumplatformFieldRefInput<$PrismaModel>
    in?: $Enums.platform[] | ListEnumplatformFieldRefInput<$PrismaModel>
    notIn?: $Enums.platform[] | ListEnumplatformFieldRefInput<$PrismaModel>
    not?: NestedEnumplatformWithAggregatesFilter<$PrismaModel> | $Enums.platform
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumplatformFilter<$PrismaModel>
    _max?: NestedEnumplatformFilter<$PrismaModel>
  }

  export type NestedIntWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[] | ListIntFieldRefInput<$PrismaModel>
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel>
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntWithAggregatesFilter<$PrismaModel> | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedIntFilter<$PrismaModel>
    _min?: NestedIntFilter<$PrismaModel>
    _max?: NestedIntFilter<$PrismaModel>
  }

  export type NestedEnumstatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.status | EnumstatusFieldRefInput<$PrismaModel>
    in?: $Enums.status[] | ListEnumstatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.status[] | ListEnumstatusFieldRefInput<$PrismaModel>
    not?: NestedEnumstatusWithAggregatesFilter<$PrismaModel> | $Enums.status
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumstatusFilter<$PrismaModel>
    _max?: NestedEnumstatusFilter<$PrismaModel>
  }

  export type NestedEnuminventoryFilter<$PrismaModel = never> = {
    equals?: $Enums.inventory | EnuminventoryFieldRefInput<$PrismaModel>
    in?: $Enums.inventory[] | ListEnuminventoryFieldRefInput<$PrismaModel>
    notIn?: $Enums.inventory[] | ListEnuminventoryFieldRefInput<$PrismaModel>
    not?: NestedEnuminventoryFilter<$PrismaModel> | $Enums.inventory
  }

  export type NestedEnuminventoryWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.inventory | EnuminventoryFieldRefInput<$PrismaModel>
    in?: $Enums.inventory[] | ListEnuminventoryFieldRefInput<$PrismaModel>
    notIn?: $Enums.inventory[] | ListEnuminventoryFieldRefInput<$PrismaModel>
    not?: NestedEnuminventoryWithAggregatesFilter<$PrismaModel> | $Enums.inventory
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnuminventoryFilter<$PrismaModel>
    _max?: NestedEnuminventoryFilter<$PrismaModel>
  }

  export type profileCreateWithoutUserInput = {
    profileID?: string
    firstname: string
    lastname: string
    phone: string
    designation?: string | null
    expertise?: string | null
    emergencyPhone?: string | null
    avatar?: avatarCreateNestedOneWithoutProfileInput
  }

  export type profileUncheckedCreateWithoutUserInput = {
    profileID?: string
    firstname: string
    lastname: string
    phone: string
    designation?: string | null
    expertise?: string | null
    emergencyPhone?: string | null
    avatar?: avatarUncheckedCreateNestedOneWithoutProfileInput
  }

  export type profileCreateOrConnectWithoutUserInput = {
    where: profileWhereUniqueInput
    create: XOR<profileCreateWithoutUserInput, profileUncheckedCreateWithoutUserInput>
  }

  export type blogsCreateWithoutUserInput = {
    blogsID?: string
    title: string
    content: string
    expertise: string
    image: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type blogsUncheckedCreateWithoutUserInput = {
    blogsID?: string
    title: string
    content: string
    expertise: string
    image: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type blogsCreateOrConnectWithoutUserInput = {
    where: blogsWhereUniqueInput
    create: XOR<blogsCreateWithoutUserInput, blogsUncheckedCreateWithoutUserInput>
  }

  export type faqsCreateWithoutUserInput = {
    faqsID?: string
    faqs: string
    answer: string
    creatdAt?: Date | string
    updateAt?: Date | string
  }

  export type faqsUncheckedCreateWithoutUserInput = {
    faqsID?: string
    faqs: string
    answer: string
    creatdAt?: Date | string
    updateAt?: Date | string
  }

  export type faqsCreateOrConnectWithoutUserInput = {
    where: faqsWhereUniqueInput
    create: XOR<faqsCreateWithoutUserInput, faqsUncheckedCreateWithoutUserInput>
  }

  export type equipmentCreateWithoutUserInput = {
    equipmentID?: string
    name: string
    inventory: $Enums.inventory
    description: string
    quantity: number
    expireDate: Date | string
    creatdAt?: Date | string
    updateAt?: Date | string
  }

  export type equipmentUncheckedCreateWithoutUserInput = {
    equipmentID?: string
    name: string
    inventory: $Enums.inventory
    description: string
    quantity: number
    expireDate: Date | string
    creatdAt?: Date | string
    updateAt?: Date | string
  }

  export type equipmentCreateOrConnectWithoutUserInput = {
    where: equipmentWhereUniqueInput
    create: XOR<equipmentCreateWithoutUserInput, equipmentUncheckedCreateWithoutUserInput>
  }

  export type presciptionCreateWithoutPatinetInput = {
    prescriptionID?: string
    prescription: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type presciptionUncheckedCreateWithoutPatinetInput = {
    prescriptionID?: string
    prescription: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type presciptionCreateOrConnectWithoutPatinetInput = {
    where: presciptionWhereUniqueInput
    create: XOR<presciptionCreateWithoutPatinetInput, presciptionUncheckedCreateWithoutPatinetInput>
  }

  export type presciptionCreateManyPatinetInputEnvelope = {
    data: presciptionCreateManyPatinetInput | presciptionCreateManyPatinetInput[]
    skipDuplicates?: boolean
  }

  export type feedbackCreateWithoutUserInput = {
    feedbackID?: string
    therapistName: string
    date: string
    time: string
    question1: string
    question2: string
    question3: string
    question4: string
    question5: string
    question6: string
    question7: string
    question8: string
    feedback: string
    rating: number
    creatdAt?: Date | string
    updatedAt?: Date | string
    appointment?: appointmentCreateNestedManyWithoutFeedbackInput
  }

  export type feedbackUncheckedCreateWithoutUserInput = {
    feedbackID?: string
    therapistName: string
    date: string
    time: string
    question1: string
    question2: string
    question3: string
    question4: string
    question5: string
    question6: string
    question7: string
    question8: string
    feedback: string
    rating: number
    creatdAt?: Date | string
    updatedAt?: Date | string
    appointment?: appointmentUncheckedCreateNestedManyWithoutFeedbackInput
  }

  export type feedbackCreateOrConnectWithoutUserInput = {
    where: feedbackWhereUniqueInput
    create: XOR<feedbackCreateWithoutUserInput, feedbackUncheckedCreateWithoutUserInput>
  }

  export type appointmentCreateWithoutUserInput = {
    appointmentID?: string
    date: Date | string
    time: string
    services?: string | null
    platform: $Enums.platform
    link?: string | null
    amount: number
    status?: $Enums.status
    createdAt?: Date | string
    updatedAt?: Date | string
    feedback?: feedbackCreateNestedOneWithoutAppointmentInput
    service?: servicesCreateNestedManyWithoutAppointmentInput
  }

  export type appointmentUncheckedCreateWithoutUserInput = {
    appointmentID?: string
    date: Date | string
    time: string
    services?: string | null
    platform: $Enums.platform
    link?: string | null
    amount: number
    status?: $Enums.status
    createdAt?: Date | string
    updatedAt?: Date | string
    feedbackID?: string | null
    service?: servicesUncheckedCreateNestedManyWithoutAppointmentInput
  }

  export type appointmentCreateOrConnectWithoutUserInput = {
    where: appointmentWhereUniqueInput
    create: XOR<appointmentCreateWithoutUserInput, appointmentUncheckedCreateWithoutUserInput>
  }

  export type diagnosisCreateWithoutUserInput = {
    diagnosisID?: string
    diagnosis?: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type diagnosisUncheckedCreateWithoutUserInput = {
    diagnosisID?: string
    diagnosis?: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type diagnosisCreateOrConnectWithoutUserInput = {
    where: diagnosisWhereUniqueInput
    create: XOR<diagnosisCreateWithoutUserInput, diagnosisUncheckedCreateWithoutUserInput>
  }

  export type diagnosisCreateManyUserInputEnvelope = {
    data: diagnosisCreateManyUserInput | diagnosisCreateManyUserInput[]
    skipDuplicates?: boolean
  }

  export type otpCreateWithoutUserInput = {
    otpID?: string
    otp: string
    expiredAt: Date | string
    createdAt: Date | string
  }

  export type otpUncheckedCreateWithoutUserInput = {
    otpID?: string
    otp: string
    expiredAt: Date | string
    createdAt: Date | string
  }

  export type otpCreateOrConnectWithoutUserInput = {
    where: otpWhereUniqueInput
    create: XOR<otpCreateWithoutUserInput, otpUncheckedCreateWithoutUserInput>
  }

  export type servicesCreateWithoutUserInput = {
    servicesID?: string
    services: string
    descriptions: string
    image: string
    price: number
    appointment?: appointmentCreateNestedManyWithoutServiceInput
  }

  export type servicesUncheckedCreateWithoutUserInput = {
    servicesID?: string
    services: string
    descriptions: string
    image: string
    price: number
    appointment?: appointmentUncheckedCreateNestedManyWithoutServiceInput
  }

  export type servicesCreateOrConnectWithoutUserInput = {
    where: servicesWhereUniqueInput
    create: XOR<servicesCreateWithoutUserInput, servicesUncheckedCreateWithoutUserInput>
  }

  export type servicesCreateManyUserInputEnvelope = {
    data: servicesCreateManyUserInput | servicesCreateManyUserInput[]
    skipDuplicates?: boolean
  }

  export type prediagCreateWithoutUserInput = {
    prediagnosticID?: string
    age: string
    sex: string
    date: string
    time: string
    question1: string
    question2: string
    question3: string
    question4: string
    question5: string
    question6: string
    question7: string
    question8: string
    question9: string
    question10: string
    question11: string
    question12: string
    question13: string
    question14: string
    question15: string
    question16: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type prediagUncheckedCreateWithoutUserInput = {
    prediagnosticID?: string
    age: string
    sex: string
    date: string
    time: string
    question1: string
    question2: string
    question3: string
    question4: string
    question5: string
    question6: string
    question7: string
    question8: string
    question9: string
    question10: string
    question11: string
    question12: string
    question13: string
    question14: string
    question15: string
    question16: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type prediagCreateOrConnectWithoutUserInput = {
    where: prediagWhereUniqueInput
    create: XOR<prediagCreateWithoutUserInput, prediagUncheckedCreateWithoutUserInput>
  }

  export type prediagCreateManyUserInputEnvelope = {
    data: prediagCreateManyUserInput | prediagCreateManyUserInput[]
    skipDuplicates?: boolean
  }

  export type profileUpsertWithoutUserInput = {
    update: XOR<profileUpdateWithoutUserInput, profileUncheckedUpdateWithoutUserInput>
    create: XOR<profileCreateWithoutUserInput, profileUncheckedCreateWithoutUserInput>
    where?: profileWhereInput
  }

  export type profileUpdateToOneWithWhereWithoutUserInput = {
    where?: profileWhereInput
    data: XOR<profileUpdateWithoutUserInput, profileUncheckedUpdateWithoutUserInput>
  }

  export type profileUpdateWithoutUserInput = {
    profileID?: StringFieldUpdateOperationsInput | string
    firstname?: StringFieldUpdateOperationsInput | string
    lastname?: StringFieldUpdateOperationsInput | string
    phone?: StringFieldUpdateOperationsInput | string
    designation?: NullableStringFieldUpdateOperationsInput | string | null
    expertise?: NullableStringFieldUpdateOperationsInput | string | null
    emergencyPhone?: NullableStringFieldUpdateOperationsInput | string | null
    avatar?: avatarUpdateOneWithoutProfileNestedInput
  }

  export type profileUncheckedUpdateWithoutUserInput = {
    profileID?: StringFieldUpdateOperationsInput | string
    firstname?: StringFieldUpdateOperationsInput | string
    lastname?: StringFieldUpdateOperationsInput | string
    phone?: StringFieldUpdateOperationsInput | string
    designation?: NullableStringFieldUpdateOperationsInput | string | null
    expertise?: NullableStringFieldUpdateOperationsInput | string | null
    emergencyPhone?: NullableStringFieldUpdateOperationsInput | string | null
    avatar?: avatarUncheckedUpdateOneWithoutProfileNestedInput
  }

  export type blogsUpsertWithWhereUniqueWithoutUserInput = {
    where: blogsWhereUniqueInput
    update: XOR<blogsUpdateWithoutUserInput, blogsUncheckedUpdateWithoutUserInput>
    create: XOR<blogsCreateWithoutUserInput, blogsUncheckedCreateWithoutUserInput>
  }

  export type blogsUpdateWithWhereUniqueWithoutUserInput = {
    where: blogsWhereUniqueInput
    data: XOR<blogsUpdateWithoutUserInput, blogsUncheckedUpdateWithoutUserInput>
  }

  export type blogsUpdateManyWithWhereWithoutUserInput = {
    where: blogsScalarWhereInput
    data: XOR<blogsUpdateManyMutationInput, blogsUncheckedUpdateManyWithoutUserInput>
  }

  export type blogsScalarWhereInput = {
    AND?: blogsScalarWhereInput | blogsScalarWhereInput[]
    OR?: blogsScalarWhereInput[]
    NOT?: blogsScalarWhereInput | blogsScalarWhereInput[]
    blogsID?: StringFilter<"blogs"> | string
    title?: StringFilter<"blogs"> | string
    content?: StringFilter<"blogs"> | string
    expertise?: StringFilter<"blogs"> | string
    image?: StringFilter<"blogs"> | string
    createdAt?: DateTimeFilter<"blogs"> | Date | string
    updatedAt?: DateTimeFilter<"blogs"> | Date | string
  }

  export type faqsUpsertWithWhereUniqueWithoutUserInput = {
    where: faqsWhereUniqueInput
    update: XOR<faqsUpdateWithoutUserInput, faqsUncheckedUpdateWithoutUserInput>
    create: XOR<faqsCreateWithoutUserInput, faqsUncheckedCreateWithoutUserInput>
  }

  export type faqsUpdateWithWhereUniqueWithoutUserInput = {
    where: faqsWhereUniqueInput
    data: XOR<faqsUpdateWithoutUserInput, faqsUncheckedUpdateWithoutUserInput>
  }

  export type faqsUpdateManyWithWhereWithoutUserInput = {
    where: faqsScalarWhereInput
    data: XOR<faqsUpdateManyMutationInput, faqsUncheckedUpdateManyWithoutUserInput>
  }

  export type faqsScalarWhereInput = {
    AND?: faqsScalarWhereInput | faqsScalarWhereInput[]
    OR?: faqsScalarWhereInput[]
    NOT?: faqsScalarWhereInput | faqsScalarWhereInput[]
    faqsID?: StringFilter<"faqs"> | string
    faqs?: StringFilter<"faqs"> | string
    answer?: StringFilter<"faqs"> | string
    creatdAt?: DateTimeFilter<"faqs"> | Date | string
    updateAt?: DateTimeFilter<"faqs"> | Date | string
  }

  export type equipmentUpsertWithWhereUniqueWithoutUserInput = {
    where: equipmentWhereUniqueInput
    update: XOR<equipmentUpdateWithoutUserInput, equipmentUncheckedUpdateWithoutUserInput>
    create: XOR<equipmentCreateWithoutUserInput, equipmentUncheckedCreateWithoutUserInput>
  }

  export type equipmentUpdateWithWhereUniqueWithoutUserInput = {
    where: equipmentWhereUniqueInput
    data: XOR<equipmentUpdateWithoutUserInput, equipmentUncheckedUpdateWithoutUserInput>
  }

  export type equipmentUpdateManyWithWhereWithoutUserInput = {
    where: equipmentScalarWhereInput
    data: XOR<equipmentUpdateManyMutationInput, equipmentUncheckedUpdateManyWithoutUserInput>
  }

  export type equipmentScalarWhereInput = {
    AND?: equipmentScalarWhereInput | equipmentScalarWhereInput[]
    OR?: equipmentScalarWhereInput[]
    NOT?: equipmentScalarWhereInput | equipmentScalarWhereInput[]
    equipmentID?: StringFilter<"equipment"> | string
    name?: StringFilter<"equipment"> | string
    inventory?: EnuminventoryFilter<"equipment"> | $Enums.inventory
    description?: StringFilter<"equipment"> | string
    quantity?: IntFilter<"equipment"> | number
    expireDate?: DateTimeFilter<"equipment"> | Date | string
    creatdAt?: DateTimeFilter<"equipment"> | Date | string
    updateAt?: DateTimeFilter<"equipment"> | Date | string
  }

  export type presciptionUpsertWithWhereUniqueWithoutPatinetInput = {
    where: presciptionWhereUniqueInput
    update: XOR<presciptionUpdateWithoutPatinetInput, presciptionUncheckedUpdateWithoutPatinetInput>
    create: XOR<presciptionCreateWithoutPatinetInput, presciptionUncheckedCreateWithoutPatinetInput>
  }

  export type presciptionUpdateWithWhereUniqueWithoutPatinetInput = {
    where: presciptionWhereUniqueInput
    data: XOR<presciptionUpdateWithoutPatinetInput, presciptionUncheckedUpdateWithoutPatinetInput>
  }

  export type presciptionUpdateManyWithWhereWithoutPatinetInput = {
    where: presciptionScalarWhereInput
    data: XOR<presciptionUpdateManyMutationInput, presciptionUncheckedUpdateManyWithoutPatinetInput>
  }

  export type presciptionScalarWhereInput = {
    AND?: presciptionScalarWhereInput | presciptionScalarWhereInput[]
    OR?: presciptionScalarWhereInput[]
    NOT?: presciptionScalarWhereInput | presciptionScalarWhereInput[]
    prescriptionID?: StringFilter<"presciption"> | string
    prescription?: StringFilter<"presciption"> | string
    createdAt?: DateTimeFilter<"presciption"> | Date | string
    updatedAt?: DateTimeFilter<"presciption"> | Date | string
    userID?: StringNullableFilter<"presciption"> | string | null
  }

  export type feedbackUpsertWithWhereUniqueWithoutUserInput = {
    where: feedbackWhereUniqueInput
    update: XOR<feedbackUpdateWithoutUserInput, feedbackUncheckedUpdateWithoutUserInput>
    create: XOR<feedbackCreateWithoutUserInput, feedbackUncheckedCreateWithoutUserInput>
  }

  export type feedbackUpdateWithWhereUniqueWithoutUserInput = {
    where: feedbackWhereUniqueInput
    data: XOR<feedbackUpdateWithoutUserInput, feedbackUncheckedUpdateWithoutUserInput>
  }

  export type feedbackUpdateManyWithWhereWithoutUserInput = {
    where: feedbackScalarWhereInput
    data: XOR<feedbackUpdateManyMutationInput, feedbackUncheckedUpdateManyWithoutUserInput>
  }

  export type feedbackScalarWhereInput = {
    AND?: feedbackScalarWhereInput | feedbackScalarWhereInput[]
    OR?: feedbackScalarWhereInput[]
    NOT?: feedbackScalarWhereInput | feedbackScalarWhereInput[]
    feedbackID?: StringFilter<"feedback"> | string
    therapistName?: StringFilter<"feedback"> | string
    date?: StringFilter<"feedback"> | string
    time?: StringFilter<"feedback"> | string
    question1?: StringFilter<"feedback"> | string
    question2?: StringFilter<"feedback"> | string
    question3?: StringFilter<"feedback"> | string
    question4?: StringFilter<"feedback"> | string
    question5?: StringFilter<"feedback"> | string
    question6?: StringFilter<"feedback"> | string
    question7?: StringFilter<"feedback"> | string
    question8?: StringFilter<"feedback"> | string
    feedback?: StringFilter<"feedback"> | string
    rating?: IntFilter<"feedback"> | number
    creatdAt?: DateTimeFilter<"feedback"> | Date | string
    updatedAt?: DateTimeFilter<"feedback"> | Date | string
  }

  export type appointmentUpsertWithWhereUniqueWithoutUserInput = {
    where: appointmentWhereUniqueInput
    update: XOR<appointmentUpdateWithoutUserInput, appointmentUncheckedUpdateWithoutUserInput>
    create: XOR<appointmentCreateWithoutUserInput, appointmentUncheckedCreateWithoutUserInput>
  }

  export type appointmentUpdateWithWhereUniqueWithoutUserInput = {
    where: appointmentWhereUniqueInput
    data: XOR<appointmentUpdateWithoutUserInput, appointmentUncheckedUpdateWithoutUserInput>
  }

  export type appointmentUpdateManyWithWhereWithoutUserInput = {
    where: appointmentScalarWhereInput
    data: XOR<appointmentUpdateManyMutationInput, appointmentUncheckedUpdateManyWithoutUserInput>
  }

  export type appointmentScalarWhereInput = {
    AND?: appointmentScalarWhereInput | appointmentScalarWhereInput[]
    OR?: appointmentScalarWhereInput[]
    NOT?: appointmentScalarWhereInput | appointmentScalarWhereInput[]
    appointmentID?: StringFilter<"appointment"> | string
    date?: DateTimeFilter<"appointment"> | Date | string
    time?: StringFilter<"appointment"> | string
    services?: StringNullableFilter<"appointment"> | string | null
    platform?: EnumplatformFilter<"appointment"> | $Enums.platform
    link?: StringNullableFilter<"appointment"> | string | null
    amount?: IntFilter<"appointment"> | number
    status?: EnumstatusFilter<"appointment"> | $Enums.status
    createdAt?: DateTimeFilter<"appointment"> | Date | string
    updatedAt?: DateTimeFilter<"appointment"> | Date | string
    feedbackID?: StringNullableFilter<"appointment"> | string | null
  }

  export type diagnosisUpsertWithWhereUniqueWithoutUserInput = {
    where: diagnosisWhereUniqueInput
    update: XOR<diagnosisUpdateWithoutUserInput, diagnosisUncheckedUpdateWithoutUserInput>
    create: XOR<diagnosisCreateWithoutUserInput, diagnosisUncheckedCreateWithoutUserInput>
  }

  export type diagnosisUpdateWithWhereUniqueWithoutUserInput = {
    where: diagnosisWhereUniqueInput
    data: XOR<diagnosisUpdateWithoutUserInput, diagnosisUncheckedUpdateWithoutUserInput>
  }

  export type diagnosisUpdateManyWithWhereWithoutUserInput = {
    where: diagnosisScalarWhereInput
    data: XOR<diagnosisUpdateManyMutationInput, diagnosisUncheckedUpdateManyWithoutUserInput>
  }

  export type diagnosisScalarWhereInput = {
    AND?: diagnosisScalarWhereInput | diagnosisScalarWhereInput[]
    OR?: diagnosisScalarWhereInput[]
    NOT?: diagnosisScalarWhereInput | diagnosisScalarWhereInput[]
    diagnosisID?: StringFilter<"diagnosis"> | string
    diagnosis?: StringFilter<"diagnosis"> | string
    createdAt?: DateTimeFilter<"diagnosis"> | Date | string
    updatedAt?: DateTimeFilter<"diagnosis"> | Date | string
    userID?: StringNullableFilter<"diagnosis"> | string | null
  }

  export type otpUpsertWithWhereUniqueWithoutUserInput = {
    where: otpWhereUniqueInput
    update: XOR<otpUpdateWithoutUserInput, otpUncheckedUpdateWithoutUserInput>
    create: XOR<otpCreateWithoutUserInput, otpUncheckedCreateWithoutUserInput>
  }

  export type otpUpdateWithWhereUniqueWithoutUserInput = {
    where: otpWhereUniqueInput
    data: XOR<otpUpdateWithoutUserInput, otpUncheckedUpdateWithoutUserInput>
  }

  export type otpUpdateManyWithWhereWithoutUserInput = {
    where: otpScalarWhereInput
    data: XOR<otpUpdateManyMutationInput, otpUncheckedUpdateManyWithoutUserInput>
  }

  export type otpScalarWhereInput = {
    AND?: otpScalarWhereInput | otpScalarWhereInput[]
    OR?: otpScalarWhereInput[]
    NOT?: otpScalarWhereInput | otpScalarWhereInput[]
    otpID?: StringFilter<"otp"> | string
    otp?: StringFilter<"otp"> | string
    expiredAt?: DateTimeFilter<"otp"> | Date | string
    createdAt?: DateTimeFilter<"otp"> | Date | string
  }

  export type servicesUpsertWithWhereUniqueWithoutUserInput = {
    where: servicesWhereUniqueInput
    update: XOR<servicesUpdateWithoutUserInput, servicesUncheckedUpdateWithoutUserInput>
    create: XOR<servicesCreateWithoutUserInput, servicesUncheckedCreateWithoutUserInput>
  }

  export type servicesUpdateWithWhereUniqueWithoutUserInput = {
    where: servicesWhereUniqueInput
    data: XOR<servicesUpdateWithoutUserInput, servicesUncheckedUpdateWithoutUserInput>
  }

  export type servicesUpdateManyWithWhereWithoutUserInput = {
    where: servicesScalarWhereInput
    data: XOR<servicesUpdateManyMutationInput, servicesUncheckedUpdateManyWithoutUserInput>
  }

  export type servicesScalarWhereInput = {
    AND?: servicesScalarWhereInput | servicesScalarWhereInput[]
    OR?: servicesScalarWhereInput[]
    NOT?: servicesScalarWhereInput | servicesScalarWhereInput[]
    servicesID?: StringFilter<"services"> | string
    services?: StringFilter<"services"> | string
    descriptions?: StringFilter<"services"> | string
    image?: StringFilter<"services"> | string
    price?: FloatFilter<"services"> | number
    userID?: StringNullableFilter<"services"> | string | null
  }

  export type prediagUpsertWithWhereUniqueWithoutUserInput = {
    where: prediagWhereUniqueInput
    update: XOR<prediagUpdateWithoutUserInput, prediagUncheckedUpdateWithoutUserInput>
    create: XOR<prediagCreateWithoutUserInput, prediagUncheckedCreateWithoutUserInput>
  }

  export type prediagUpdateWithWhereUniqueWithoutUserInput = {
    where: prediagWhereUniqueInput
    data: XOR<prediagUpdateWithoutUserInput, prediagUncheckedUpdateWithoutUserInput>
  }

  export type prediagUpdateManyWithWhereWithoutUserInput = {
    where: prediagScalarWhereInput
    data: XOR<prediagUpdateManyMutationInput, prediagUncheckedUpdateManyWithoutUserInput>
  }

  export type prediagScalarWhereInput = {
    AND?: prediagScalarWhereInput | prediagScalarWhereInput[]
    OR?: prediagScalarWhereInput[]
    NOT?: prediagScalarWhereInput | prediagScalarWhereInput[]
    prediagnosticID?: StringFilter<"prediag"> | string
    age?: StringFilter<"prediag"> | string
    sex?: StringFilter<"prediag"> | string
    date?: StringFilter<"prediag"> | string
    time?: StringFilter<"prediag"> | string
    question1?: StringFilter<"prediag"> | string
    question2?: StringFilter<"prediag"> | string
    question3?: StringFilter<"prediag"> | string
    question4?: StringFilter<"prediag"> | string
    question5?: StringFilter<"prediag"> | string
    question6?: StringFilter<"prediag"> | string
    question7?: StringFilter<"prediag"> | string
    question8?: StringFilter<"prediag"> | string
    question9?: StringFilter<"prediag"> | string
    question10?: StringFilter<"prediag"> | string
    question11?: StringFilter<"prediag"> | string
    question12?: StringFilter<"prediag"> | string
    question13?: StringFilter<"prediag"> | string
    question14?: StringFilter<"prediag"> | string
    question15?: StringFilter<"prediag"> | string
    question16?: StringFilter<"prediag"> | string
    createdAt?: DateTimeFilter<"prediag"> | Date | string
    updatedAt?: DateTimeFilter<"prediag"> | Date | string
    userID?: StringNullableFilter<"prediag"> | string | null
  }

  export type userCreateWithoutServicesInput = {
    userID?: string
    email: string
    password: string
    role: $Enums.roles
    verified?: boolean
    creatdAt?: Date | string
    updateAt?: Date | string
    profile?: profileCreateNestedOneWithoutUserInput
    blog?: blogsCreateNestedManyWithoutUserInput
    faqs?: faqsCreateNestedManyWithoutUserInput
    equipment?: equipmentCreateNestedManyWithoutUserInput
    prescription?: presciptionCreateNestedManyWithoutPatinetInput
    feedback?: feedbackCreateNestedManyWithoutUserInput
    appointment?: appointmentCreateNestedManyWithoutUserInput
    diagnosis?: diagnosisCreateNestedManyWithoutUserInput
    otp?: otpCreateNestedManyWithoutUserInput
    preDiagnostic?: prediagCreateNestedManyWithoutUserInput
  }

  export type userUncheckedCreateWithoutServicesInput = {
    userID?: string
    email: string
    password: string
    role: $Enums.roles
    verified?: boolean
    creatdAt?: Date | string
    updateAt?: Date | string
    profile?: profileUncheckedCreateNestedOneWithoutUserInput
    blog?: blogsUncheckedCreateNestedManyWithoutUserInput
    faqs?: faqsUncheckedCreateNestedManyWithoutUserInput
    equipment?: equipmentUncheckedCreateNestedManyWithoutUserInput
    prescription?: presciptionUncheckedCreateNestedManyWithoutPatinetInput
    feedback?: feedbackUncheckedCreateNestedManyWithoutUserInput
    appointment?: appointmentUncheckedCreateNestedManyWithoutUserInput
    diagnosis?: diagnosisUncheckedCreateNestedManyWithoutUserInput
    otp?: otpUncheckedCreateNestedManyWithoutUserInput
    preDiagnostic?: prediagUncheckedCreateNestedManyWithoutUserInput
  }

  export type userCreateOrConnectWithoutServicesInput = {
    where: userWhereUniqueInput
    create: XOR<userCreateWithoutServicesInput, userUncheckedCreateWithoutServicesInput>
  }

  export type appointmentCreateWithoutServiceInput = {
    appointmentID?: string
    date: Date | string
    time: string
    services?: string | null
    platform: $Enums.platform
    link?: string | null
    amount: number
    status?: $Enums.status
    createdAt?: Date | string
    updatedAt?: Date | string
    user?: userCreateNestedManyWithoutAppointmentInput
    feedback?: feedbackCreateNestedOneWithoutAppointmentInput
  }

  export type appointmentUncheckedCreateWithoutServiceInput = {
    appointmentID?: string
    date: Date | string
    time: string
    services?: string | null
    platform: $Enums.platform
    link?: string | null
    amount: number
    status?: $Enums.status
    createdAt?: Date | string
    updatedAt?: Date | string
    feedbackID?: string | null
    user?: userUncheckedCreateNestedManyWithoutAppointmentInput
  }

  export type appointmentCreateOrConnectWithoutServiceInput = {
    where: appointmentWhereUniqueInput
    create: XOR<appointmentCreateWithoutServiceInput, appointmentUncheckedCreateWithoutServiceInput>
  }

  export type userUpsertWithoutServicesInput = {
    update: XOR<userUpdateWithoutServicesInput, userUncheckedUpdateWithoutServicesInput>
    create: XOR<userCreateWithoutServicesInput, userUncheckedCreateWithoutServicesInput>
    where?: userWhereInput
  }

  export type userUpdateToOneWithWhereWithoutServicesInput = {
    where?: userWhereInput
    data: XOR<userUpdateWithoutServicesInput, userUncheckedUpdateWithoutServicesInput>
  }

  export type userUpdateWithoutServicesInput = {
    userID?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    role?: EnumrolesFieldUpdateOperationsInput | $Enums.roles
    verified?: BoolFieldUpdateOperationsInput | boolean
    creatdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updateAt?: DateTimeFieldUpdateOperationsInput | Date | string
    profile?: profileUpdateOneWithoutUserNestedInput
    blog?: blogsUpdateManyWithoutUserNestedInput
    faqs?: faqsUpdateManyWithoutUserNestedInput
    equipment?: equipmentUpdateManyWithoutUserNestedInput
    prescription?: presciptionUpdateManyWithoutPatinetNestedInput
    feedback?: feedbackUpdateManyWithoutUserNestedInput
    appointment?: appointmentUpdateManyWithoutUserNestedInput
    diagnosis?: diagnosisUpdateManyWithoutUserNestedInput
    otp?: otpUpdateManyWithoutUserNestedInput
    preDiagnostic?: prediagUpdateManyWithoutUserNestedInput
  }

  export type userUncheckedUpdateWithoutServicesInput = {
    userID?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    role?: EnumrolesFieldUpdateOperationsInput | $Enums.roles
    verified?: BoolFieldUpdateOperationsInput | boolean
    creatdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updateAt?: DateTimeFieldUpdateOperationsInput | Date | string
    profile?: profileUncheckedUpdateOneWithoutUserNestedInput
    blog?: blogsUncheckedUpdateManyWithoutUserNestedInput
    faqs?: faqsUncheckedUpdateManyWithoutUserNestedInput
    equipment?: equipmentUncheckedUpdateManyWithoutUserNestedInput
    prescription?: presciptionUncheckedUpdateManyWithoutPatinetNestedInput
    feedback?: feedbackUncheckedUpdateManyWithoutUserNestedInput
    appointment?: appointmentUncheckedUpdateManyWithoutUserNestedInput
    diagnosis?: diagnosisUncheckedUpdateManyWithoutUserNestedInput
    otp?: otpUncheckedUpdateManyWithoutUserNestedInput
    preDiagnostic?: prediagUncheckedUpdateManyWithoutUserNestedInput
  }

  export type appointmentUpsertWithWhereUniqueWithoutServiceInput = {
    where: appointmentWhereUniqueInput
    update: XOR<appointmentUpdateWithoutServiceInput, appointmentUncheckedUpdateWithoutServiceInput>
    create: XOR<appointmentCreateWithoutServiceInput, appointmentUncheckedCreateWithoutServiceInput>
  }

  export type appointmentUpdateWithWhereUniqueWithoutServiceInput = {
    where: appointmentWhereUniqueInput
    data: XOR<appointmentUpdateWithoutServiceInput, appointmentUncheckedUpdateWithoutServiceInput>
  }

  export type appointmentUpdateManyWithWhereWithoutServiceInput = {
    where: appointmentScalarWhereInput
    data: XOR<appointmentUpdateManyMutationInput, appointmentUncheckedUpdateManyWithoutServiceInput>
  }

  export type userCreateWithoutOtpInput = {
    userID?: string
    email: string
    password: string
    role: $Enums.roles
    verified?: boolean
    creatdAt?: Date | string
    updateAt?: Date | string
    profile?: profileCreateNestedOneWithoutUserInput
    blog?: blogsCreateNestedManyWithoutUserInput
    faqs?: faqsCreateNestedManyWithoutUserInput
    equipment?: equipmentCreateNestedManyWithoutUserInput
    prescription?: presciptionCreateNestedManyWithoutPatinetInput
    feedback?: feedbackCreateNestedManyWithoutUserInput
    appointment?: appointmentCreateNestedManyWithoutUserInput
    diagnosis?: diagnosisCreateNestedManyWithoutUserInput
    services?: servicesCreateNestedManyWithoutUserInput
    preDiagnostic?: prediagCreateNestedManyWithoutUserInput
  }

  export type userUncheckedCreateWithoutOtpInput = {
    userID?: string
    email: string
    password: string
    role: $Enums.roles
    verified?: boolean
    creatdAt?: Date | string
    updateAt?: Date | string
    profile?: profileUncheckedCreateNestedOneWithoutUserInput
    blog?: blogsUncheckedCreateNestedManyWithoutUserInput
    faqs?: faqsUncheckedCreateNestedManyWithoutUserInput
    equipment?: equipmentUncheckedCreateNestedManyWithoutUserInput
    prescription?: presciptionUncheckedCreateNestedManyWithoutPatinetInput
    feedback?: feedbackUncheckedCreateNestedManyWithoutUserInput
    appointment?: appointmentUncheckedCreateNestedManyWithoutUserInput
    diagnosis?: diagnosisUncheckedCreateNestedManyWithoutUserInput
    services?: servicesUncheckedCreateNestedManyWithoutUserInput
    preDiagnostic?: prediagUncheckedCreateNestedManyWithoutUserInput
  }

  export type userCreateOrConnectWithoutOtpInput = {
    where: userWhereUniqueInput
    create: XOR<userCreateWithoutOtpInput, userUncheckedCreateWithoutOtpInput>
  }

  export type userUpsertWithWhereUniqueWithoutOtpInput = {
    where: userWhereUniqueInput
    update: XOR<userUpdateWithoutOtpInput, userUncheckedUpdateWithoutOtpInput>
    create: XOR<userCreateWithoutOtpInput, userUncheckedCreateWithoutOtpInput>
  }

  export type userUpdateWithWhereUniqueWithoutOtpInput = {
    where: userWhereUniqueInput
    data: XOR<userUpdateWithoutOtpInput, userUncheckedUpdateWithoutOtpInput>
  }

  export type userUpdateManyWithWhereWithoutOtpInput = {
    where: userScalarWhereInput
    data: XOR<userUpdateManyMutationInput, userUncheckedUpdateManyWithoutOtpInput>
  }

  export type userScalarWhereInput = {
    AND?: userScalarWhereInput | userScalarWhereInput[]
    OR?: userScalarWhereInput[]
    NOT?: userScalarWhereInput | userScalarWhereInput[]
    userID?: StringFilter<"user"> | string
    email?: StringFilter<"user"> | string
    password?: StringFilter<"user"> | string
    role?: EnumrolesFilter<"user"> | $Enums.roles
    verified?: BoolFilter<"user"> | boolean
    creatdAt?: DateTimeFilter<"user"> | Date | string
    updateAt?: DateTimeFilter<"user"> | Date | string
  }

  export type userCreateWithoutAppointmentInput = {
    userID?: string
    email: string
    password: string
    role: $Enums.roles
    verified?: boolean
    creatdAt?: Date | string
    updateAt?: Date | string
    profile?: profileCreateNestedOneWithoutUserInput
    blog?: blogsCreateNestedManyWithoutUserInput
    faqs?: faqsCreateNestedManyWithoutUserInput
    equipment?: equipmentCreateNestedManyWithoutUserInput
    prescription?: presciptionCreateNestedManyWithoutPatinetInput
    feedback?: feedbackCreateNestedManyWithoutUserInput
    diagnosis?: diagnosisCreateNestedManyWithoutUserInput
    otp?: otpCreateNestedManyWithoutUserInput
    services?: servicesCreateNestedManyWithoutUserInput
    preDiagnostic?: prediagCreateNestedManyWithoutUserInput
  }

  export type userUncheckedCreateWithoutAppointmentInput = {
    userID?: string
    email: string
    password: string
    role: $Enums.roles
    verified?: boolean
    creatdAt?: Date | string
    updateAt?: Date | string
    profile?: profileUncheckedCreateNestedOneWithoutUserInput
    blog?: blogsUncheckedCreateNestedManyWithoutUserInput
    faqs?: faqsUncheckedCreateNestedManyWithoutUserInput
    equipment?: equipmentUncheckedCreateNestedManyWithoutUserInput
    prescription?: presciptionUncheckedCreateNestedManyWithoutPatinetInput
    feedback?: feedbackUncheckedCreateNestedManyWithoutUserInput
    diagnosis?: diagnosisUncheckedCreateNestedManyWithoutUserInput
    otp?: otpUncheckedCreateNestedManyWithoutUserInput
    services?: servicesUncheckedCreateNestedManyWithoutUserInput
    preDiagnostic?: prediagUncheckedCreateNestedManyWithoutUserInput
  }

  export type userCreateOrConnectWithoutAppointmentInput = {
    where: userWhereUniqueInput
    create: XOR<userCreateWithoutAppointmentInput, userUncheckedCreateWithoutAppointmentInput>
  }

  export type feedbackCreateWithoutAppointmentInput = {
    feedbackID?: string
    therapistName: string
    date: string
    time: string
    question1: string
    question2: string
    question3: string
    question4: string
    question5: string
    question6: string
    question7: string
    question8: string
    feedback: string
    rating: number
    creatdAt?: Date | string
    updatedAt?: Date | string
    user?: userCreateNestedManyWithoutFeedbackInput
  }

  export type feedbackUncheckedCreateWithoutAppointmentInput = {
    feedbackID?: string
    therapistName: string
    date: string
    time: string
    question1: string
    question2: string
    question3: string
    question4: string
    question5: string
    question6: string
    question7: string
    question8: string
    feedback: string
    rating: number
    creatdAt?: Date | string
    updatedAt?: Date | string
    user?: userUncheckedCreateNestedManyWithoutFeedbackInput
  }

  export type feedbackCreateOrConnectWithoutAppointmentInput = {
    where: feedbackWhereUniqueInput
    create: XOR<feedbackCreateWithoutAppointmentInput, feedbackUncheckedCreateWithoutAppointmentInput>
  }

  export type servicesCreateWithoutAppointmentInput = {
    servicesID?: string
    services: string
    descriptions: string
    image: string
    price: number
    user?: userCreateNestedOneWithoutServicesInput
  }

  export type servicesUncheckedCreateWithoutAppointmentInput = {
    servicesID?: string
    services: string
    descriptions: string
    image: string
    price: number
    userID?: string | null
  }

  export type servicesCreateOrConnectWithoutAppointmentInput = {
    where: servicesWhereUniqueInput
    create: XOR<servicesCreateWithoutAppointmentInput, servicesUncheckedCreateWithoutAppointmentInput>
  }

  export type userUpsertWithWhereUniqueWithoutAppointmentInput = {
    where: userWhereUniqueInput
    update: XOR<userUpdateWithoutAppointmentInput, userUncheckedUpdateWithoutAppointmentInput>
    create: XOR<userCreateWithoutAppointmentInput, userUncheckedCreateWithoutAppointmentInput>
  }

  export type userUpdateWithWhereUniqueWithoutAppointmentInput = {
    where: userWhereUniqueInput
    data: XOR<userUpdateWithoutAppointmentInput, userUncheckedUpdateWithoutAppointmentInput>
  }

  export type userUpdateManyWithWhereWithoutAppointmentInput = {
    where: userScalarWhereInput
    data: XOR<userUpdateManyMutationInput, userUncheckedUpdateManyWithoutAppointmentInput>
  }

  export type feedbackUpsertWithoutAppointmentInput = {
    update: XOR<feedbackUpdateWithoutAppointmentInput, feedbackUncheckedUpdateWithoutAppointmentInput>
    create: XOR<feedbackCreateWithoutAppointmentInput, feedbackUncheckedCreateWithoutAppointmentInput>
    where?: feedbackWhereInput
  }

  export type feedbackUpdateToOneWithWhereWithoutAppointmentInput = {
    where?: feedbackWhereInput
    data: XOR<feedbackUpdateWithoutAppointmentInput, feedbackUncheckedUpdateWithoutAppointmentInput>
  }

  export type feedbackUpdateWithoutAppointmentInput = {
    feedbackID?: StringFieldUpdateOperationsInput | string
    therapistName?: StringFieldUpdateOperationsInput | string
    date?: StringFieldUpdateOperationsInput | string
    time?: StringFieldUpdateOperationsInput | string
    question1?: StringFieldUpdateOperationsInput | string
    question2?: StringFieldUpdateOperationsInput | string
    question3?: StringFieldUpdateOperationsInput | string
    question4?: StringFieldUpdateOperationsInput | string
    question5?: StringFieldUpdateOperationsInput | string
    question6?: StringFieldUpdateOperationsInput | string
    question7?: StringFieldUpdateOperationsInput | string
    question8?: StringFieldUpdateOperationsInput | string
    feedback?: StringFieldUpdateOperationsInput | string
    rating?: IntFieldUpdateOperationsInput | number
    creatdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: userUpdateManyWithoutFeedbackNestedInput
  }

  export type feedbackUncheckedUpdateWithoutAppointmentInput = {
    feedbackID?: StringFieldUpdateOperationsInput | string
    therapistName?: StringFieldUpdateOperationsInput | string
    date?: StringFieldUpdateOperationsInput | string
    time?: StringFieldUpdateOperationsInput | string
    question1?: StringFieldUpdateOperationsInput | string
    question2?: StringFieldUpdateOperationsInput | string
    question3?: StringFieldUpdateOperationsInput | string
    question4?: StringFieldUpdateOperationsInput | string
    question5?: StringFieldUpdateOperationsInput | string
    question6?: StringFieldUpdateOperationsInput | string
    question7?: StringFieldUpdateOperationsInput | string
    question8?: StringFieldUpdateOperationsInput | string
    feedback?: StringFieldUpdateOperationsInput | string
    rating?: IntFieldUpdateOperationsInput | number
    creatdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: userUncheckedUpdateManyWithoutFeedbackNestedInput
  }

  export type servicesUpsertWithWhereUniqueWithoutAppointmentInput = {
    where: servicesWhereUniqueInput
    update: XOR<servicesUpdateWithoutAppointmentInput, servicesUncheckedUpdateWithoutAppointmentInput>
    create: XOR<servicesCreateWithoutAppointmentInput, servicesUncheckedCreateWithoutAppointmentInput>
  }

  export type servicesUpdateWithWhereUniqueWithoutAppointmentInput = {
    where: servicesWhereUniqueInput
    data: XOR<servicesUpdateWithoutAppointmentInput, servicesUncheckedUpdateWithoutAppointmentInput>
  }

  export type servicesUpdateManyWithWhereWithoutAppointmentInput = {
    where: servicesScalarWhereInput
    data: XOR<servicesUpdateManyMutationInput, servicesUncheckedUpdateManyWithoutAppointmentInput>
  }

  export type userCreateWithoutEquipmentInput = {
    userID?: string
    email: string
    password: string
    role: $Enums.roles
    verified?: boolean
    creatdAt?: Date | string
    updateAt?: Date | string
    profile?: profileCreateNestedOneWithoutUserInput
    blog?: blogsCreateNestedManyWithoutUserInput
    faqs?: faqsCreateNestedManyWithoutUserInput
    prescription?: presciptionCreateNestedManyWithoutPatinetInput
    feedback?: feedbackCreateNestedManyWithoutUserInput
    appointment?: appointmentCreateNestedManyWithoutUserInput
    diagnosis?: diagnosisCreateNestedManyWithoutUserInput
    otp?: otpCreateNestedManyWithoutUserInput
    services?: servicesCreateNestedManyWithoutUserInput
    preDiagnostic?: prediagCreateNestedManyWithoutUserInput
  }

  export type userUncheckedCreateWithoutEquipmentInput = {
    userID?: string
    email: string
    password: string
    role: $Enums.roles
    verified?: boolean
    creatdAt?: Date | string
    updateAt?: Date | string
    profile?: profileUncheckedCreateNestedOneWithoutUserInput
    blog?: blogsUncheckedCreateNestedManyWithoutUserInput
    faqs?: faqsUncheckedCreateNestedManyWithoutUserInput
    prescription?: presciptionUncheckedCreateNestedManyWithoutPatinetInput
    feedback?: feedbackUncheckedCreateNestedManyWithoutUserInput
    appointment?: appointmentUncheckedCreateNestedManyWithoutUserInput
    diagnosis?: diagnosisUncheckedCreateNestedManyWithoutUserInput
    otp?: otpUncheckedCreateNestedManyWithoutUserInput
    services?: servicesUncheckedCreateNestedManyWithoutUserInput
    preDiagnostic?: prediagUncheckedCreateNestedManyWithoutUserInput
  }

  export type userCreateOrConnectWithoutEquipmentInput = {
    where: userWhereUniqueInput
    create: XOR<userCreateWithoutEquipmentInput, userUncheckedCreateWithoutEquipmentInput>
  }

  export type userUpsertWithWhereUniqueWithoutEquipmentInput = {
    where: userWhereUniqueInput
    update: XOR<userUpdateWithoutEquipmentInput, userUncheckedUpdateWithoutEquipmentInput>
    create: XOR<userCreateWithoutEquipmentInput, userUncheckedCreateWithoutEquipmentInput>
  }

  export type userUpdateWithWhereUniqueWithoutEquipmentInput = {
    where: userWhereUniqueInput
    data: XOR<userUpdateWithoutEquipmentInput, userUncheckedUpdateWithoutEquipmentInput>
  }

  export type userUpdateManyWithWhereWithoutEquipmentInput = {
    where: userScalarWhereInput
    data: XOR<userUpdateManyMutationInput, userUncheckedUpdateManyWithoutEquipmentInput>
  }

  export type userCreateWithoutBlogInput = {
    userID?: string
    email: string
    password: string
    role: $Enums.roles
    verified?: boolean
    creatdAt?: Date | string
    updateAt?: Date | string
    profile?: profileCreateNestedOneWithoutUserInput
    faqs?: faqsCreateNestedManyWithoutUserInput
    equipment?: equipmentCreateNestedManyWithoutUserInput
    prescription?: presciptionCreateNestedManyWithoutPatinetInput
    feedback?: feedbackCreateNestedManyWithoutUserInput
    appointment?: appointmentCreateNestedManyWithoutUserInput
    diagnosis?: diagnosisCreateNestedManyWithoutUserInput
    otp?: otpCreateNestedManyWithoutUserInput
    services?: servicesCreateNestedManyWithoutUserInput
    preDiagnostic?: prediagCreateNestedManyWithoutUserInput
  }

  export type userUncheckedCreateWithoutBlogInput = {
    userID?: string
    email: string
    password: string
    role: $Enums.roles
    verified?: boolean
    creatdAt?: Date | string
    updateAt?: Date | string
    profile?: profileUncheckedCreateNestedOneWithoutUserInput
    faqs?: faqsUncheckedCreateNestedManyWithoutUserInput
    equipment?: equipmentUncheckedCreateNestedManyWithoutUserInput
    prescription?: presciptionUncheckedCreateNestedManyWithoutPatinetInput
    feedback?: feedbackUncheckedCreateNestedManyWithoutUserInput
    appointment?: appointmentUncheckedCreateNestedManyWithoutUserInput
    diagnosis?: diagnosisUncheckedCreateNestedManyWithoutUserInput
    otp?: otpUncheckedCreateNestedManyWithoutUserInput
    services?: servicesUncheckedCreateNestedManyWithoutUserInput
    preDiagnostic?: prediagUncheckedCreateNestedManyWithoutUserInput
  }

  export type userCreateOrConnectWithoutBlogInput = {
    where: userWhereUniqueInput
    create: XOR<userCreateWithoutBlogInput, userUncheckedCreateWithoutBlogInput>
  }

  export type userUpsertWithWhereUniqueWithoutBlogInput = {
    where: userWhereUniqueInput
    update: XOR<userUpdateWithoutBlogInput, userUncheckedUpdateWithoutBlogInput>
    create: XOR<userCreateWithoutBlogInput, userUncheckedCreateWithoutBlogInput>
  }

  export type userUpdateWithWhereUniqueWithoutBlogInput = {
    where: userWhereUniqueInput
    data: XOR<userUpdateWithoutBlogInput, userUncheckedUpdateWithoutBlogInput>
  }

  export type userUpdateManyWithWhereWithoutBlogInput = {
    where: userScalarWhereInput
    data: XOR<userUpdateManyMutationInput, userUncheckedUpdateManyWithoutBlogInput>
  }

  export type userCreateWithoutFaqsInput = {
    userID?: string
    email: string
    password: string
    role: $Enums.roles
    verified?: boolean
    creatdAt?: Date | string
    updateAt?: Date | string
    profile?: profileCreateNestedOneWithoutUserInput
    blog?: blogsCreateNestedManyWithoutUserInput
    equipment?: equipmentCreateNestedManyWithoutUserInput
    prescription?: presciptionCreateNestedManyWithoutPatinetInput
    feedback?: feedbackCreateNestedManyWithoutUserInput
    appointment?: appointmentCreateNestedManyWithoutUserInput
    diagnosis?: diagnosisCreateNestedManyWithoutUserInput
    otp?: otpCreateNestedManyWithoutUserInput
    services?: servicesCreateNestedManyWithoutUserInput
    preDiagnostic?: prediagCreateNestedManyWithoutUserInput
  }

  export type userUncheckedCreateWithoutFaqsInput = {
    userID?: string
    email: string
    password: string
    role: $Enums.roles
    verified?: boolean
    creatdAt?: Date | string
    updateAt?: Date | string
    profile?: profileUncheckedCreateNestedOneWithoutUserInput
    blog?: blogsUncheckedCreateNestedManyWithoutUserInput
    equipment?: equipmentUncheckedCreateNestedManyWithoutUserInput
    prescription?: presciptionUncheckedCreateNestedManyWithoutPatinetInput
    feedback?: feedbackUncheckedCreateNestedManyWithoutUserInput
    appointment?: appointmentUncheckedCreateNestedManyWithoutUserInput
    diagnosis?: diagnosisUncheckedCreateNestedManyWithoutUserInput
    otp?: otpUncheckedCreateNestedManyWithoutUserInput
    services?: servicesUncheckedCreateNestedManyWithoutUserInput
    preDiagnostic?: prediagUncheckedCreateNestedManyWithoutUserInput
  }

  export type userCreateOrConnectWithoutFaqsInput = {
    where: userWhereUniqueInput
    create: XOR<userCreateWithoutFaqsInput, userUncheckedCreateWithoutFaqsInput>
  }

  export type userUpsertWithWhereUniqueWithoutFaqsInput = {
    where: userWhereUniqueInput
    update: XOR<userUpdateWithoutFaqsInput, userUncheckedUpdateWithoutFaqsInput>
    create: XOR<userCreateWithoutFaqsInput, userUncheckedCreateWithoutFaqsInput>
  }

  export type userUpdateWithWhereUniqueWithoutFaqsInput = {
    where: userWhereUniqueInput
    data: XOR<userUpdateWithoutFaqsInput, userUncheckedUpdateWithoutFaqsInput>
  }

  export type userUpdateManyWithWhereWithoutFaqsInput = {
    where: userScalarWhereInput
    data: XOR<userUpdateManyMutationInput, userUncheckedUpdateManyWithoutFaqsInput>
  }

  export type profileCreateWithoutAvatarInput = {
    profileID?: string
    firstname: string
    lastname: string
    phone: string
    designation?: string | null
    expertise?: string | null
    emergencyPhone?: string | null
    user?: userCreateNestedOneWithoutProfileInput
  }

  export type profileUncheckedCreateWithoutAvatarInput = {
    profileID?: string
    firstname: string
    lastname: string
    phone: string
    designation?: string | null
    expertise?: string | null
    emergencyPhone?: string | null
    userID?: string | null
  }

  export type profileCreateOrConnectWithoutAvatarInput = {
    where: profileWhereUniqueInput
    create: XOR<profileCreateWithoutAvatarInput, profileUncheckedCreateWithoutAvatarInput>
  }

  export type profileUpsertWithoutAvatarInput = {
    update: XOR<profileUpdateWithoutAvatarInput, profileUncheckedUpdateWithoutAvatarInput>
    create: XOR<profileCreateWithoutAvatarInput, profileUncheckedCreateWithoutAvatarInput>
    where?: profileWhereInput
  }

  export type profileUpdateToOneWithWhereWithoutAvatarInput = {
    where?: profileWhereInput
    data: XOR<profileUpdateWithoutAvatarInput, profileUncheckedUpdateWithoutAvatarInput>
  }

  export type profileUpdateWithoutAvatarInput = {
    profileID?: StringFieldUpdateOperationsInput | string
    firstname?: StringFieldUpdateOperationsInput | string
    lastname?: StringFieldUpdateOperationsInput | string
    phone?: StringFieldUpdateOperationsInput | string
    designation?: NullableStringFieldUpdateOperationsInput | string | null
    expertise?: NullableStringFieldUpdateOperationsInput | string | null
    emergencyPhone?: NullableStringFieldUpdateOperationsInput | string | null
    user?: userUpdateOneWithoutProfileNestedInput
  }

  export type profileUncheckedUpdateWithoutAvatarInput = {
    profileID?: StringFieldUpdateOperationsInput | string
    firstname?: StringFieldUpdateOperationsInput | string
    lastname?: StringFieldUpdateOperationsInput | string
    phone?: StringFieldUpdateOperationsInput | string
    designation?: NullableStringFieldUpdateOperationsInput | string | null
    expertise?: NullableStringFieldUpdateOperationsInput | string | null
    emergencyPhone?: NullableStringFieldUpdateOperationsInput | string | null
    userID?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type avatarCreateWithoutProfileInput = {
    avatarID?: string
    avatar: string
    creatdAt?: Date | string
    updateAt?: Date | string
  }

  export type avatarUncheckedCreateWithoutProfileInput = {
    avatarID?: string
    avatar: string
    creatdAt?: Date | string
    updateAt?: Date | string
  }

  export type avatarCreateOrConnectWithoutProfileInput = {
    where: avatarWhereUniqueInput
    create: XOR<avatarCreateWithoutProfileInput, avatarUncheckedCreateWithoutProfileInput>
  }

  export type userCreateWithoutProfileInput = {
    userID?: string
    email: string
    password: string
    role: $Enums.roles
    verified?: boolean
    creatdAt?: Date | string
    updateAt?: Date | string
    blog?: blogsCreateNestedManyWithoutUserInput
    faqs?: faqsCreateNestedManyWithoutUserInput
    equipment?: equipmentCreateNestedManyWithoutUserInput
    prescription?: presciptionCreateNestedManyWithoutPatinetInput
    feedback?: feedbackCreateNestedManyWithoutUserInput
    appointment?: appointmentCreateNestedManyWithoutUserInput
    diagnosis?: diagnosisCreateNestedManyWithoutUserInput
    otp?: otpCreateNestedManyWithoutUserInput
    services?: servicesCreateNestedManyWithoutUserInput
    preDiagnostic?: prediagCreateNestedManyWithoutUserInput
  }

  export type userUncheckedCreateWithoutProfileInput = {
    userID?: string
    email: string
    password: string
    role: $Enums.roles
    verified?: boolean
    creatdAt?: Date | string
    updateAt?: Date | string
    blog?: blogsUncheckedCreateNestedManyWithoutUserInput
    faqs?: faqsUncheckedCreateNestedManyWithoutUserInput
    equipment?: equipmentUncheckedCreateNestedManyWithoutUserInput
    prescription?: presciptionUncheckedCreateNestedManyWithoutPatinetInput
    feedback?: feedbackUncheckedCreateNestedManyWithoutUserInput
    appointment?: appointmentUncheckedCreateNestedManyWithoutUserInput
    diagnosis?: diagnosisUncheckedCreateNestedManyWithoutUserInput
    otp?: otpUncheckedCreateNestedManyWithoutUserInput
    services?: servicesUncheckedCreateNestedManyWithoutUserInput
    preDiagnostic?: prediagUncheckedCreateNestedManyWithoutUserInput
  }

  export type userCreateOrConnectWithoutProfileInput = {
    where: userWhereUniqueInput
    create: XOR<userCreateWithoutProfileInput, userUncheckedCreateWithoutProfileInput>
  }

  export type avatarUpsertWithoutProfileInput = {
    update: XOR<avatarUpdateWithoutProfileInput, avatarUncheckedUpdateWithoutProfileInput>
    create: XOR<avatarCreateWithoutProfileInput, avatarUncheckedCreateWithoutProfileInput>
    where?: avatarWhereInput
  }

  export type avatarUpdateToOneWithWhereWithoutProfileInput = {
    where?: avatarWhereInput
    data: XOR<avatarUpdateWithoutProfileInput, avatarUncheckedUpdateWithoutProfileInput>
  }

  export type avatarUpdateWithoutProfileInput = {
    avatarID?: StringFieldUpdateOperationsInput | string
    avatar?: StringFieldUpdateOperationsInput | string
    creatdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updateAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type avatarUncheckedUpdateWithoutProfileInput = {
    avatarID?: StringFieldUpdateOperationsInput | string
    avatar?: StringFieldUpdateOperationsInput | string
    creatdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updateAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type userUpsertWithoutProfileInput = {
    update: XOR<userUpdateWithoutProfileInput, userUncheckedUpdateWithoutProfileInput>
    create: XOR<userCreateWithoutProfileInput, userUncheckedCreateWithoutProfileInput>
    where?: userWhereInput
  }

  export type userUpdateToOneWithWhereWithoutProfileInput = {
    where?: userWhereInput
    data: XOR<userUpdateWithoutProfileInput, userUncheckedUpdateWithoutProfileInput>
  }

  export type userUpdateWithoutProfileInput = {
    userID?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    role?: EnumrolesFieldUpdateOperationsInput | $Enums.roles
    verified?: BoolFieldUpdateOperationsInput | boolean
    creatdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updateAt?: DateTimeFieldUpdateOperationsInput | Date | string
    blog?: blogsUpdateManyWithoutUserNestedInput
    faqs?: faqsUpdateManyWithoutUserNestedInput
    equipment?: equipmentUpdateManyWithoutUserNestedInput
    prescription?: presciptionUpdateManyWithoutPatinetNestedInput
    feedback?: feedbackUpdateManyWithoutUserNestedInput
    appointment?: appointmentUpdateManyWithoutUserNestedInput
    diagnosis?: diagnosisUpdateManyWithoutUserNestedInput
    otp?: otpUpdateManyWithoutUserNestedInput
    services?: servicesUpdateManyWithoutUserNestedInput
    preDiagnostic?: prediagUpdateManyWithoutUserNestedInput
  }

  export type userUncheckedUpdateWithoutProfileInput = {
    userID?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    role?: EnumrolesFieldUpdateOperationsInput | $Enums.roles
    verified?: BoolFieldUpdateOperationsInput | boolean
    creatdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updateAt?: DateTimeFieldUpdateOperationsInput | Date | string
    blog?: blogsUncheckedUpdateManyWithoutUserNestedInput
    faqs?: faqsUncheckedUpdateManyWithoutUserNestedInput
    equipment?: equipmentUncheckedUpdateManyWithoutUserNestedInput
    prescription?: presciptionUncheckedUpdateManyWithoutPatinetNestedInput
    feedback?: feedbackUncheckedUpdateManyWithoutUserNestedInput
    appointment?: appointmentUncheckedUpdateManyWithoutUserNestedInput
    diagnosis?: diagnosisUncheckedUpdateManyWithoutUserNestedInput
    otp?: otpUncheckedUpdateManyWithoutUserNestedInput
    services?: servicesUncheckedUpdateManyWithoutUserNestedInput
    preDiagnostic?: prediagUncheckedUpdateManyWithoutUserNestedInput
  }

  export type userCreateWithoutDiagnosisInput = {
    userID?: string
    email: string
    password: string
    role: $Enums.roles
    verified?: boolean
    creatdAt?: Date | string
    updateAt?: Date | string
    profile?: profileCreateNestedOneWithoutUserInput
    blog?: blogsCreateNestedManyWithoutUserInput
    faqs?: faqsCreateNestedManyWithoutUserInput
    equipment?: equipmentCreateNestedManyWithoutUserInput
    prescription?: presciptionCreateNestedManyWithoutPatinetInput
    feedback?: feedbackCreateNestedManyWithoutUserInput
    appointment?: appointmentCreateNestedManyWithoutUserInput
    otp?: otpCreateNestedManyWithoutUserInput
    services?: servicesCreateNestedManyWithoutUserInput
    preDiagnostic?: prediagCreateNestedManyWithoutUserInput
  }

  export type userUncheckedCreateWithoutDiagnosisInput = {
    userID?: string
    email: string
    password: string
    role: $Enums.roles
    verified?: boolean
    creatdAt?: Date | string
    updateAt?: Date | string
    profile?: profileUncheckedCreateNestedOneWithoutUserInput
    blog?: blogsUncheckedCreateNestedManyWithoutUserInput
    faqs?: faqsUncheckedCreateNestedManyWithoutUserInput
    equipment?: equipmentUncheckedCreateNestedManyWithoutUserInput
    prescription?: presciptionUncheckedCreateNestedManyWithoutPatinetInput
    feedback?: feedbackUncheckedCreateNestedManyWithoutUserInput
    appointment?: appointmentUncheckedCreateNestedManyWithoutUserInput
    otp?: otpUncheckedCreateNestedManyWithoutUserInput
    services?: servicesUncheckedCreateNestedManyWithoutUserInput
    preDiagnostic?: prediagUncheckedCreateNestedManyWithoutUserInput
  }

  export type userCreateOrConnectWithoutDiagnosisInput = {
    where: userWhereUniqueInput
    create: XOR<userCreateWithoutDiagnosisInput, userUncheckedCreateWithoutDiagnosisInput>
  }

  export type userUpsertWithoutDiagnosisInput = {
    update: XOR<userUpdateWithoutDiagnosisInput, userUncheckedUpdateWithoutDiagnosisInput>
    create: XOR<userCreateWithoutDiagnosisInput, userUncheckedCreateWithoutDiagnosisInput>
    where?: userWhereInput
  }

  export type userUpdateToOneWithWhereWithoutDiagnosisInput = {
    where?: userWhereInput
    data: XOR<userUpdateWithoutDiagnosisInput, userUncheckedUpdateWithoutDiagnosisInput>
  }

  export type userUpdateWithoutDiagnosisInput = {
    userID?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    role?: EnumrolesFieldUpdateOperationsInput | $Enums.roles
    verified?: BoolFieldUpdateOperationsInput | boolean
    creatdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updateAt?: DateTimeFieldUpdateOperationsInput | Date | string
    profile?: profileUpdateOneWithoutUserNestedInput
    blog?: blogsUpdateManyWithoutUserNestedInput
    faqs?: faqsUpdateManyWithoutUserNestedInput
    equipment?: equipmentUpdateManyWithoutUserNestedInput
    prescription?: presciptionUpdateManyWithoutPatinetNestedInput
    feedback?: feedbackUpdateManyWithoutUserNestedInput
    appointment?: appointmentUpdateManyWithoutUserNestedInput
    otp?: otpUpdateManyWithoutUserNestedInput
    services?: servicesUpdateManyWithoutUserNestedInput
    preDiagnostic?: prediagUpdateManyWithoutUserNestedInput
  }

  export type userUncheckedUpdateWithoutDiagnosisInput = {
    userID?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    role?: EnumrolesFieldUpdateOperationsInput | $Enums.roles
    verified?: BoolFieldUpdateOperationsInput | boolean
    creatdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updateAt?: DateTimeFieldUpdateOperationsInput | Date | string
    profile?: profileUncheckedUpdateOneWithoutUserNestedInput
    blog?: blogsUncheckedUpdateManyWithoutUserNestedInput
    faqs?: faqsUncheckedUpdateManyWithoutUserNestedInput
    equipment?: equipmentUncheckedUpdateManyWithoutUserNestedInput
    prescription?: presciptionUncheckedUpdateManyWithoutPatinetNestedInput
    feedback?: feedbackUncheckedUpdateManyWithoutUserNestedInput
    appointment?: appointmentUncheckedUpdateManyWithoutUserNestedInput
    otp?: otpUncheckedUpdateManyWithoutUserNestedInput
    services?: servicesUncheckedUpdateManyWithoutUserNestedInput
    preDiagnostic?: prediagUncheckedUpdateManyWithoutUserNestedInput
  }

  export type userCreateWithoutPrescriptionInput = {
    userID?: string
    email: string
    password: string
    role: $Enums.roles
    verified?: boolean
    creatdAt?: Date | string
    updateAt?: Date | string
    profile?: profileCreateNestedOneWithoutUserInput
    blog?: blogsCreateNestedManyWithoutUserInput
    faqs?: faqsCreateNestedManyWithoutUserInput
    equipment?: equipmentCreateNestedManyWithoutUserInput
    feedback?: feedbackCreateNestedManyWithoutUserInput
    appointment?: appointmentCreateNestedManyWithoutUserInput
    diagnosis?: diagnosisCreateNestedManyWithoutUserInput
    otp?: otpCreateNestedManyWithoutUserInput
    services?: servicesCreateNestedManyWithoutUserInput
    preDiagnostic?: prediagCreateNestedManyWithoutUserInput
  }

  export type userUncheckedCreateWithoutPrescriptionInput = {
    userID?: string
    email: string
    password: string
    role: $Enums.roles
    verified?: boolean
    creatdAt?: Date | string
    updateAt?: Date | string
    profile?: profileUncheckedCreateNestedOneWithoutUserInput
    blog?: blogsUncheckedCreateNestedManyWithoutUserInput
    faqs?: faqsUncheckedCreateNestedManyWithoutUserInput
    equipment?: equipmentUncheckedCreateNestedManyWithoutUserInput
    feedback?: feedbackUncheckedCreateNestedManyWithoutUserInput
    appointment?: appointmentUncheckedCreateNestedManyWithoutUserInput
    diagnosis?: diagnosisUncheckedCreateNestedManyWithoutUserInput
    otp?: otpUncheckedCreateNestedManyWithoutUserInput
    services?: servicesUncheckedCreateNestedManyWithoutUserInput
    preDiagnostic?: prediagUncheckedCreateNestedManyWithoutUserInput
  }

  export type userCreateOrConnectWithoutPrescriptionInput = {
    where: userWhereUniqueInput
    create: XOR<userCreateWithoutPrescriptionInput, userUncheckedCreateWithoutPrescriptionInput>
  }

  export type userUpsertWithoutPrescriptionInput = {
    update: XOR<userUpdateWithoutPrescriptionInput, userUncheckedUpdateWithoutPrescriptionInput>
    create: XOR<userCreateWithoutPrescriptionInput, userUncheckedCreateWithoutPrescriptionInput>
    where?: userWhereInput
  }

  export type userUpdateToOneWithWhereWithoutPrescriptionInput = {
    where?: userWhereInput
    data: XOR<userUpdateWithoutPrescriptionInput, userUncheckedUpdateWithoutPrescriptionInput>
  }

  export type userUpdateWithoutPrescriptionInput = {
    userID?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    role?: EnumrolesFieldUpdateOperationsInput | $Enums.roles
    verified?: BoolFieldUpdateOperationsInput | boolean
    creatdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updateAt?: DateTimeFieldUpdateOperationsInput | Date | string
    profile?: profileUpdateOneWithoutUserNestedInput
    blog?: blogsUpdateManyWithoutUserNestedInput
    faqs?: faqsUpdateManyWithoutUserNestedInput
    equipment?: equipmentUpdateManyWithoutUserNestedInput
    feedback?: feedbackUpdateManyWithoutUserNestedInput
    appointment?: appointmentUpdateManyWithoutUserNestedInput
    diagnosis?: diagnosisUpdateManyWithoutUserNestedInput
    otp?: otpUpdateManyWithoutUserNestedInput
    services?: servicesUpdateManyWithoutUserNestedInput
    preDiagnostic?: prediagUpdateManyWithoutUserNestedInput
  }

  export type userUncheckedUpdateWithoutPrescriptionInput = {
    userID?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    role?: EnumrolesFieldUpdateOperationsInput | $Enums.roles
    verified?: BoolFieldUpdateOperationsInput | boolean
    creatdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updateAt?: DateTimeFieldUpdateOperationsInput | Date | string
    profile?: profileUncheckedUpdateOneWithoutUserNestedInput
    blog?: blogsUncheckedUpdateManyWithoutUserNestedInput
    faqs?: faqsUncheckedUpdateManyWithoutUserNestedInput
    equipment?: equipmentUncheckedUpdateManyWithoutUserNestedInput
    feedback?: feedbackUncheckedUpdateManyWithoutUserNestedInput
    appointment?: appointmentUncheckedUpdateManyWithoutUserNestedInput
    diagnosis?: diagnosisUncheckedUpdateManyWithoutUserNestedInput
    otp?: otpUncheckedUpdateManyWithoutUserNestedInput
    services?: servicesUncheckedUpdateManyWithoutUserNestedInput
    preDiagnostic?: prediagUncheckedUpdateManyWithoutUserNestedInput
  }

  export type appointmentCreateWithoutFeedbackInput = {
    appointmentID?: string
    date: Date | string
    time: string
    services?: string | null
    platform: $Enums.platform
    link?: string | null
    amount: number
    status?: $Enums.status
    createdAt?: Date | string
    updatedAt?: Date | string
    user?: userCreateNestedManyWithoutAppointmentInput
    service?: servicesCreateNestedManyWithoutAppointmentInput
  }

  export type appointmentUncheckedCreateWithoutFeedbackInput = {
    appointmentID?: string
    date: Date | string
    time: string
    services?: string | null
    platform: $Enums.platform
    link?: string | null
    amount: number
    status?: $Enums.status
    createdAt?: Date | string
    updatedAt?: Date | string
    user?: userUncheckedCreateNestedManyWithoutAppointmentInput
    service?: servicesUncheckedCreateNestedManyWithoutAppointmentInput
  }

  export type appointmentCreateOrConnectWithoutFeedbackInput = {
    where: appointmentWhereUniqueInput
    create: XOR<appointmentCreateWithoutFeedbackInput, appointmentUncheckedCreateWithoutFeedbackInput>
  }

  export type appointmentCreateManyFeedbackInputEnvelope = {
    data: appointmentCreateManyFeedbackInput | appointmentCreateManyFeedbackInput[]
    skipDuplicates?: boolean
  }

  export type userCreateWithoutFeedbackInput = {
    userID?: string
    email: string
    password: string
    role: $Enums.roles
    verified?: boolean
    creatdAt?: Date | string
    updateAt?: Date | string
    profile?: profileCreateNestedOneWithoutUserInput
    blog?: blogsCreateNestedManyWithoutUserInput
    faqs?: faqsCreateNestedManyWithoutUserInput
    equipment?: equipmentCreateNestedManyWithoutUserInput
    prescription?: presciptionCreateNestedManyWithoutPatinetInput
    appointment?: appointmentCreateNestedManyWithoutUserInput
    diagnosis?: diagnosisCreateNestedManyWithoutUserInput
    otp?: otpCreateNestedManyWithoutUserInput
    services?: servicesCreateNestedManyWithoutUserInput
    preDiagnostic?: prediagCreateNestedManyWithoutUserInput
  }

  export type userUncheckedCreateWithoutFeedbackInput = {
    userID?: string
    email: string
    password: string
    role: $Enums.roles
    verified?: boolean
    creatdAt?: Date | string
    updateAt?: Date | string
    profile?: profileUncheckedCreateNestedOneWithoutUserInput
    blog?: blogsUncheckedCreateNestedManyWithoutUserInput
    faqs?: faqsUncheckedCreateNestedManyWithoutUserInput
    equipment?: equipmentUncheckedCreateNestedManyWithoutUserInput
    prescription?: presciptionUncheckedCreateNestedManyWithoutPatinetInput
    appointment?: appointmentUncheckedCreateNestedManyWithoutUserInput
    diagnosis?: diagnosisUncheckedCreateNestedManyWithoutUserInput
    otp?: otpUncheckedCreateNestedManyWithoutUserInput
    services?: servicesUncheckedCreateNestedManyWithoutUserInput
    preDiagnostic?: prediagUncheckedCreateNestedManyWithoutUserInput
  }

  export type userCreateOrConnectWithoutFeedbackInput = {
    where: userWhereUniqueInput
    create: XOR<userCreateWithoutFeedbackInput, userUncheckedCreateWithoutFeedbackInput>
  }

  export type appointmentUpsertWithWhereUniqueWithoutFeedbackInput = {
    where: appointmentWhereUniqueInput
    update: XOR<appointmentUpdateWithoutFeedbackInput, appointmentUncheckedUpdateWithoutFeedbackInput>
    create: XOR<appointmentCreateWithoutFeedbackInput, appointmentUncheckedCreateWithoutFeedbackInput>
  }

  export type appointmentUpdateWithWhereUniqueWithoutFeedbackInput = {
    where: appointmentWhereUniqueInput
    data: XOR<appointmentUpdateWithoutFeedbackInput, appointmentUncheckedUpdateWithoutFeedbackInput>
  }

  export type appointmentUpdateManyWithWhereWithoutFeedbackInput = {
    where: appointmentScalarWhereInput
    data: XOR<appointmentUpdateManyMutationInput, appointmentUncheckedUpdateManyWithoutFeedbackInput>
  }

  export type userUpsertWithWhereUniqueWithoutFeedbackInput = {
    where: userWhereUniqueInput
    update: XOR<userUpdateWithoutFeedbackInput, userUncheckedUpdateWithoutFeedbackInput>
    create: XOR<userCreateWithoutFeedbackInput, userUncheckedCreateWithoutFeedbackInput>
  }

  export type userUpdateWithWhereUniqueWithoutFeedbackInput = {
    where: userWhereUniqueInput
    data: XOR<userUpdateWithoutFeedbackInput, userUncheckedUpdateWithoutFeedbackInput>
  }

  export type userUpdateManyWithWhereWithoutFeedbackInput = {
    where: userScalarWhereInput
    data: XOR<userUpdateManyMutationInput, userUncheckedUpdateManyWithoutFeedbackInput>
  }

  export type userCreateWithoutPreDiagnosticInput = {
    userID?: string
    email: string
    password: string
    role: $Enums.roles
    verified?: boolean
    creatdAt?: Date | string
    updateAt?: Date | string
    profile?: profileCreateNestedOneWithoutUserInput
    blog?: blogsCreateNestedManyWithoutUserInput
    faqs?: faqsCreateNestedManyWithoutUserInput
    equipment?: equipmentCreateNestedManyWithoutUserInput
    prescription?: presciptionCreateNestedManyWithoutPatinetInput
    feedback?: feedbackCreateNestedManyWithoutUserInput
    appointment?: appointmentCreateNestedManyWithoutUserInput
    diagnosis?: diagnosisCreateNestedManyWithoutUserInput
    otp?: otpCreateNestedManyWithoutUserInput
    services?: servicesCreateNestedManyWithoutUserInput
  }

  export type userUncheckedCreateWithoutPreDiagnosticInput = {
    userID?: string
    email: string
    password: string
    role: $Enums.roles
    verified?: boolean
    creatdAt?: Date | string
    updateAt?: Date | string
    profile?: profileUncheckedCreateNestedOneWithoutUserInput
    blog?: blogsUncheckedCreateNestedManyWithoutUserInput
    faqs?: faqsUncheckedCreateNestedManyWithoutUserInput
    equipment?: equipmentUncheckedCreateNestedManyWithoutUserInput
    prescription?: presciptionUncheckedCreateNestedManyWithoutPatinetInput
    feedback?: feedbackUncheckedCreateNestedManyWithoutUserInput
    appointment?: appointmentUncheckedCreateNestedManyWithoutUserInput
    diagnosis?: diagnosisUncheckedCreateNestedManyWithoutUserInput
    otp?: otpUncheckedCreateNestedManyWithoutUserInput
    services?: servicesUncheckedCreateNestedManyWithoutUserInput
  }

  export type userCreateOrConnectWithoutPreDiagnosticInput = {
    where: userWhereUniqueInput
    create: XOR<userCreateWithoutPreDiagnosticInput, userUncheckedCreateWithoutPreDiagnosticInput>
  }

  export type userUpsertWithoutPreDiagnosticInput = {
    update: XOR<userUpdateWithoutPreDiagnosticInput, userUncheckedUpdateWithoutPreDiagnosticInput>
    create: XOR<userCreateWithoutPreDiagnosticInput, userUncheckedCreateWithoutPreDiagnosticInput>
    where?: userWhereInput
  }

  export type userUpdateToOneWithWhereWithoutPreDiagnosticInput = {
    where?: userWhereInput
    data: XOR<userUpdateWithoutPreDiagnosticInput, userUncheckedUpdateWithoutPreDiagnosticInput>
  }

  export type userUpdateWithoutPreDiagnosticInput = {
    userID?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    role?: EnumrolesFieldUpdateOperationsInput | $Enums.roles
    verified?: BoolFieldUpdateOperationsInput | boolean
    creatdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updateAt?: DateTimeFieldUpdateOperationsInput | Date | string
    profile?: profileUpdateOneWithoutUserNestedInput
    blog?: blogsUpdateManyWithoutUserNestedInput
    faqs?: faqsUpdateManyWithoutUserNestedInput
    equipment?: equipmentUpdateManyWithoutUserNestedInput
    prescription?: presciptionUpdateManyWithoutPatinetNestedInput
    feedback?: feedbackUpdateManyWithoutUserNestedInput
    appointment?: appointmentUpdateManyWithoutUserNestedInput
    diagnosis?: diagnosisUpdateManyWithoutUserNestedInput
    otp?: otpUpdateManyWithoutUserNestedInput
    services?: servicesUpdateManyWithoutUserNestedInput
  }

  export type userUncheckedUpdateWithoutPreDiagnosticInput = {
    userID?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    role?: EnumrolesFieldUpdateOperationsInput | $Enums.roles
    verified?: BoolFieldUpdateOperationsInput | boolean
    creatdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updateAt?: DateTimeFieldUpdateOperationsInput | Date | string
    profile?: profileUncheckedUpdateOneWithoutUserNestedInput
    blog?: blogsUncheckedUpdateManyWithoutUserNestedInput
    faqs?: faqsUncheckedUpdateManyWithoutUserNestedInput
    equipment?: equipmentUncheckedUpdateManyWithoutUserNestedInput
    prescription?: presciptionUncheckedUpdateManyWithoutPatinetNestedInput
    feedback?: feedbackUncheckedUpdateManyWithoutUserNestedInput
    appointment?: appointmentUncheckedUpdateManyWithoutUserNestedInput
    diagnosis?: diagnosisUncheckedUpdateManyWithoutUserNestedInput
    otp?: otpUncheckedUpdateManyWithoutUserNestedInput
    services?: servicesUncheckedUpdateManyWithoutUserNestedInput
  }

  export type presciptionCreateManyPatinetInput = {
    prescriptionID?: string
    prescription: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type diagnosisCreateManyUserInput = {
    diagnosisID?: string
    diagnosis?: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type servicesCreateManyUserInput = {
    servicesID?: string
    services: string
    descriptions: string
    image: string
    price: number
  }

  export type prediagCreateManyUserInput = {
    prediagnosticID?: string
    age: string
    sex: string
    date: string
    time: string
    question1: string
    question2: string
    question3: string
    question4: string
    question5: string
    question6: string
    question7: string
    question8: string
    question9: string
    question10: string
    question11: string
    question12: string
    question13: string
    question14: string
    question15: string
    question16: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type blogsUpdateWithoutUserInput = {
    blogsID?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    expertise?: StringFieldUpdateOperationsInput | string
    image?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type blogsUncheckedUpdateWithoutUserInput = {
    blogsID?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    expertise?: StringFieldUpdateOperationsInput | string
    image?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type blogsUncheckedUpdateManyWithoutUserInput = {
    blogsID?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    expertise?: StringFieldUpdateOperationsInput | string
    image?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type faqsUpdateWithoutUserInput = {
    faqsID?: StringFieldUpdateOperationsInput | string
    faqs?: StringFieldUpdateOperationsInput | string
    answer?: StringFieldUpdateOperationsInput | string
    creatdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updateAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type faqsUncheckedUpdateWithoutUserInput = {
    faqsID?: StringFieldUpdateOperationsInput | string
    faqs?: StringFieldUpdateOperationsInput | string
    answer?: StringFieldUpdateOperationsInput | string
    creatdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updateAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type faqsUncheckedUpdateManyWithoutUserInput = {
    faqsID?: StringFieldUpdateOperationsInput | string
    faqs?: StringFieldUpdateOperationsInput | string
    answer?: StringFieldUpdateOperationsInput | string
    creatdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updateAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type equipmentUpdateWithoutUserInput = {
    equipmentID?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    inventory?: EnuminventoryFieldUpdateOperationsInput | $Enums.inventory
    description?: StringFieldUpdateOperationsInput | string
    quantity?: IntFieldUpdateOperationsInput | number
    expireDate?: DateTimeFieldUpdateOperationsInput | Date | string
    creatdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updateAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type equipmentUncheckedUpdateWithoutUserInput = {
    equipmentID?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    inventory?: EnuminventoryFieldUpdateOperationsInput | $Enums.inventory
    description?: StringFieldUpdateOperationsInput | string
    quantity?: IntFieldUpdateOperationsInput | number
    expireDate?: DateTimeFieldUpdateOperationsInput | Date | string
    creatdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updateAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type equipmentUncheckedUpdateManyWithoutUserInput = {
    equipmentID?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    inventory?: EnuminventoryFieldUpdateOperationsInput | $Enums.inventory
    description?: StringFieldUpdateOperationsInput | string
    quantity?: IntFieldUpdateOperationsInput | number
    expireDate?: DateTimeFieldUpdateOperationsInput | Date | string
    creatdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updateAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type presciptionUpdateWithoutPatinetInput = {
    prescriptionID?: StringFieldUpdateOperationsInput | string
    prescription?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type presciptionUncheckedUpdateWithoutPatinetInput = {
    prescriptionID?: StringFieldUpdateOperationsInput | string
    prescription?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type presciptionUncheckedUpdateManyWithoutPatinetInput = {
    prescriptionID?: StringFieldUpdateOperationsInput | string
    prescription?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type feedbackUpdateWithoutUserInput = {
    feedbackID?: StringFieldUpdateOperationsInput | string
    therapistName?: StringFieldUpdateOperationsInput | string
    date?: StringFieldUpdateOperationsInput | string
    time?: StringFieldUpdateOperationsInput | string
    question1?: StringFieldUpdateOperationsInput | string
    question2?: StringFieldUpdateOperationsInput | string
    question3?: StringFieldUpdateOperationsInput | string
    question4?: StringFieldUpdateOperationsInput | string
    question5?: StringFieldUpdateOperationsInput | string
    question6?: StringFieldUpdateOperationsInput | string
    question7?: StringFieldUpdateOperationsInput | string
    question8?: StringFieldUpdateOperationsInput | string
    feedback?: StringFieldUpdateOperationsInput | string
    rating?: IntFieldUpdateOperationsInput | number
    creatdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    appointment?: appointmentUpdateManyWithoutFeedbackNestedInput
  }

  export type feedbackUncheckedUpdateWithoutUserInput = {
    feedbackID?: StringFieldUpdateOperationsInput | string
    therapistName?: StringFieldUpdateOperationsInput | string
    date?: StringFieldUpdateOperationsInput | string
    time?: StringFieldUpdateOperationsInput | string
    question1?: StringFieldUpdateOperationsInput | string
    question2?: StringFieldUpdateOperationsInput | string
    question3?: StringFieldUpdateOperationsInput | string
    question4?: StringFieldUpdateOperationsInput | string
    question5?: StringFieldUpdateOperationsInput | string
    question6?: StringFieldUpdateOperationsInput | string
    question7?: StringFieldUpdateOperationsInput | string
    question8?: StringFieldUpdateOperationsInput | string
    feedback?: StringFieldUpdateOperationsInput | string
    rating?: IntFieldUpdateOperationsInput | number
    creatdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    appointment?: appointmentUncheckedUpdateManyWithoutFeedbackNestedInput
  }

  export type feedbackUncheckedUpdateManyWithoutUserInput = {
    feedbackID?: StringFieldUpdateOperationsInput | string
    therapistName?: StringFieldUpdateOperationsInput | string
    date?: StringFieldUpdateOperationsInput | string
    time?: StringFieldUpdateOperationsInput | string
    question1?: StringFieldUpdateOperationsInput | string
    question2?: StringFieldUpdateOperationsInput | string
    question3?: StringFieldUpdateOperationsInput | string
    question4?: StringFieldUpdateOperationsInput | string
    question5?: StringFieldUpdateOperationsInput | string
    question6?: StringFieldUpdateOperationsInput | string
    question7?: StringFieldUpdateOperationsInput | string
    question8?: StringFieldUpdateOperationsInput | string
    feedback?: StringFieldUpdateOperationsInput | string
    rating?: IntFieldUpdateOperationsInput | number
    creatdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type appointmentUpdateWithoutUserInput = {
    appointmentID?: StringFieldUpdateOperationsInput | string
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    time?: StringFieldUpdateOperationsInput | string
    services?: NullableStringFieldUpdateOperationsInput | string | null
    platform?: EnumplatformFieldUpdateOperationsInput | $Enums.platform
    link?: NullableStringFieldUpdateOperationsInput | string | null
    amount?: IntFieldUpdateOperationsInput | number
    status?: EnumstatusFieldUpdateOperationsInput | $Enums.status
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    feedback?: feedbackUpdateOneWithoutAppointmentNestedInput
    service?: servicesUpdateManyWithoutAppointmentNestedInput
  }

  export type appointmentUncheckedUpdateWithoutUserInput = {
    appointmentID?: StringFieldUpdateOperationsInput | string
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    time?: StringFieldUpdateOperationsInput | string
    services?: NullableStringFieldUpdateOperationsInput | string | null
    platform?: EnumplatformFieldUpdateOperationsInput | $Enums.platform
    link?: NullableStringFieldUpdateOperationsInput | string | null
    amount?: IntFieldUpdateOperationsInput | number
    status?: EnumstatusFieldUpdateOperationsInput | $Enums.status
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    feedbackID?: NullableStringFieldUpdateOperationsInput | string | null
    service?: servicesUncheckedUpdateManyWithoutAppointmentNestedInput
  }

  export type appointmentUncheckedUpdateManyWithoutUserInput = {
    appointmentID?: StringFieldUpdateOperationsInput | string
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    time?: StringFieldUpdateOperationsInput | string
    services?: NullableStringFieldUpdateOperationsInput | string | null
    platform?: EnumplatformFieldUpdateOperationsInput | $Enums.platform
    link?: NullableStringFieldUpdateOperationsInput | string | null
    amount?: IntFieldUpdateOperationsInput | number
    status?: EnumstatusFieldUpdateOperationsInput | $Enums.status
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    feedbackID?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type diagnosisUpdateWithoutUserInput = {
    diagnosisID?: StringFieldUpdateOperationsInput | string
    diagnosis?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type diagnosisUncheckedUpdateWithoutUserInput = {
    diagnosisID?: StringFieldUpdateOperationsInput | string
    diagnosis?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type diagnosisUncheckedUpdateManyWithoutUserInput = {
    diagnosisID?: StringFieldUpdateOperationsInput | string
    diagnosis?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type otpUpdateWithoutUserInput = {
    otpID?: StringFieldUpdateOperationsInput | string
    otp?: StringFieldUpdateOperationsInput | string
    expiredAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type otpUncheckedUpdateWithoutUserInput = {
    otpID?: StringFieldUpdateOperationsInput | string
    otp?: StringFieldUpdateOperationsInput | string
    expiredAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type otpUncheckedUpdateManyWithoutUserInput = {
    otpID?: StringFieldUpdateOperationsInput | string
    otp?: StringFieldUpdateOperationsInput | string
    expiredAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type servicesUpdateWithoutUserInput = {
    servicesID?: StringFieldUpdateOperationsInput | string
    services?: StringFieldUpdateOperationsInput | string
    descriptions?: StringFieldUpdateOperationsInput | string
    image?: StringFieldUpdateOperationsInput | string
    price?: FloatFieldUpdateOperationsInput | number
    appointment?: appointmentUpdateManyWithoutServiceNestedInput
  }

  export type servicesUncheckedUpdateWithoutUserInput = {
    servicesID?: StringFieldUpdateOperationsInput | string
    services?: StringFieldUpdateOperationsInput | string
    descriptions?: StringFieldUpdateOperationsInput | string
    image?: StringFieldUpdateOperationsInput | string
    price?: FloatFieldUpdateOperationsInput | number
    appointment?: appointmentUncheckedUpdateManyWithoutServiceNestedInput
  }

  export type servicesUncheckedUpdateManyWithoutUserInput = {
    servicesID?: StringFieldUpdateOperationsInput | string
    services?: StringFieldUpdateOperationsInput | string
    descriptions?: StringFieldUpdateOperationsInput | string
    image?: StringFieldUpdateOperationsInput | string
    price?: FloatFieldUpdateOperationsInput | number
  }

  export type prediagUpdateWithoutUserInput = {
    prediagnosticID?: StringFieldUpdateOperationsInput | string
    age?: StringFieldUpdateOperationsInput | string
    sex?: StringFieldUpdateOperationsInput | string
    date?: StringFieldUpdateOperationsInput | string
    time?: StringFieldUpdateOperationsInput | string
    question1?: StringFieldUpdateOperationsInput | string
    question2?: StringFieldUpdateOperationsInput | string
    question3?: StringFieldUpdateOperationsInput | string
    question4?: StringFieldUpdateOperationsInput | string
    question5?: StringFieldUpdateOperationsInput | string
    question6?: StringFieldUpdateOperationsInput | string
    question7?: StringFieldUpdateOperationsInput | string
    question8?: StringFieldUpdateOperationsInput | string
    question9?: StringFieldUpdateOperationsInput | string
    question10?: StringFieldUpdateOperationsInput | string
    question11?: StringFieldUpdateOperationsInput | string
    question12?: StringFieldUpdateOperationsInput | string
    question13?: StringFieldUpdateOperationsInput | string
    question14?: StringFieldUpdateOperationsInput | string
    question15?: StringFieldUpdateOperationsInput | string
    question16?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type prediagUncheckedUpdateWithoutUserInput = {
    prediagnosticID?: StringFieldUpdateOperationsInput | string
    age?: StringFieldUpdateOperationsInput | string
    sex?: StringFieldUpdateOperationsInput | string
    date?: StringFieldUpdateOperationsInput | string
    time?: StringFieldUpdateOperationsInput | string
    question1?: StringFieldUpdateOperationsInput | string
    question2?: StringFieldUpdateOperationsInput | string
    question3?: StringFieldUpdateOperationsInput | string
    question4?: StringFieldUpdateOperationsInput | string
    question5?: StringFieldUpdateOperationsInput | string
    question6?: StringFieldUpdateOperationsInput | string
    question7?: StringFieldUpdateOperationsInput | string
    question8?: StringFieldUpdateOperationsInput | string
    question9?: StringFieldUpdateOperationsInput | string
    question10?: StringFieldUpdateOperationsInput | string
    question11?: StringFieldUpdateOperationsInput | string
    question12?: StringFieldUpdateOperationsInput | string
    question13?: StringFieldUpdateOperationsInput | string
    question14?: StringFieldUpdateOperationsInput | string
    question15?: StringFieldUpdateOperationsInput | string
    question16?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type prediagUncheckedUpdateManyWithoutUserInput = {
    prediagnosticID?: StringFieldUpdateOperationsInput | string
    age?: StringFieldUpdateOperationsInput | string
    sex?: StringFieldUpdateOperationsInput | string
    date?: StringFieldUpdateOperationsInput | string
    time?: StringFieldUpdateOperationsInput | string
    question1?: StringFieldUpdateOperationsInput | string
    question2?: StringFieldUpdateOperationsInput | string
    question3?: StringFieldUpdateOperationsInput | string
    question4?: StringFieldUpdateOperationsInput | string
    question5?: StringFieldUpdateOperationsInput | string
    question6?: StringFieldUpdateOperationsInput | string
    question7?: StringFieldUpdateOperationsInput | string
    question8?: StringFieldUpdateOperationsInput | string
    question9?: StringFieldUpdateOperationsInput | string
    question10?: StringFieldUpdateOperationsInput | string
    question11?: StringFieldUpdateOperationsInput | string
    question12?: StringFieldUpdateOperationsInput | string
    question13?: StringFieldUpdateOperationsInput | string
    question14?: StringFieldUpdateOperationsInput | string
    question15?: StringFieldUpdateOperationsInput | string
    question16?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type appointmentUpdateWithoutServiceInput = {
    appointmentID?: StringFieldUpdateOperationsInput | string
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    time?: StringFieldUpdateOperationsInput | string
    services?: NullableStringFieldUpdateOperationsInput | string | null
    platform?: EnumplatformFieldUpdateOperationsInput | $Enums.platform
    link?: NullableStringFieldUpdateOperationsInput | string | null
    amount?: IntFieldUpdateOperationsInput | number
    status?: EnumstatusFieldUpdateOperationsInput | $Enums.status
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: userUpdateManyWithoutAppointmentNestedInput
    feedback?: feedbackUpdateOneWithoutAppointmentNestedInput
  }

  export type appointmentUncheckedUpdateWithoutServiceInput = {
    appointmentID?: StringFieldUpdateOperationsInput | string
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    time?: StringFieldUpdateOperationsInput | string
    services?: NullableStringFieldUpdateOperationsInput | string | null
    platform?: EnumplatformFieldUpdateOperationsInput | $Enums.platform
    link?: NullableStringFieldUpdateOperationsInput | string | null
    amount?: IntFieldUpdateOperationsInput | number
    status?: EnumstatusFieldUpdateOperationsInput | $Enums.status
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    feedbackID?: NullableStringFieldUpdateOperationsInput | string | null
    user?: userUncheckedUpdateManyWithoutAppointmentNestedInput
  }

  export type appointmentUncheckedUpdateManyWithoutServiceInput = {
    appointmentID?: StringFieldUpdateOperationsInput | string
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    time?: StringFieldUpdateOperationsInput | string
    services?: NullableStringFieldUpdateOperationsInput | string | null
    platform?: EnumplatformFieldUpdateOperationsInput | $Enums.platform
    link?: NullableStringFieldUpdateOperationsInput | string | null
    amount?: IntFieldUpdateOperationsInput | number
    status?: EnumstatusFieldUpdateOperationsInput | $Enums.status
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    feedbackID?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type userUpdateWithoutOtpInput = {
    userID?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    role?: EnumrolesFieldUpdateOperationsInput | $Enums.roles
    verified?: BoolFieldUpdateOperationsInput | boolean
    creatdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updateAt?: DateTimeFieldUpdateOperationsInput | Date | string
    profile?: profileUpdateOneWithoutUserNestedInput
    blog?: blogsUpdateManyWithoutUserNestedInput
    faqs?: faqsUpdateManyWithoutUserNestedInput
    equipment?: equipmentUpdateManyWithoutUserNestedInput
    prescription?: presciptionUpdateManyWithoutPatinetNestedInput
    feedback?: feedbackUpdateManyWithoutUserNestedInput
    appointment?: appointmentUpdateManyWithoutUserNestedInput
    diagnosis?: diagnosisUpdateManyWithoutUserNestedInput
    services?: servicesUpdateManyWithoutUserNestedInput
    preDiagnostic?: prediagUpdateManyWithoutUserNestedInput
  }

  export type userUncheckedUpdateWithoutOtpInput = {
    userID?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    role?: EnumrolesFieldUpdateOperationsInput | $Enums.roles
    verified?: BoolFieldUpdateOperationsInput | boolean
    creatdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updateAt?: DateTimeFieldUpdateOperationsInput | Date | string
    profile?: profileUncheckedUpdateOneWithoutUserNestedInput
    blog?: blogsUncheckedUpdateManyWithoutUserNestedInput
    faqs?: faqsUncheckedUpdateManyWithoutUserNestedInput
    equipment?: equipmentUncheckedUpdateManyWithoutUserNestedInput
    prescription?: presciptionUncheckedUpdateManyWithoutPatinetNestedInput
    feedback?: feedbackUncheckedUpdateManyWithoutUserNestedInput
    appointment?: appointmentUncheckedUpdateManyWithoutUserNestedInput
    diagnosis?: diagnosisUncheckedUpdateManyWithoutUserNestedInput
    services?: servicesUncheckedUpdateManyWithoutUserNestedInput
    preDiagnostic?: prediagUncheckedUpdateManyWithoutUserNestedInput
  }

  export type userUncheckedUpdateManyWithoutOtpInput = {
    userID?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    role?: EnumrolesFieldUpdateOperationsInput | $Enums.roles
    verified?: BoolFieldUpdateOperationsInput | boolean
    creatdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updateAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type userUpdateWithoutAppointmentInput = {
    userID?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    role?: EnumrolesFieldUpdateOperationsInput | $Enums.roles
    verified?: BoolFieldUpdateOperationsInput | boolean
    creatdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updateAt?: DateTimeFieldUpdateOperationsInput | Date | string
    profile?: profileUpdateOneWithoutUserNestedInput
    blog?: blogsUpdateManyWithoutUserNestedInput
    faqs?: faqsUpdateManyWithoutUserNestedInput
    equipment?: equipmentUpdateManyWithoutUserNestedInput
    prescription?: presciptionUpdateManyWithoutPatinetNestedInput
    feedback?: feedbackUpdateManyWithoutUserNestedInput
    diagnosis?: diagnosisUpdateManyWithoutUserNestedInput
    otp?: otpUpdateManyWithoutUserNestedInput
    services?: servicesUpdateManyWithoutUserNestedInput
    preDiagnostic?: prediagUpdateManyWithoutUserNestedInput
  }

  export type userUncheckedUpdateWithoutAppointmentInput = {
    userID?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    role?: EnumrolesFieldUpdateOperationsInput | $Enums.roles
    verified?: BoolFieldUpdateOperationsInput | boolean
    creatdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updateAt?: DateTimeFieldUpdateOperationsInput | Date | string
    profile?: profileUncheckedUpdateOneWithoutUserNestedInput
    blog?: blogsUncheckedUpdateManyWithoutUserNestedInput
    faqs?: faqsUncheckedUpdateManyWithoutUserNestedInput
    equipment?: equipmentUncheckedUpdateManyWithoutUserNestedInput
    prescription?: presciptionUncheckedUpdateManyWithoutPatinetNestedInput
    feedback?: feedbackUncheckedUpdateManyWithoutUserNestedInput
    diagnosis?: diagnosisUncheckedUpdateManyWithoutUserNestedInput
    otp?: otpUncheckedUpdateManyWithoutUserNestedInput
    services?: servicesUncheckedUpdateManyWithoutUserNestedInput
    preDiagnostic?: prediagUncheckedUpdateManyWithoutUserNestedInput
  }

  export type userUncheckedUpdateManyWithoutAppointmentInput = {
    userID?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    role?: EnumrolesFieldUpdateOperationsInput | $Enums.roles
    verified?: BoolFieldUpdateOperationsInput | boolean
    creatdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updateAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type servicesUpdateWithoutAppointmentInput = {
    servicesID?: StringFieldUpdateOperationsInput | string
    services?: StringFieldUpdateOperationsInput | string
    descriptions?: StringFieldUpdateOperationsInput | string
    image?: StringFieldUpdateOperationsInput | string
    price?: FloatFieldUpdateOperationsInput | number
    user?: userUpdateOneWithoutServicesNestedInput
  }

  export type servicesUncheckedUpdateWithoutAppointmentInput = {
    servicesID?: StringFieldUpdateOperationsInput | string
    services?: StringFieldUpdateOperationsInput | string
    descriptions?: StringFieldUpdateOperationsInput | string
    image?: StringFieldUpdateOperationsInput | string
    price?: FloatFieldUpdateOperationsInput | number
    userID?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type servicesUncheckedUpdateManyWithoutAppointmentInput = {
    servicesID?: StringFieldUpdateOperationsInput | string
    services?: StringFieldUpdateOperationsInput | string
    descriptions?: StringFieldUpdateOperationsInput | string
    image?: StringFieldUpdateOperationsInput | string
    price?: FloatFieldUpdateOperationsInput | number
    userID?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type userUpdateWithoutEquipmentInput = {
    userID?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    role?: EnumrolesFieldUpdateOperationsInput | $Enums.roles
    verified?: BoolFieldUpdateOperationsInput | boolean
    creatdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updateAt?: DateTimeFieldUpdateOperationsInput | Date | string
    profile?: profileUpdateOneWithoutUserNestedInput
    blog?: blogsUpdateManyWithoutUserNestedInput
    faqs?: faqsUpdateManyWithoutUserNestedInput
    prescription?: presciptionUpdateManyWithoutPatinetNestedInput
    feedback?: feedbackUpdateManyWithoutUserNestedInput
    appointment?: appointmentUpdateManyWithoutUserNestedInput
    diagnosis?: diagnosisUpdateManyWithoutUserNestedInput
    otp?: otpUpdateManyWithoutUserNestedInput
    services?: servicesUpdateManyWithoutUserNestedInput
    preDiagnostic?: prediagUpdateManyWithoutUserNestedInput
  }

  export type userUncheckedUpdateWithoutEquipmentInput = {
    userID?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    role?: EnumrolesFieldUpdateOperationsInput | $Enums.roles
    verified?: BoolFieldUpdateOperationsInput | boolean
    creatdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updateAt?: DateTimeFieldUpdateOperationsInput | Date | string
    profile?: profileUncheckedUpdateOneWithoutUserNestedInput
    blog?: blogsUncheckedUpdateManyWithoutUserNestedInput
    faqs?: faqsUncheckedUpdateManyWithoutUserNestedInput
    prescription?: presciptionUncheckedUpdateManyWithoutPatinetNestedInput
    feedback?: feedbackUncheckedUpdateManyWithoutUserNestedInput
    appointment?: appointmentUncheckedUpdateManyWithoutUserNestedInput
    diagnosis?: diagnosisUncheckedUpdateManyWithoutUserNestedInput
    otp?: otpUncheckedUpdateManyWithoutUserNestedInput
    services?: servicesUncheckedUpdateManyWithoutUserNestedInput
    preDiagnostic?: prediagUncheckedUpdateManyWithoutUserNestedInput
  }

  export type userUncheckedUpdateManyWithoutEquipmentInput = {
    userID?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    role?: EnumrolesFieldUpdateOperationsInput | $Enums.roles
    verified?: BoolFieldUpdateOperationsInput | boolean
    creatdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updateAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type userUpdateWithoutBlogInput = {
    userID?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    role?: EnumrolesFieldUpdateOperationsInput | $Enums.roles
    verified?: BoolFieldUpdateOperationsInput | boolean
    creatdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updateAt?: DateTimeFieldUpdateOperationsInput | Date | string
    profile?: profileUpdateOneWithoutUserNestedInput
    faqs?: faqsUpdateManyWithoutUserNestedInput
    equipment?: equipmentUpdateManyWithoutUserNestedInput
    prescription?: presciptionUpdateManyWithoutPatinetNestedInput
    feedback?: feedbackUpdateManyWithoutUserNestedInput
    appointment?: appointmentUpdateManyWithoutUserNestedInput
    diagnosis?: diagnosisUpdateManyWithoutUserNestedInput
    otp?: otpUpdateManyWithoutUserNestedInput
    services?: servicesUpdateManyWithoutUserNestedInput
    preDiagnostic?: prediagUpdateManyWithoutUserNestedInput
  }

  export type userUncheckedUpdateWithoutBlogInput = {
    userID?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    role?: EnumrolesFieldUpdateOperationsInput | $Enums.roles
    verified?: BoolFieldUpdateOperationsInput | boolean
    creatdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updateAt?: DateTimeFieldUpdateOperationsInput | Date | string
    profile?: profileUncheckedUpdateOneWithoutUserNestedInput
    faqs?: faqsUncheckedUpdateManyWithoutUserNestedInput
    equipment?: equipmentUncheckedUpdateManyWithoutUserNestedInput
    prescription?: presciptionUncheckedUpdateManyWithoutPatinetNestedInput
    feedback?: feedbackUncheckedUpdateManyWithoutUserNestedInput
    appointment?: appointmentUncheckedUpdateManyWithoutUserNestedInput
    diagnosis?: diagnosisUncheckedUpdateManyWithoutUserNestedInput
    otp?: otpUncheckedUpdateManyWithoutUserNestedInput
    services?: servicesUncheckedUpdateManyWithoutUserNestedInput
    preDiagnostic?: prediagUncheckedUpdateManyWithoutUserNestedInput
  }

  export type userUncheckedUpdateManyWithoutBlogInput = {
    userID?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    role?: EnumrolesFieldUpdateOperationsInput | $Enums.roles
    verified?: BoolFieldUpdateOperationsInput | boolean
    creatdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updateAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type userUpdateWithoutFaqsInput = {
    userID?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    role?: EnumrolesFieldUpdateOperationsInput | $Enums.roles
    verified?: BoolFieldUpdateOperationsInput | boolean
    creatdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updateAt?: DateTimeFieldUpdateOperationsInput | Date | string
    profile?: profileUpdateOneWithoutUserNestedInput
    blog?: blogsUpdateManyWithoutUserNestedInput
    equipment?: equipmentUpdateManyWithoutUserNestedInput
    prescription?: presciptionUpdateManyWithoutPatinetNestedInput
    feedback?: feedbackUpdateManyWithoutUserNestedInput
    appointment?: appointmentUpdateManyWithoutUserNestedInput
    diagnosis?: diagnosisUpdateManyWithoutUserNestedInput
    otp?: otpUpdateManyWithoutUserNestedInput
    services?: servicesUpdateManyWithoutUserNestedInput
    preDiagnostic?: prediagUpdateManyWithoutUserNestedInput
  }

  export type userUncheckedUpdateWithoutFaqsInput = {
    userID?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    role?: EnumrolesFieldUpdateOperationsInput | $Enums.roles
    verified?: BoolFieldUpdateOperationsInput | boolean
    creatdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updateAt?: DateTimeFieldUpdateOperationsInput | Date | string
    profile?: profileUncheckedUpdateOneWithoutUserNestedInput
    blog?: blogsUncheckedUpdateManyWithoutUserNestedInput
    equipment?: equipmentUncheckedUpdateManyWithoutUserNestedInput
    prescription?: presciptionUncheckedUpdateManyWithoutPatinetNestedInput
    feedback?: feedbackUncheckedUpdateManyWithoutUserNestedInput
    appointment?: appointmentUncheckedUpdateManyWithoutUserNestedInput
    diagnosis?: diagnosisUncheckedUpdateManyWithoutUserNestedInput
    otp?: otpUncheckedUpdateManyWithoutUserNestedInput
    services?: servicesUncheckedUpdateManyWithoutUserNestedInput
    preDiagnostic?: prediagUncheckedUpdateManyWithoutUserNestedInput
  }

  export type userUncheckedUpdateManyWithoutFaqsInput = {
    userID?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    role?: EnumrolesFieldUpdateOperationsInput | $Enums.roles
    verified?: BoolFieldUpdateOperationsInput | boolean
    creatdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updateAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type appointmentCreateManyFeedbackInput = {
    appointmentID?: string
    date: Date | string
    time: string
    services?: string | null
    platform: $Enums.platform
    link?: string | null
    amount: number
    status?: $Enums.status
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type appointmentUpdateWithoutFeedbackInput = {
    appointmentID?: StringFieldUpdateOperationsInput | string
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    time?: StringFieldUpdateOperationsInput | string
    services?: NullableStringFieldUpdateOperationsInput | string | null
    platform?: EnumplatformFieldUpdateOperationsInput | $Enums.platform
    link?: NullableStringFieldUpdateOperationsInput | string | null
    amount?: IntFieldUpdateOperationsInput | number
    status?: EnumstatusFieldUpdateOperationsInput | $Enums.status
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: userUpdateManyWithoutAppointmentNestedInput
    service?: servicesUpdateManyWithoutAppointmentNestedInput
  }

  export type appointmentUncheckedUpdateWithoutFeedbackInput = {
    appointmentID?: StringFieldUpdateOperationsInput | string
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    time?: StringFieldUpdateOperationsInput | string
    services?: NullableStringFieldUpdateOperationsInput | string | null
    platform?: EnumplatformFieldUpdateOperationsInput | $Enums.platform
    link?: NullableStringFieldUpdateOperationsInput | string | null
    amount?: IntFieldUpdateOperationsInput | number
    status?: EnumstatusFieldUpdateOperationsInput | $Enums.status
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: userUncheckedUpdateManyWithoutAppointmentNestedInput
    service?: servicesUncheckedUpdateManyWithoutAppointmentNestedInput
  }

  export type appointmentUncheckedUpdateManyWithoutFeedbackInput = {
    appointmentID?: StringFieldUpdateOperationsInput | string
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    time?: StringFieldUpdateOperationsInput | string
    services?: NullableStringFieldUpdateOperationsInput | string | null
    platform?: EnumplatformFieldUpdateOperationsInput | $Enums.platform
    link?: NullableStringFieldUpdateOperationsInput | string | null
    amount?: IntFieldUpdateOperationsInput | number
    status?: EnumstatusFieldUpdateOperationsInput | $Enums.status
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type userUpdateWithoutFeedbackInput = {
    userID?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    role?: EnumrolesFieldUpdateOperationsInput | $Enums.roles
    verified?: BoolFieldUpdateOperationsInput | boolean
    creatdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updateAt?: DateTimeFieldUpdateOperationsInput | Date | string
    profile?: profileUpdateOneWithoutUserNestedInput
    blog?: blogsUpdateManyWithoutUserNestedInput
    faqs?: faqsUpdateManyWithoutUserNestedInput
    equipment?: equipmentUpdateManyWithoutUserNestedInput
    prescription?: presciptionUpdateManyWithoutPatinetNestedInput
    appointment?: appointmentUpdateManyWithoutUserNestedInput
    diagnosis?: diagnosisUpdateManyWithoutUserNestedInput
    otp?: otpUpdateManyWithoutUserNestedInput
    services?: servicesUpdateManyWithoutUserNestedInput
    preDiagnostic?: prediagUpdateManyWithoutUserNestedInput
  }

  export type userUncheckedUpdateWithoutFeedbackInput = {
    userID?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    role?: EnumrolesFieldUpdateOperationsInput | $Enums.roles
    verified?: BoolFieldUpdateOperationsInput | boolean
    creatdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updateAt?: DateTimeFieldUpdateOperationsInput | Date | string
    profile?: profileUncheckedUpdateOneWithoutUserNestedInput
    blog?: blogsUncheckedUpdateManyWithoutUserNestedInput
    faqs?: faqsUncheckedUpdateManyWithoutUserNestedInput
    equipment?: equipmentUncheckedUpdateManyWithoutUserNestedInput
    prescription?: presciptionUncheckedUpdateManyWithoutPatinetNestedInput
    appointment?: appointmentUncheckedUpdateManyWithoutUserNestedInput
    diagnosis?: diagnosisUncheckedUpdateManyWithoutUserNestedInput
    otp?: otpUncheckedUpdateManyWithoutUserNestedInput
    services?: servicesUncheckedUpdateManyWithoutUserNestedInput
    preDiagnostic?: prediagUncheckedUpdateManyWithoutUserNestedInput
  }

  export type userUncheckedUpdateManyWithoutFeedbackInput = {
    userID?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    role?: EnumrolesFieldUpdateOperationsInput | $Enums.roles
    verified?: BoolFieldUpdateOperationsInput | boolean
    creatdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updateAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }



  /**
   * Aliases for legacy arg types
   */
    /**
     * @deprecated Use UserCountOutputTypeDefaultArgs instead
     */
    export type UserCountOutputTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = UserCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use ServicesCountOutputTypeDefaultArgs instead
     */
    export type ServicesCountOutputTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = ServicesCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use OtpCountOutputTypeDefaultArgs instead
     */
    export type OtpCountOutputTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = OtpCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use AppointmentCountOutputTypeDefaultArgs instead
     */
    export type AppointmentCountOutputTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = AppointmentCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use EquipmentCountOutputTypeDefaultArgs instead
     */
    export type EquipmentCountOutputTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = EquipmentCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use BlogsCountOutputTypeDefaultArgs instead
     */
    export type BlogsCountOutputTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = BlogsCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use FaqsCountOutputTypeDefaultArgs instead
     */
    export type FaqsCountOutputTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = FaqsCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use FeedbackCountOutputTypeDefaultArgs instead
     */
    export type FeedbackCountOutputTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = FeedbackCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use userDefaultArgs instead
     */
    export type userArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = userDefaultArgs<ExtArgs>
    /**
     * @deprecated Use servicesDefaultArgs instead
     */
    export type servicesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = servicesDefaultArgs<ExtArgs>
    /**
     * @deprecated Use otpDefaultArgs instead
     */
    export type otpArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = otpDefaultArgs<ExtArgs>
    /**
     * @deprecated Use appointmentDefaultArgs instead
     */
    export type appointmentArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = appointmentDefaultArgs<ExtArgs>
    /**
     * @deprecated Use equipmentDefaultArgs instead
     */
    export type equipmentArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = equipmentDefaultArgs<ExtArgs>
    /**
     * @deprecated Use blogsDefaultArgs instead
     */
    export type blogsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = blogsDefaultArgs<ExtArgs>
    /**
     * @deprecated Use faqsDefaultArgs instead
     */
    export type faqsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = faqsDefaultArgs<ExtArgs>
    /**
     * @deprecated Use avatarDefaultArgs instead
     */
    export type avatarArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = avatarDefaultArgs<ExtArgs>
    /**
     * @deprecated Use profileDefaultArgs instead
     */
    export type profileArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = profileDefaultArgs<ExtArgs>
    /**
     * @deprecated Use diagnosisDefaultArgs instead
     */
    export type diagnosisArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = diagnosisDefaultArgs<ExtArgs>
    /**
     * @deprecated Use presciptionDefaultArgs instead
     */
    export type presciptionArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = presciptionDefaultArgs<ExtArgs>
    /**
     * @deprecated Use feedbackDefaultArgs instead
     */
    export type feedbackArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = feedbackDefaultArgs<ExtArgs>
    /**
     * @deprecated Use prediagDefaultArgs instead
     */
    export type prediagArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = prediagDefaultArgs<ExtArgs>

  /**
   * Batch Payload for updateMany & deleteMany & createMany
   */

  export type BatchPayload = {
    count: number
  }

  /**
   * DMMF
   */
  export const dmmf: runtime.BaseDMMF
}